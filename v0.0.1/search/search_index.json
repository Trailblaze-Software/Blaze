{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<code>BLAZE</code> <p>A LIDAR mapping tool for processing point cloud data</p> <p> </p> <p>Blaze is a LIDAR mapping tool designed for processing, analyzing, and visualizing point cloud data from LAS/LAZ files. Built with modern C++20, Blaze provides both command-line (<code>blaze-cli</code>) and graphical interfaces (<code>Blaze</code> and <code>Blaze3D</code>).</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>Quick Start Guide</li> <li>QGIS Plugin</li> <li>Contributing</li> </ul>"},{"location":"about/","title":"Contributing","text":"<p>Contributions are welcome! Please follow these guidelines to help maintain the quality of the project.</p>"},{"location":"about/#development-workflow","title":"Development Workflow","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally.</li> <li>Create a branch for your feature or bugfix.</li> <li>Commit your changes following the project's coding style (see below).</li> <li>Push to your fork and submit a Pull Request.</li> </ol>"},{"location":"about/#coding-standards","title":"Coding Standards","text":"<ul> <li>C++: We use C++20. Please follow the existing code style. We use <code>.clang-format</code> to maintain consistency.</li> <li>Python: Follow Black formatting.</li> <li>Pre-commit: We recommend installing <code>pre-commit</code> to automatically run linters before committing.</li> </ul> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"about/#licensing","title":"Licensing","text":"<p>By contributing to Blaze, you agree that your contributions will be licensed under the project's GPLv3 License.</p>"},{"location":"about/license/","title":"License","text":"<p>GNU GENERAL PUBLIC LICENSE                        Version 3, 29 June 2007</p> <p>Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/  Everyone is permitted to copy and distribute verbatim copies  of this license document, but changing it is not allowed.</p> <pre><code>                        Preamble\n</code></pre> <p>The GNU General Public License is a free, copyleft license for software and other kinds of works.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works.  By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.  We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors.  You can apply it to your programs, too.</p> <p>When we speak of free software, we are referring to freedom, not price.  Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights.  Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.</p> <p>For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received.  You must make sure that they, too, receive or can get the source code.  And you must show them these terms so they know their rights.</p> <p>Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.</p> <p>For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software.  For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.</p> <p>Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so.  This is fundamentally incompatible with the aim of protecting users' freedom to change the software.  The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable.  Therefore, we have designed this version of the GPL to prohibit the practice for those products.  If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.</p> <p>Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary.  To prevent this, the GPL assures that patents cannot be used to render the program non-free.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p> <pre><code>                   TERMS AND CONDITIONS\n</code></pre> <ol> <li>Definitions.</li> </ol> <p>\"This License\" refers to version 3 of the GNU General Public License.</p> <p>\"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\"The Program\" refers to any copyrightable work licensed under this License.  Each licensee is addressed as \"you\".  \"Licensees\" and \"recipients\" may be individuals or organizations.</p> <p>To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy.  The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work.</p> <p>A \"covered work\" means either the unmodified Program or a work based on the Program.</p> <p>To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy.  Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies.  Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License.  If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p> <ol> <li>Source Code.</li> </ol> <p>The \"source code\" for a work means the preferred form of the work for making modifications to it.  \"Object code\" means any non-source form of a work.</p> <p>A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form.  A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities.  However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work.  For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p> <ol> <li>Basic Permissions.</li> </ol> <p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met.  This License explicitly affirms your unlimited permission to run the unmodified Program.  The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work.  This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force.  You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright.  Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below.  Sublicensing is not allowed; section 10 makes it unnecessary.</p> <ol> <li>Protecting Users' Legal Rights From Anti-Circumvention Law.</li> </ol> <p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p> <ol> <li>Conveying Verbatim Copies.</li> </ol> <p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p> <ol> <li>Conveying Modified Source Versions.</li> </ol> <p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <pre><code>a) The work must carry prominent notices stating that you modified\nit, and giving a relevant date.\n\nb) The work must carry prominent notices stating that it is\nreleased under this License and any conditions added under section\n7.  This requirement modifies the requirement in section 4 to\n\"keep intact all notices\".\n\nc) You must license the entire work, as a whole, under this\nLicense to anyone who comes into possession of a copy.  This\nLicense will therefore apply, along with any applicable section 7\nadditional terms, to the whole of the work, and all its parts,\nregardless of how they are packaged.  This License gives no\npermission to license the work in any other way, but it does not\ninvalidate such permission if you have separately received it.\n\nd) If the work has interactive user interfaces, each must display\nAppropriate Legal Notices; however, if the Program has interactive\ninterfaces that do not display Appropriate Legal Notices, your\nwork need not make them do so.\n</code></pre> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit.  Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p> <ol> <li>Conveying Non-Source Forms.</li> </ol> <p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <pre><code>a) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by the\nCorresponding Source fixed on a durable physical medium\ncustomarily used for software interchange.\n\nb) Convey the object code in, or embodied in, a physical product\n(including a physical distribution medium), accompanied by a\nwritten offer, valid for at least three years and valid for as\nlong as you offer spare parts or customer support for that product\nmodel, to give anyone who possesses the object code either (1) a\ncopy of the Corresponding Source for all the software in the\nproduct that is covered by this License, on a durable physical\nmedium customarily used for software interchange, for a price no\nmore than your reasonable cost of physically performing this\nconveying of source, or (2) access to copy the\nCorresponding Source from a network server at no charge.\n\nc) Convey individual copies of the object code with a copy of the\nwritten offer to provide the Corresponding Source.  This\nalternative is allowed only occasionally and noncommercially, and\nonly if you received the object code with such an offer, in\naccord with subsection 6b.\n\nd) Convey the object code by offering access from a designated\nplace (gratis or for a charge), and offer equivalent access to the\nCorresponding Source in the same way through the same place at no\nfurther charge.  You need not require recipients to copy the\nCorresponding Source along with the object code.  If the place to\ncopy the object code is a network server, the Corresponding Source\nmay be on a different server (operated by you or a third party)\nthat supports equivalent copying facilities, provided you maintain\nclear directions next to the object code saying where to find the\nCorresponding Source.  Regardless of what server hosts the\nCorresponding Source, you remain obligated to ensure that it is\navailable for as long as needed to satisfy these requirements.\n\ne) Convey the object code using peer-to-peer transmission, provided\nyou inform other peers where the object code and Corresponding\nSource of the work are being offered to the general public at no\ncharge under subsection 6d.\n</code></pre> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling.  In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage.  For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is intended to use, the product.  A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source.  The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information.  But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed.  Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p> <ol> <li>Additional Terms.</li> </ol> <p>\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law.  If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it.  (Additional permissions may be written to require their own removal in certain cases when you modify the work.)  You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <pre><code>a) Disclaiming warranty or limiting liability differently from the\nterms of sections 15 and 16 of this License; or\n\nb) Requiring preservation of specified reasonable legal notices or\nauthor attributions in that material or in the Appropriate Legal\nNotices displayed by works containing it; or\n\nc) Prohibiting misrepresentation of the origin of that material, or\nrequiring that modified versions of such material be marked in\nreasonable ways as different from the original version; or\n\nd) Limiting the use for publicity purposes of names of licensors or\nauthors of the material; or\n\ne) Declining to grant rights under trademark law for use of some\ntrade names, trademarks, or service marks; or\n\nf) Requiring indemnification of licensors and authors of that\nmaterial by anyone who conveys the material (or modified versions of\nit) with contractual assumptions of liability to the recipient, for\nany liability that these contractual assumptions directly impose on\nthose licensors and authors.\n</code></pre> <p>All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10.  If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term.  If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p> <ol> <li>Termination.</li> </ol> <p>You may not propagate or modify a covered work except as expressly provided under this License.  Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License.  If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p> <ol> <li>Acceptance Not Required for Having Copies.</li> </ol> <p>You are not required to accept this License in order to receive or run a copy of the Program.  Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance.  However, nothing other than this License grants you permission to propagate or modify any covered work.  These actions infringe copyright if you do not accept this License.  Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p> <ol> <li>Automatic Licensing of Downstream Recipients.</li> </ol> <p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License.  You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations.  If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License.  For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p> <ol> <li>Patents.</li> </ol> <p>A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based.  The work thus licensed is called the contributor's \"contributor version\".</p> <p>A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version.  For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement).  To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients.  \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License.  You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p> <ol> <li>No Surrender of Others' Freedom.</li> </ol> <p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License.  If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all.  For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p> <ol> <li>Use with the GNU Affero General Public License.</li> </ol> <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work.  The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.</p> <ol> <li>Revised Versions of this License.</li> </ol> <p>The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number.  If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation.  If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions.  However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p> <ol> <li>Disclaimer of Warranty.</li> </ol> <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY   APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT   HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY   OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR   PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE   PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME   THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p> <ol> <li>Limitation of Liability.</li> </ol> <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING   WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS   THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY   GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE   USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF   DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR   THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER   PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE   POSSIBILITY OF SUCH DAMAGES.</p> <ol> <li>Interpretation of Sections 15 and 16.</li> </ol> <p>If the disclaimer of warranty and limitation of liability provided   above cannot be given local legal effect according to their terms,   reviewing courts shall apply local law that most closely approximates   an absolute waiver of all civil liability in connection with the   Program, unless a warranty or assumption of liability accompanies a   copy of the Program in return for a fee.</p> <pre><code>                 END OF TERMS AND CONDITIONS\n\n        How to Apply These Terms to Your New Programs\n</code></pre> <p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.</p> <p>To do so, attach the following notices to the program.  It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>&lt;one line to give the program's name and a brief idea of what it does.&gt;\nCopyright (C) &lt;year&gt;  &lt;name of author&gt;\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>If the program does terminal interaction, make it output a short   notice like this when it starts in an interactive mode:</p> <pre><code>&lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;\nThis program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n</code></pre> <p>The hypothetical commands <code>show w' and</code>show c' should show the appropriate parts of the General Public License.  Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\".</p> <p>You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/.</p> <p>The GNU General Public License does not permit incorporating your program into proprietary programs.  If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library.  If this is what you want to do, use the GNU Lesser General Public License instead of this License.  But first, please read https://www.gnu.org/licenses/why-not-lgpl.html.</p>"},{"location":"installation/","title":"Installation","text":"<p>The easiest way to install Blaze is to download pre-built binaries from the GitHub Releases page.</p>"},{"location":"installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download the latest release for your platform from:</p> <p>https://github.com/Trailblaze-Software/Blaze/releases</p> <p>For most users on Windows, this will be <code>Blaze-x.x.x-win64-x64.exe</code>. You will likely need to tell Windows that the download is safe and to keep anyway.</p>"},{"location":"installation/#building-from-source","title":"Building from Source","text":"<p>If you need to build from source or want to contribute to the project, see the Building from Source guide.</p>"},{"location":"installation/build-from-source/","title":"Building from Source","text":"<p>This guide covers how to build Blaze from source on Linux and Windows.</p>"},{"location":"installation/build-from-source/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":""},{"location":"installation/build-from-source/#prerequisites","title":"Prerequisites","text":"<p>Install the required dependencies:</p> <ul> <li>CMake (build system)</li> <li>GDAL (Geospatial Data Abstraction Library)</li> <li>OpenCV (Computer Vision library)</li> <li>Qt6 (GUI framework)</li> <li>OpenMP (parallel processing)</li> </ul> <p>which on Ubuntu can all be installed with the script</p> <pre><code>./scripts/install-ubuntu-deps.sh\n</code></pre>"},{"location":"installation/build-from-source/#building-from-source_1","title":"Building from Source","text":""},{"location":"installation/build-from-source/#1-configure-the-build","title":"1. Configure the build:","text":"<pre><code>cmake -B build\n</code></pre>"},{"location":"installation/build-from-source/#2-compile","title":"2. Compile:","text":"<pre><code>cmake --build build --config Release -j$(nproc)\n</code></pre> <p>Or use the provided build script:    <pre><code>./scripts/linux-build.sh\n</code></pre></p>"},{"location":"installation/build-from-source/#3-install-optional","title":"3. Install (optional):","text":"<pre><code>sudo cmake --install build\n</code></pre> <p>The following executables will be available in the <code>build</code> directory:</p> <ul> <li><code>blaze-cli</code> - Command-line interface</li> <li><code>Blaze</code> - Desktop GUI application (WIP)</li> <li><code>Blaze3D</code> - 3D visualization application (very WIP)</li> </ul>"},{"location":"installation/build-from-source/#windows","title":"Windows","text":""},{"location":"installation/build-from-source/#prerequisites_1","title":"Prerequisites","text":"<p>Option 1: Using vcpkg (Recommended)</p> <p>Blaze uses vcpkg for dependency management on Windows. The build system will automatically fetch, configure, and build dependencies but this can take several hours.</p> <p>Option 2: Manual Installation</p> <p>Install dependencies using Chocolatey:</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process\n.\\scripts\\install-deps-windows.ps1\n</code></pre> <p>This script installs:</p> <ul> <li>CMake</li> <li>Git</li> <li>GDAL</li> <li>OpenCV</li> </ul> <p>Note: You may need to run PowerShell as Administrator.</p>"},{"location":"installation/build-from-source/#building-from-source_2","title":"Building from Source","text":""},{"location":"installation/build-from-source/#1-configure-the-build_1","title":"1. Configure the build:","text":"<pre><code>cmake -B build\n</code></pre> <p>For CLI-only build (without GUI):    <pre><code>cmake -B build -DBLAZE_CLI_ONLY=ON\n</code></pre></p> <p>To disable vcpkg and use system packages:    <pre><code>cmake -B build -DBLAZE_USE_VCPKG=OFF\n</code></pre></p>"},{"location":"installation/build-from-source/#2-compile_1","title":"2. Compile:","text":"<pre><code>cmake --build build --config Release --parallel\n</code></pre>"},{"location":"installation/build-from-source/#3-install-optional_1","title":"3. Install (optional):","text":"<pre><code>cmake --install build --config Release\n</code></pre> <p>The executables will be available in the <code>build</code> directory:</p> <ul> <li><code>blaze-cli.exe</code> - Command-line interface</li> <li><code>Blaze.exe</code> - Desktop GUI application</li> <li><code>Blaze3D.exe</code> - 3D visualization application</li> </ul>"},{"location":"installation/build-from-source/#windows-installer","title":"Windows Installer","text":"<p>A Windows installer (NSIS) can be created using CPack:</p> <pre><code>cd build\ncpack -C Release -G NSIS\n</code></pre>"},{"location":"installation/build-from-source/#speeding-up-builds-vcpkg-caching","title":"Speeding up Builds (vcpkg Caching)","text":"<p>Blaze supports binary caching via GitHub Packages. This allows you to download pre-compiled dependencies instead of building them locally.</p> <ol> <li> <p>Install NuGet CLI:    If you don't have it already, install it via Chocolatey (run as Administrator):    <pre><code>choco install nuget.commandline\n</code></pre></p> </li> <li> <p>Generate a Personal Access Token (PAT):    Go to GitHub Settings &gt; Developer settings &gt; Personal access tokens (classic) and create a token with <code>read:packages</code> (and <code>write:packages</code> if you want to contribute binaries) scope.</p> </li> <li> <p>Add the NuGet source:    <pre><code>nuget sources add -Name \"GitHub\" `\n  -Source \"https://nuget.pkg.github.com/Trailblaze-Software/index.json\" `\n  -UserName \"YOUR_GITHUB_USERNAME\" `\n  -Password \"YOUR_PAT\"\n</code></pre></p> </li> <li> <p>Enable the cache:    Set the following environment variable before running CMake:    <pre><code>$env:VCPKG_BINARY_SOURCES=\"clear;nuget,GitHub,readwrite\"\n</code></pre></p> </li> </ol>"},{"location":"reference/","title":"Developers Reference","text":"<p>This section documents the internal C++ API of Blaze.</p>"},{"location":"reference/#api-indices","title":"API Indices","text":"<ul> <li>Classes: List of all classes and structs.</li> <li>Functions: List of all global functions.</li> <li>Files: List of source files.</li> </ul>"},{"location":"reference/releasing/","title":"Releasing Blaze","text":"<p>Blaze uses an automated release process triggered by GitHub tags. When a new version tag is pushed, the CI/CD pipeline builds binaries for multiple platforms, packages the QGIS plugin, and updates the documentation.</p>"},{"location":"reference/releasing/#how-to-create-a-release","title":"How to Create a Release","text":"<p>To trigger a new release, you need to create and push a git tag following the semantic versioning format (e.g., <code>v0.0.1</code>).</p>"},{"location":"reference/releasing/#using-the-command-line","title":"Using the Command Line","text":"<ol> <li> <p>Tag the latest commit:     <pre><code>git tag v0.0.1\n</code></pre></p> </li> <li> <p>Push the tag to GitHub:     <pre><code>git push origin v0.0.1\n</code></pre></p> </li> </ol>"},{"location":"reference/releasing/#using-the-github-ui","title":"Using the GitHub UI","text":"<ol> <li>Go to the repository on GitHub.</li> <li>Click on Releases in the right sidebar.</li> <li>Click Draft a new release.</li> <li>Click Choose a tag, type your version (e.g., <code>v0.0.1</code>), and select Create new tag.</li> <li>Click Publish release.</li> </ol>"},{"location":"reference/releasing/#what-happens-automatically","title":"What Happens Automatically","text":"<p>Once the tag is pushed, the following actions are performed:</p> <ol> <li>Application Binaries: The CI builds and attaches the following installers to the release:<ul> <li>Windows: x64 and ARM64 installers (.exe)</li> <li>Linux: x64 and ARM64 Debian packages (.deb)</li> </ul> </li> <li>QGIS Plugin: The Blaze Map Loader plugin is packaged into a <code>.zip</code> file and attached to the release.</li> <li>Documentation: A new version of the documentation site is published. The <code>latest</code> alias will be updated to point to this new release.</li> <li>Source Code: GitHub automatically bundles the source code as <code>.zip</code> and <code>.tar.gz</code> archives.</li> </ol>"},{"location":"reference/releasing/#versioning-policy","title":"Versioning Policy","text":"<p>We follow Semantic Versioning (SemVer): *   MAJOR version for incompatible API changes. *   MINOR version for functionality in a backwards compatible manner. *   PATCH version for backwards compatible bug fixes.</p>"},{"location":"usage/","title":"Quick Guide","text":"<p>Get started with processing LIDAR data using Blaze.</p>"},{"location":"usage/#command-line-interface-cli","title":"Command-Line Interface (CLI)","text":"<p>The <code>blaze-cli</code> is the core processing engine. You can provide a JSON configuration file to customize the processing pipeline. See the Configuration Reference for details.</p> <pre><code>./blaze-cli configs/config.json\n</code></pre>"},{"location":"usage/#gui-application","title":"GUI Application","text":"<p>For a more interactive and user-friendly experience, use the <code>Blaze</code> desktop application. This can also be used to load and save configuration files that can be used with the command-line interface.</p> <p>Launch <code>Blaze</code> (or <code>Blaze.exe</code> on Windows). You should get a screen that looks something like this.</p> <p></p> <p>You can optionally load a configuration you have saved earlier with <code>File &gt; Open Config</code> or <code>Ctrl + O</code>.</p> <p>You can now load your LAS/LAZ files using the <code>-</code>, <code>+</code>, and <code>+ Folder</code> buttons. The <code>+ Folder</code> can be used to add an entire folder of LIDAR tiles that will be processed together and combined.</p> <p>You can now configure the parameters such as scale and output resolution. The most important configuration option to play around with is the \"Bin Resolution\". For dense LIDAR such as we have in the ACT, 0.5m works well, however for sparser LIDAR such as in NSW, it is generally better to increase it, with 3m generally working well. We highly recommend testing and refining on a single LIDAR tile until you are happy with the output before processing a large area.</p> <p></p> <p>Finally, run the calculation with the <code>Run Blaze</code> button. This can take a long time for large amounts of LIDAR. I have found up to 5min/GB depending on processing capability. For large areas, you will need a lot of RAM to hold the final combined maps, or reduce the resolution.</p>"},{"location":"usage/#3d-visualization","title":"3D Visualization","text":"<p>The <code>Blaze3D</code> application is currently under development and provides a point cloud viewer for inspecting your data.</p>"},{"location":"usage/configuration/","title":"Configuration Reference","text":"<p>Blaze uses a JSON configuration file to control the processing pipeline. This file allows you to customize grid generation, contour intervals, feature detection parameters, and output rendering styles.</p>"},{"location":"usage/configuration/#example-configuration","title":"Example Configuration","text":"<pre><code>{\n  \"las_files\": [],\n  \"steps\": [\"tiles\", \"combine\"],\n  \"output_directory\": \"out\",\n  \"grid\": {\n    \"bin_resolution\": 0.5,\n    \"downsample_factor\": 3\n  },\n  \"ground\": {\n    \"outlier_removal_height_diff\": 0.3,\n    \"min_ground_intensity\": 0,\n    \"max_ground_intensity\": 65535\n  },\n  \"contours\": {\n    \"normal\": {\n      \"interval\": 5.0,\n      \"min_points\": 5,\n      \"color\": \"brown\",\n      \"width\": 0.14\n    },\n    \"index\": {\n      \"interval\": 25.0,\n      \"min_points\": 5,\n      \"color\": \"brown\",\n      \"width\": 0.25\n    }\n  },\n  \"water\": {\n    \"stream\": {\n      \"catchment\": 0.03,\n      \"color\": \"blue\",\n      \"width\": 0.18\n    }\n  },\n  \"vege\": {\n    \"background_color\": \"50% yellow\",\n    \"height_configs\": [\n      {\n        \"name\": \"canopy\",\n        \"min_height\": 2.5,\n        \"max_height\": 100,\n        \"colors\": [\n          {\n            \"blocking_threshold\": 0.1,\n            \"color\": \"white\"\n          }\n        ]\n      }\n    ]\n  },\n  \"buildings\": {\n    \"color\": \"black\"\n  },\n  \"render\": {\n    \"scale\": 10000,\n    \"dpi\": 600\n  },\n  \"colors\": {\n    \"primitive\": {\n      \"brown\": { \"cmyk\": [0, 56, 100, 18] },\n      \"blue\": { \"cmyk\": [100, 0, 0, 0] }\n    },\n    \"composite\": {\n      \"50% yellow\": { \"yellow\": 0.5 }\n    }\n  }\n}\n</code></pre>"},{"location":"usage/configuration/#sections","title":"Sections","text":""},{"location":"usage/configuration/#grid","title":"Grid","text":"<p>Controls the resolution of the digital elevation model (DEM). - <code>bin_resolution</code>: Size of each grid cell in meters. We generally want about 5-10 points per cell for good contour generation, so this should be set based on your point density. For recent ACT LIDAR, this can be as low as 0.5m, whilst for the sparser NSW data 3m is a good choice. - <code>downsample_factor</code>: Factor to downsample the grid for smoother contours elevation model.</p>"},{"location":"usage/configuration/#ground","title":"Ground","text":"<p>Parameters for ground point classification and filtering. - <code>outlier_removal_height_diff</code>: Minimum height difference for removing spikes. - <code>min_ground_intensity</code>: Minimum intensity value for ground points. - <code>max_ground_intensity</code>: Maximum intensity value for ground points.</p>"},{"location":"usage/configuration/#contours","title":"Contours","text":"<p>Defines contour lines. You can define multiple types (e.g., normal, index). - <code>interval</code>: Vertical distance between contours in meters. - <code>min_points</code>: Minimum points required to form a contour segment. - <code>color</code>: Name of the color (defined in <code>colors</code> section). - <code>width</code>: Line width in mm.</p>"},{"location":"usage/configuration/#water","title":"Water","text":"<p>Defines watercourse detection based on catchment area. - <code>catchment</code>: Threshold for catchment area to define a stream. - <code>color</code>: Color of the water line. - <code>width</code>: Line width in mm.</p>"},{"location":"usage/configuration/#vegetation","title":"Vegetation","text":"<p>Configures vegetation density and height mapping. - <code>background_color</code>: Base color for the vegetation layer. - <code>height_configs</code>: List of height bands (e.g., low vegetation, canopy).   - <code>min_height</code>: Minimum height of vegetation in this band.   - <code>max_height</code>: Maximum height.   - <code>colors</code>: List of colors based on blocking threshold (density).</p>"},{"location":"usage/configuration/#buildings","title":"Buildings","text":"<ul> <li><code>color</code>: Color for building footprints.</li> </ul>"},{"location":"usage/configuration/#render","title":"Render","text":"<p>Output settings. - <code>scale</code>: Map scale (e.g., 10000 for 1:10000). - <code>dpi</code>: Dots per inch for the output image.</p>"},{"location":"usage/configuration/#colors","title":"Colors","text":"<p>Defines the color palette. - <code>primitive</code>: Basic colors defined by RGB or CMYK.   - RGB example: <code>\"red\": { \"rgb\": [255, 0, 0, 255] }</code>   - CMYK example: <code>\"cyan\": { \"cmyk\": [100, 0, 0, 0] }</code> (Values 0-100) - <code>composite</code>: Mixed colors defined by percentage of other colors.   - Example: <code>\"light_green\": { \"green\": 0.3 }</code> (30% green)</p>"},{"location":"usage/qgis-plugin/","title":"QGIS Plugin","text":"<p>The Blaze Map Loader plugin simplifies importing processed results into QGIS.</p>"},{"location":"usage/qgis-plugin/#features","title":"Features","text":"<ul> <li>Automated Loading: Automatically loads output maps created by Blaze.</li> <li>Magnetic North: Overlays magnetic north lines.</li> <li>Topo Data: Integrates NSW topographic data where available.</li> <li>Styling: Applies predefined styles to layers for consistent visualization.</li> </ul>"},{"location":"usage/qgis-plugin/#installation","title":"Installation","text":"<ol> <li>Copy the <code>qgis_plugin/blaze_loader</code> folder to your QGIS plugins directory:</li> <li>Linux: <code>~/.local/share/QGIS/QGIS3/profiles/default/python/plugins/</code></li> <li>Windows: <code>%APPDATA%\\QGIS\\QGIS3\\profiles\\default\\python\\plugins</code></li> <li>Open QGIS.</li> <li>Go to Plugins &gt; Manage and Install Plugins.</li> <li>Enable Blaze Map Loader.</li> </ol>"},{"location":"usage/qgis-plugin/#usage","title":"Usage","text":"<p>Once enabled, look for the Blaze icon in your QGIS toolbar or under the Plugins menu. Use the dialog to select your Blaze output directory and load the data.</p>"},{"location":"blaze/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class AssetRetriever </li> <li>class AsyncLASData </li> <li>class AsyncProgressTracker </li> <li>struct BlazeBool </li> <li>struct BlockingThresholdColorPair </li> <li>struct BuildingsConfig </li> <li>class CMYKColor </li> <li>class Camera </li> <li>struct CanopyConfig </li> <li>class Color </li> <li>struct Config </li> <li>class ConfigEditor </li> <li>class Contour </li> <li>struct ContourConfig </li> <li>struct ContourConfigs </li> <li>class ContourPoint </li> <li>class Coordinate2D </li> <li>class Coordinate3D </li> <li>class Direction2D </li> <li>struct Extent2D </li> <li>struct Extent3D </li> <li>class FlexGrid </li> <li>class GDALDataset_w </li> <li>class GLWidget </li> <li>class GPKGWriter </li> <li>class Geo </li> <li>class GeoGridData </li> <li>class GeoImgGrid </li> <li>class GeoProjection </li> <li>class GeoTransform </li> <li>class Grid </li> <li>struct GridConfig </li> <li>class GridData </li> <li>class GridGraph </li> <li>struct GroundConfig </li> <li>class ImgGrid </li> <li>class LASData </li> <li>class LASFile </li> <li>class LASLayer </li> <li>class LASLayerRenderer </li> <li>class LASPoint </li> <li>class Layer </li> <li>class LayerRenderer </li> <li>class LineCoord2D </li> <li>class LineCoord2DCrossing </li> <li>class LocalDataRetriever </li> <li>class Main3DWindow </li> <li>class MainWindow </li> <li>class MultiBand </li> <li>class ParentFolderExistsValidator </li> <li>class PointLayer </li> <li>class Polyline </li> <li>struct PriorityPoint </li> <li>class ProgressBar </li> <li>class ProgressBox </li> <li>class ProgressObserver </li> <li>class ProgressTracker </li> <li>class ProgressTrackerBar </li> <li>class RGBColor </li> <li>struct RenderConfig </li> <li>struct Stream </li> <li>class TaskException </li> <li>class TestGrid </li> <li>class TimeFunction </li> <li>class Timer </li> <li>namespace Ui </li> <li>struct VegeConfig </li> <li>struct VegeHeightConfig </li> <li>struct WaterConfig </li> <li>struct WaterConfigs </li> <li>namespace cv <ul> <li>class Scalar_ </li> </ul> </li> <li>struct is_specialization </li> <li>struct is_specialization&lt; Ref&lt; Args... &gt;, Ref &gt; </li> <li>struct is_std_optional </li> <li>struct is_std_optional&lt; std::optional&lt; T &gt; &gt; </li> <li>namespace nlohmann <ul> <li>struct adl_serializer&lt; BlockingThresholdColorPair &gt; </li> <li>struct adl_serializer&lt; BuildingsConfig &gt; </li> <li>struct adl_serializer&lt; CMYKColor &gt; </li> <li>struct adl_serializer&lt; CanopyConfig &gt; </li> <li>struct adl_serializer&lt; ColorVariant &gt; </li> <li>struct adl_serializer&lt; ContourConfig &gt; </li> <li>struct adl_serializer&lt; ContourConfigs &gt; </li> <li>struct adl_serializer&lt; GridConfig &gt; </li> <li>struct adl_serializer&lt; GroundConfig &gt; </li> <li>struct adl_serializer&lt; RGBColor &gt; </li> <li>struct adl_serializer&lt; RenderConfig &gt; </li> <li>struct adl_serializer&lt; VegeConfig &gt; </li> <li>struct adl_serializer&lt; VegeHeightConfig &gt; </li> <li>struct adl_serializer&lt; WaterConfig &gt; </li> <li>struct adl_serializer&lt; WaterConfigs &gt; </li> </ul> </li> <li>namespace std </li> </ul>"},{"location":"blaze/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>dir gui <ul> <li>file camera.hpp </li> <li>file config_editor.cpp </li> <li>file config_editor.hpp </li> <li>file gl_widget.cpp </li> <li>file gl_widget.hpp </li> <li>file layer.hpp </li> <li>file layer_renderer.hpp </li> <li>file main.cpp </li> <li>file main_3d.cpp </li> <li>file main_3d_window.cpp </li> <li>file main_3d_window.hpp </li> <li>file main_window.cpp </li> <li>file main_window.hpp </li> <li>file progress_box.cpp </li> <li>file progress_box.hpp </li> </ul> </li> <li>dir lib <ul> <li>dir assert <ul> <li>file assert.hpp </li> <li>file gdal_assert.hpp </li> </ul> </li> <li>dir cliff <ul> <li>file cliff.hpp </li> </ul> </li> <li>dir config_input <ul> <li>file config_input.cpp </li> <li>file config_input.hpp </li> </ul> </li> <li>dir contour <ul> <li>dir tests <ul> <li>file test_contour_gen.cpp </li> </ul> </li> <li>file contour.cpp </li> <li>file contour.hpp </li> <li>file contour_gen.hpp </li> </ul> </li> <li>dir dxf <ul> <li>file dxf.hpp </li> </ul> </li> <li>dir grid <ul> <li>file forward_grid.hpp </li> <li>file grid.cpp </li> <li>file grid.hpp </li> <li>file grid_ops.hpp </li> <li>file img_grid.cpp </li> <li>file img_grid.hpp </li> </ul> </li> <li>dir io <ul> <li>file gpkg.hpp </li> </ul> </li> <li>dir isom <ul> <li>file colors.cpp </li> <li>file colors.hpp </li> </ul> </li> <li>dir las <ul> <li>file las_file.hpp </li> <li>file las_point.hpp </li> </ul> </li> <li>dir printing <ul> <li>file to_string.hpp </li> </ul> </li> <li>dir tif <ul> <li>file tif.cpp </li> <li>file tif.hpp </li> </ul> </li> <li>dir utilities <ul> <li>dir tests <ul> <li>file progress_tracker_helper.cpp </li> <li>file test_progress_tracker.cpp </li> </ul> </li> <li>file coordinate.hpp </li> <li>file filesystem.hpp </li> <li>file progress_tracker.cpp </li> <li>file progress_tracker.hpp </li> <li>file resources.cpp </li> <li>file resources.hpp </li> <li>file timer.hpp </li> </ul> </li> <li>dir vegetation <ul> <li>file vegetation.hpp </li> </ul> </li> </ul> </li> <li>dir methods <ul> <li>dir hill_shade <ul> <li>file hill_shade.hpp </li> </ul> </li> <li>dir water <ul> <li>dir tests <ul> <li>file test_water.cpp </li> </ul> </li> <li>file water.cpp </li> <li>file water.hpp </li> </ul> </li> </ul> </li> <li>file blaze.cpp </li> <li>file precompiled_headers.hpp </li> <li>file process.cpp </li> <li>file process.hpp </li> <li>file run.cpp </li> <li>file run.hpp </li> <li>file unit_tests.cpp </li> </ul> </li> </ul>"},{"location":"blaze/classAssetRetriever/","title":"Class AssetRetriever","text":"<p>ClassList &gt; AssetRetriever</p>"},{"location":"blaze/classAssetRetriever/#public-static-functions","title":"Public Static Functions","text":"Type Name fs::path get_asset (const fs::path &amp; asset)"},{"location":"blaze/classAssetRetriever/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/classAssetRetriever/#function-get_asset","title":"function get_asset","text":"<pre><code>static fs::path AssetRetriever::get_asset (\n    const fs::path &amp; asset\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/resources.hpp</code></p>"},{"location":"blaze/classAsyncLASData/","title":"Class AsyncLASData","text":"<p>ClassList &gt; AsyncLASData</p> <p>Inherits the following classes: LASData</p>"},{"location":"blaze/classAsyncLASData/#public-functions","title":"Public Functions","text":"Type Name AsyncLASData (const fs::path &amp; filename, AsyncProgressTracker progress_tracker, std::vector&lt; std::function&lt; void()&gt; &gt; callbacks={})  bool data_ready ()  std::mutex &amp; mutex ()  void wait_for_data ()  ~AsyncLASData ()"},{"location":"blaze/classAsyncLASData/#public-functions-inherited-from-lasdata","title":"Public Functions inherited from LASData","text":"<p>See LASData</p> Type Name LASData (const Extent2D &amp; bounds, const GeoProjection &amp; projection)  LASData (const GeoGrid&lt; T &gt; &amp; grid)  LASData (const fs::path &amp; filename, ProgressTracker progress_tracker, bool skip_reading_points=false, std::optional&lt; Extent2D &gt; bounds=std::nullopt)  auto begin ()  auto end ()  void extract_borders (const fs::path &amp; tmp_dir, double border_width, ProgressTracker progress_tracker) const void insert (const LASPoint &amp; point)  std::pair&lt; uint16_t, uint16_t &gt; intensity_range () const std::size_t n_points () const const LASPoint &amp; operator[] (std::size_t i) const LASPoint &amp; operator[] (std::size_t i)  void push_back (const LASPoint &amp; point)  void write (const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker={}) const"},{"location":"blaze/classAsyncLASData/#public-functions-inherited-from-lasfile","title":"Public Functions inherited from LASFile","text":"<p>See LASFile</p> Type Name LASFile (const Extent2D &amp; bounds, GeoProjection &amp;&amp; projection)  LASFile (const fs::path &amp; filename, ProgressTracker progress_tracker)  const Extent3D &amp; bounds () const Extent2D export_bounds () const double height () const std::pair&lt; double, double &gt; height_range () const Extent2D original_bounds () const const GeoProjection &amp; projection () const Coordinate2D&lt; double &gt; top_left () const double width () const"},{"location":"blaze/classAsyncLASData/#public-static-functions-inherited-from-lasdata","title":"Public Static Functions inherited from LASData","text":"<p>See LASData</p> Type Name LASData with_border (const fs::path &amp; filename, double border_width, const std::vector&lt; std::pair&lt; Extent3D, fs::path &gt; &gt; &amp; all_las_file_extents, ProgressTracker progress_tracker)  LASData with_border (const fs::path &amp; filename, double border_width, ProgressTracker progress_tracker)"},{"location":"blaze/classAsyncLASData/#protected-attributes-inherited-from-lasfile","title":"Protected Attributes inherited from LASFile","text":"<p>See LASFile</p> Type Name Extent3D m_bounds std::optional&lt; fs::path &gt; m_filename Extent3D m_original_bounds GeoProjection m_projection laspp::QuadtreeSpatialIndex m_spatial_index"},{"location":"blaze/classAsyncLASData/#protected-functions-inherited-from-lasdata","title":"Protected Functions inherited from LASData","text":"<p>See LASData</p> Type Name void read_points (laspp::LASReader &amp; reader, ProgressTracker progress_tracker, std::optional&lt; Extent2D &gt; bounds=std::nullopt)"},{"location":"blaze/classAsyncLASData/#protected-functions-inherited-from-lasfile","title":"Protected Functions inherited from LASFile","text":"<p>See LASFile</p> Type Name void from_las_reader (const laspp::LASReader &amp; reader)"},{"location":"blaze/classAsyncLASData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classAsyncLASData/#function-asynclasdata","title":"function AsyncLASData","text":"<pre><code>inline AsyncLASData::AsyncLASData (\n    const fs::path &amp; filename,\n    AsyncProgressTracker progress_tracker,\n    std::vector&lt; std::function&lt; void ()&gt; &gt; callbacks={}\n) \n</code></pre>"},{"location":"blaze/classAsyncLASData/#function-data_ready","title":"function data_ready","text":"<pre><code>inline bool AsyncLASData::data_ready () \n</code></pre>"},{"location":"blaze/classAsyncLASData/#function-mutex","title":"function mutex","text":"<pre><code>inline std::mutex &amp; AsyncLASData::mutex () \n</code></pre>"},{"location":"blaze/classAsyncLASData/#function-wait_for_data","title":"function wait_for_data","text":"<pre><code>inline void AsyncLASData::wait_for_data () \n</code></pre>"},{"location":"blaze/classAsyncLASData/#function-asynclasdata_1","title":"function ~AsyncLASData","text":"<pre><code>inline AsyncLASData::~AsyncLASData () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/las/las_file.hpp</code></p>"},{"location":"blaze/classAsyncProgressTracker/","title":"Class AsyncProgressTracker","text":"<p>ClassList &gt; AsyncProgressTracker</p>"},{"location":"blaze/classAsyncProgressTracker/#public-functions","title":"Public Functions","text":"Type Name AsyncProgressTracker ()  std::shared_ptr&lt; ProgressTracker &gt; tracker ()"},{"location":"blaze/classAsyncProgressTracker/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classAsyncProgressTracker/#function-asyncprogresstracker","title":"function AsyncProgressTracker","text":"<pre><code>inline AsyncProgressTracker::AsyncProgressTracker () \n</code></pre>"},{"location":"blaze/classAsyncProgressTracker/#function-tracker","title":"function tracker","text":"<pre><code>inline std::shared_ptr&lt; ProgressTracker &gt; AsyncProgressTracker::tracker () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/progress_tracker.hpp</code></p>"},{"location":"blaze/structBlazeBool/","title":"Struct BlazeBool","text":"<p>ClassList &gt; BlazeBool</p>"},{"location":"blaze/structBlazeBool/#public-attributes","title":"Public Attributes","text":"Type Name bool value"},{"location":"blaze/structBlazeBool/#public-functions","title":"Public Functions","text":"Type Name BlazeBool (bool value)  BlazeBool ()  operator bool () const BlazeBool &amp; operator= (bool new_value)"},{"location":"blaze/structBlazeBool/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structBlazeBool/#variable-value","title":"variable value","text":"<pre><code>bool BlazeBool::value;\n</code></pre>"},{"location":"blaze/structBlazeBool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/structBlazeBool/#function-blazebool-12","title":"function BlazeBool [1/2]","text":"<pre><code>inline BlazeBool::BlazeBool (\n    bool value\n) \n</code></pre>"},{"location":"blaze/structBlazeBool/#function-blazebool-22","title":"function BlazeBool [2/2]","text":"<pre><code>inline BlazeBool::BlazeBool () \n</code></pre>"},{"location":"blaze/structBlazeBool/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline BlazeBool::operator bool () const\n</code></pre>"},{"location":"blaze/structBlazeBool/#function-operator","title":"function operator=","text":"<pre><code>inline BlazeBool &amp; BlazeBool::operator= (\n    bool new_value\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/structBlockingThresholdColorPair/","title":"Struct BlockingThresholdColorPair","text":"<p>ClassList &gt; BlockingThresholdColorPair</p>"},{"location":"blaze/structBlockingThresholdColorPair/#public-attributes","title":"Public Attributes","text":"Type Name double blocking_threshold ColorVariant color"},{"location":"blaze/structBlockingThresholdColorPair/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structBlockingThresholdColorPair/#variable-blocking_threshold","title":"variable blocking_threshold","text":"<pre><code>double BlockingThresholdColorPair::blocking_threshold;\n</code></pre>"},{"location":"blaze/structBlockingThresholdColorPair/#variable-color","title":"variable color","text":"<pre><code>ColorVariant BlockingThresholdColorPair::color;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/structBuildingsConfig/","title":"Struct BuildingsConfig","text":"<p>ClassList &gt; BuildingsConfig</p>"},{"location":"blaze/structBuildingsConfig/#public-attributes","title":"Public Attributes","text":"Type Name ColorVariant color"},{"location":"blaze/structBuildingsConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structBuildingsConfig/#variable-color","title":"variable color","text":"<pre><code>ColorVariant BuildingsConfig::color;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/classCMYKColor/","title":"Class CMYKColor","text":"<p>ClassList &gt; CMYKColor</p> <p>Inherits the following classes: Color</p>"},{"location":"blaze/classCMYKColor/#public-functions","title":"Public Functions","text":"Type Name CMYKColor (unsigned char c, unsigned char m, unsigned char y, unsigned char k)  CMYKColor ()  unsigned char getBlack () const unsigned char getCyan () const unsigned char getMagenta () const unsigned char getYellow () const CMYKColor operator* (double factor) const CMYKColor operator+ (const CMYKColor &amp; other) const unsigned char operator[] (int index) const virtual CMYKColor toCMYK () override const virtual RGBColor toRGB () override const"},{"location":"blaze/classCMYKColor/#public-functions-inherited-from-color","title":"Public Functions inherited from Color","text":"<p>See Color</p> Type Name Color (const Color &amp;) = default Color () = default Color &amp; operator= (const Color &amp;) = default virtual CMYKColor toCMYK () const = 0 virtual RGBColor toRGB () const = 0 virtual ~Color () = default"},{"location":"blaze/classCMYKColor/#public-static-functions","title":"Public Static Functions","text":"Type Name CMYKColor FromRGB (const RGBColor &amp; rgb)"},{"location":"blaze/classCMYKColor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classCMYKColor/#function-cmykcolor-12","title":"function CMYKColor [1/2]","text":"<pre><code>CMYKColor::CMYKColor (\n    unsigned  char c,\n    unsigned  char m,\n    unsigned  char y,\n    unsigned  char k\n) \n</code></pre>"},{"location":"blaze/classCMYKColor/#function-cmykcolor-22","title":"function CMYKColor [2/2]","text":"<pre><code>inline CMYKColor::CMYKColor () \n</code></pre>"},{"location":"blaze/classCMYKColor/#function-getblack","title":"function getBlack","text":"<pre><code>inline unsigned  char CMYKColor::getBlack () const\n</code></pre>"},{"location":"blaze/classCMYKColor/#function-getcyan","title":"function getCyan","text":"<pre><code>inline unsigned  char CMYKColor::getCyan () const\n</code></pre>"},{"location":"blaze/classCMYKColor/#function-getmagenta","title":"function getMagenta","text":"<pre><code>inline unsigned  char CMYKColor::getMagenta () const\n</code></pre>"},{"location":"blaze/classCMYKColor/#function-getyellow","title":"function getYellow","text":"<pre><code>inline unsigned  char CMYKColor::getYellow () const\n</code></pre>"},{"location":"blaze/classCMYKColor/#function-operator","title":"function operator*","text":"<pre><code>inline CMYKColor CMYKColor::operator* (\n    double factor\n) const\n</code></pre>"},{"location":"blaze/classCMYKColor/#function-operator_1","title":"function operator+","text":"<pre><code>inline CMYKColor CMYKColor::operator+ (\n    const  CMYKColor &amp; other\n) const\n</code></pre>"},{"location":"blaze/classCMYKColor/#function-operator_2","title":"function operator[]","text":"<pre><code>inline unsigned  char CMYKColor::operator[] (\n    int index\n) const\n</code></pre>"},{"location":"blaze/classCMYKColor/#function-tocmyk","title":"function toCMYK","text":"<pre><code>inline virtual CMYKColor CMYKColor::toCMYK () override const\n</code></pre> <p>Implements Color::toCMYK</p>"},{"location":"blaze/classCMYKColor/#function-torgb","title":"function toRGB","text":"<pre><code>inline virtual RGBColor CMYKColor::toRGB () override const\n</code></pre> <p>Implements Color::toRGB</p>"},{"location":"blaze/classCMYKColor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/classCMYKColor/#function-fromrgb","title":"function FromRGB","text":"<pre><code>static CMYKColor CMYKColor::FromRGB (\n    const  RGBColor &amp; rgb\n) \n</code></pre>"},{"location":"blaze/classCMYKColor/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classCMYKColor/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; CMYKColor::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  CMYKColor &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/isom/colors.hpp</code></p>"},{"location":"blaze/classCamera/","title":"Class Camera","text":"<p>ClassList &gt; Camera</p>"},{"location":"blaze/classCamera/#public-functions","title":"Public Functions","text":"Type Name Camera (int width, int height)  Camera (const QVector3D &amp; position, const QVector3D &amp; direction, const QVector3D &amp; up)  double current_altitude_angle () const const QVector3D &amp; direction () const void fly (double dx, double dy, double dz)  void move (const QVector3D &amp; direction)  void move_towards (const QVector3D &amp; world_pos, double distance, bool shrink_direction=false)  void pan (double dx, double dy)  QVector3D planar_direction () const const QVector3D &amp; position () const QMatrix4x4 proj_matrix () const double projection_scale () const void reset_to_origin ()  void rotate_around_center (double dx, double dy, const std::optional&lt; QVector3D &gt; &amp; center=std::nullopt)  void rotate_view (double dx, double dy)  void set_screen_size (int width, int height)  QVector3D unproject (const QPointF &amp; screen_pos) const const QVector3D &amp; up () const QVector3D view_right () const QVector3D view_up () const const Coordinate3D&lt; double &gt; &amp; world_offset () const Coordinate3D&lt; double &gt; &amp; world_offset ()  void zoom_to_fit (const Extent3D &amp; extent)"},{"location":"blaze/classCamera/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classCamera/#function-camera-12","title":"function Camera [1/2]","text":"<pre><code>inline Camera::Camera (\n    int width,\n    int height\n) \n</code></pre>"},{"location":"blaze/classCamera/#function-camera-22","title":"function Camera [2/2]","text":"<pre><code>inline Camera::Camera (\n    const  QVector3D &amp; position,\n    const  QVector3D &amp; direction,\n    const  QVector3D &amp; up\n) \n</code></pre>"},{"location":"blaze/classCamera/#function-current_altitude_angle","title":"function current_altitude_angle","text":"<pre><code>inline double Camera::current_altitude_angle () const\n</code></pre>"},{"location":"blaze/classCamera/#function-direction","title":"function direction","text":"<pre><code>inline const  QVector3D &amp; Camera::direction () const\n</code></pre>"},{"location":"blaze/classCamera/#function-fly","title":"function fly","text":"<pre><code>inline void Camera::fly (\n    double dx,\n    double dy,\n    double dz\n) \n</code></pre>"},{"location":"blaze/classCamera/#function-move","title":"function move","text":"<pre><code>inline void Camera::move (\n    const  QVector3D &amp; direction\n) \n</code></pre>"},{"location":"blaze/classCamera/#function-move_towards","title":"function move_towards","text":"<pre><code>inline void Camera::move_towards (\n    const  QVector3D &amp; world_pos,\n    double distance,\n    bool shrink_direction=false\n) \n</code></pre>"},{"location":"blaze/classCamera/#function-pan","title":"function pan","text":"<pre><code>inline void Camera::pan (\n    double dx,\n    double dy\n) \n</code></pre>"},{"location":"blaze/classCamera/#function-planar_direction","title":"function planar_direction","text":"<pre><code>inline QVector3D Camera::planar_direction () const\n</code></pre>"},{"location":"blaze/classCamera/#function-position","title":"function position","text":"<pre><code>inline const  QVector3D &amp; Camera::position () const\n</code></pre>"},{"location":"blaze/classCamera/#function-proj_matrix","title":"function proj_matrix","text":"<pre><code>inline QMatrix4x4 Camera::proj_matrix () const\n</code></pre>"},{"location":"blaze/classCamera/#function-projection_scale","title":"function projection_scale","text":"<pre><code>inline double Camera::projection_scale () const\n</code></pre>"},{"location":"blaze/classCamera/#function-reset_to_origin","title":"function reset_to_origin","text":"<pre><code>inline void Camera::reset_to_origin () \n</code></pre>"},{"location":"blaze/classCamera/#function-rotate_around_center","title":"function rotate_around_center","text":"<pre><code>inline void Camera::rotate_around_center (\n    double dx,\n    double dy,\n    const std::optional&lt; QVector3D &gt; &amp; center=std::nullopt\n) \n</code></pre>"},{"location":"blaze/classCamera/#function-rotate_view","title":"function rotate_view","text":"<pre><code>inline void Camera::rotate_view (\n    double dx,\n    double dy\n) \n</code></pre>"},{"location":"blaze/classCamera/#function-set_screen_size","title":"function set_screen_size","text":"<pre><code>inline void Camera::set_screen_size (\n    int width,\n    int height\n) \n</code></pre>"},{"location":"blaze/classCamera/#function-unproject","title":"function unproject","text":"<pre><code>inline QVector3D Camera::unproject (\n    const  QPointF &amp; screen_pos\n) const\n</code></pre>"},{"location":"blaze/classCamera/#function-up","title":"function up","text":"<pre><code>inline const  QVector3D &amp; Camera::up () const\n</code></pre>"},{"location":"blaze/classCamera/#function-view_right","title":"function view_right","text":"<pre><code>inline QVector3D Camera::view_right () const\n</code></pre>"},{"location":"blaze/classCamera/#function-view_up","title":"function view_up","text":"<pre><code>inline QVector3D Camera::view_up () const\n</code></pre>"},{"location":"blaze/classCamera/#function-world_offset-12","title":"function world_offset [1/2]","text":"<pre><code>inline const  Coordinate3D &lt; double &gt; &amp; Camera::world_offset () const\n</code></pre>"},{"location":"blaze/classCamera/#function-world_offset-22","title":"function world_offset [2/2]","text":"<pre><code>inline Coordinate3D &lt; double &gt; &amp; Camera::world_offset () \n</code></pre>"},{"location":"blaze/classCamera/#function-zoom_to_fit","title":"function zoom_to_fit","text":"<pre><code>inline void Camera::zoom_to_fit (\n    const  Extent3D &amp; extent\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/camera.hpp</code></p>"},{"location":"blaze/structCanopyConfig/","title":"Struct CanopyConfig","text":"<p>ClassList &gt; CanopyConfig</p>"},{"location":"blaze/structCanopyConfig/#public-attributes","title":"Public Attributes","text":"Type Name double blocking_threshold double max_height double min_height"},{"location":"blaze/structCanopyConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structCanopyConfig/#variable-blocking_threshold","title":"variable blocking_threshold","text":"<pre><code>double CanopyConfig::blocking_threshold;\n</code></pre>"},{"location":"blaze/structCanopyConfig/#variable-max_height","title":"variable max_height","text":"<pre><code>double CanopyConfig::max_height;\n</code></pre>"},{"location":"blaze/structCanopyConfig/#variable-min_height","title":"variable min_height","text":"<pre><code>double CanopyConfig::min_height;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/classColor/","title":"Class Color","text":"<p>ClassList &gt; Color</p> <p>Inherited by the following classes: CMYKColor,  RGBColor</p>"},{"location":"blaze/classColor/#public-functions","title":"Public Functions","text":"Type Name Color (const Color &amp;) = default Color () = default Color &amp; operator= (const Color &amp;) = default virtual CMYKColor toCMYK () const = 0 virtual RGBColor toRGB () const = 0 virtual ~Color () = default"},{"location":"blaze/classColor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classColor/#function-color-12","title":"function Color [1/2]","text":"<pre><code>Color::Color (\n    const  Color &amp;\n) = default\n</code></pre>"},{"location":"blaze/classColor/#function-color-22","title":"function Color [2/2]","text":"<pre><code>Color::Color () = default\n</code></pre>"},{"location":"blaze/classColor/#function-operator","title":"function operator=","text":"<pre><code>Color &amp; Color::operator= (\n    const  Color &amp;\n) = default\n</code></pre>"},{"location":"blaze/classColor/#function-tocmyk","title":"function toCMYK","text":"<pre><code>virtual CMYKColor Color::toCMYK () const = 0\n</code></pre>"},{"location":"blaze/classColor/#function-torgb","title":"function toRGB","text":"<pre><code>virtual RGBColor Color::toRGB () const = 0\n</code></pre>"},{"location":"blaze/classColor/#function-color","title":"function ~Color","text":"<pre><code>virtual Color::~Color () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/isom/colors.hpp</code></p>"},{"location":"blaze/structConfig/","title":"Struct Config","text":"<p>ClassList &gt; Config</p>"},{"location":"blaze/structConfig/#public-attributes","title":"Public Attributes","text":"Type Name double border_width BuildingsConfig buildings ContourConfigs contours GridConfig grid GroundConfig ground std::vector&lt; fs::path &gt; las_files fs::path output_directory std::set&lt; ProcessingStep &gt; processing_steps fs::path relative_path_to_config RenderConfig render VegeConfig vege WaterConfigs water"},{"location":"blaze/structConfig/#public-functions","title":"Public Functions","text":"Type Name Config (const Config &amp; config) = delete Config (Config &amp;&amp; config) = default Config () = default std::vector&lt; fs::path &gt; get_las_files (const fs::path &amp; las_path) const std::vector&lt; fs::path &gt; las_filepaths () const Config &amp; operator= (const Config &amp; config) = default fs::path output_path () const void set_output_directory (const fs::path &amp; output_dir)  void write_to_file (const fs::path &amp; filename) const"},{"location":"blaze/structConfig/#public-static-functions","title":"Public Static Functions","text":"Type Name Config Default ()  Config FromFile (const fs::path &amp; filename)"},{"location":"blaze/structConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structConfig/#variable-border_width","title":"variable border_width","text":"<pre><code>double Config::border_width;\n</code></pre>"},{"location":"blaze/structConfig/#variable-buildings","title":"variable buildings","text":"<pre><code>BuildingsConfig Config::buildings;\n</code></pre>"},{"location":"blaze/structConfig/#variable-contours","title":"variable contours","text":"<pre><code>ContourConfigs Config::contours;\n</code></pre>"},{"location":"blaze/structConfig/#variable-grid","title":"variable grid","text":"<pre><code>GridConfig Config::grid;\n</code></pre>"},{"location":"blaze/structConfig/#variable-ground","title":"variable ground","text":"<pre><code>GroundConfig Config::ground;\n</code></pre>"},{"location":"blaze/structConfig/#variable-las_files","title":"variable las_files","text":"<pre><code>std::vector&lt;fs::path&gt; Config::las_files;\n</code></pre>"},{"location":"blaze/structConfig/#variable-output_directory","title":"variable output_directory","text":"<pre><code>fs::path Config::output_directory;\n</code></pre>"},{"location":"blaze/structConfig/#variable-processing_steps","title":"variable processing_steps","text":"<pre><code>std::set&lt;ProcessingStep&gt; Config::processing_steps;\n</code></pre>"},{"location":"blaze/structConfig/#variable-relative_path_to_config","title":"variable relative_path_to_config","text":"<pre><code>fs::path Config::relative_path_to_config;\n</code></pre>"},{"location":"blaze/structConfig/#variable-render","title":"variable render","text":"<pre><code>RenderConfig Config::render;\n</code></pre>"},{"location":"blaze/structConfig/#variable-vege","title":"variable vege","text":"<pre><code>VegeConfig Config::vege;\n</code></pre>"},{"location":"blaze/structConfig/#variable-water","title":"variable water","text":"<pre><code>WaterConfigs Config::water;\n</code></pre>"},{"location":"blaze/structConfig/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/structConfig/#function-config-13","title":"function Config [1/3]","text":"<pre><code>Config::Config (\n    const  Config &amp; config\n) = delete\n</code></pre>"},{"location":"blaze/structConfig/#function-config-23","title":"function Config [2/3]","text":"<pre><code>Config::Config (\n    Config &amp;&amp; config\n) = default\n</code></pre>"},{"location":"blaze/structConfig/#function-config-33","title":"function Config [3/3]","text":"<pre><code>Config::Config () = default\n</code></pre>"},{"location":"blaze/structConfig/#function-get_las_files","title":"function get_las_files","text":"<pre><code>inline std::vector&lt; fs::path &gt; Config::get_las_files (\n    const fs::path &amp; las_path\n) const\n</code></pre>"},{"location":"blaze/structConfig/#function-las_filepaths","title":"function las_filepaths","text":"<pre><code>inline std::vector&lt; fs::path &gt; Config::las_filepaths () const\n</code></pre>"},{"location":"blaze/structConfig/#function-operator","title":"function operator=","text":"<pre><code>Config &amp; Config::operator= (\n    const  Config &amp; config\n) = default\n</code></pre>"},{"location":"blaze/structConfig/#function-output_path","title":"function output_path","text":"<pre><code>inline fs::path Config::output_path () const\n</code></pre>"},{"location":"blaze/structConfig/#function-set_output_directory","title":"function set_output_directory","text":"<pre><code>inline void Config::set_output_directory (\n    const fs::path &amp; output_dir\n) \n</code></pre>"},{"location":"blaze/structConfig/#function-write_to_file","title":"function write_to_file","text":"<pre><code>void Config::write_to_file (\n    const fs::path &amp; filename\n) const\n</code></pre>"},{"location":"blaze/structConfig/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structConfig/#function-default","title":"function Default","text":"<pre><code>static inline Config Config::Default () \n</code></pre>"},{"location":"blaze/structConfig/#function-fromfile","title":"function FromFile","text":"<pre><code>static Config Config::FromFile (\n    const fs::path &amp; filename\n) \n</code></pre>"},{"location":"blaze/structConfig/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/structConfig/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>std::ostream &amp; Config::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  Config &amp; config\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/classConfigEditor/","title":"Class ConfigEditor","text":"<p>ClassList &gt; ConfigEditor</p> <p>Inherits the following classes: QWidget</p>"},{"location":"blaze/classConfigEditor/#public-slots","title":"Public Slots","text":"Type Name slot void add_color slot void add_contour slot void add_las_file slot void add_las_folder slot void add_vege slot void add_vege_color slot void add_water slot void on_color_selected slot void on_color_type_changed (int index)  slot void on_contour_selected slot void on_vege_selected slot void on_water_selected slot void open_config_file slot void pick_color slot void remove_color slot void remove_contour slot void remove_las_file slot void remove_vege slot void remove_vege_color slot void remove_water slot void save_config_file slot void update_color_from_ui slot void update_contour_from_ui slot void update_general_from_ui slot void update_vege_color_from_ui (int row, int column)  slot void update_vege_from_ui slot void update_water_from_ui"},{"location":"blaze/classConfigEditor/#public-signals","title":"Public Signals","text":"Type Name signal void config_changed"},{"location":"blaze/classConfigEditor/#public-functions","title":"Public Functions","text":"Type Name ConfigEditor (QWidget * parent=nullptr)  const Config &amp; get_config ()  bool is_valid () const ~ConfigEditor ()"},{"location":"blaze/classConfigEditor/#public-slots-documentation","title":"Public Slots Documentation","text":""},{"location":"blaze/classConfigEditor/#slot-add_color","title":"slot add_color","text":"<pre><code>void ConfigEditor::add_color;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-add_contour","title":"slot add_contour","text":"<pre><code>void ConfigEditor::add_contour;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-add_las_file","title":"slot add_las_file","text":"<pre><code>void ConfigEditor::add_las_file;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-add_las_folder","title":"slot add_las_folder","text":"<pre><code>void ConfigEditor::add_las_folder;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-add_vege","title":"slot add_vege","text":"<pre><code>void ConfigEditor::add_vege;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-add_vege_color","title":"slot add_vege_color","text":"<pre><code>void ConfigEditor::add_vege_color;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-add_water","title":"slot add_water","text":"<pre><code>void ConfigEditor::add_water;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-on_color_selected","title":"slot on_color_selected","text":"<pre><code>void ConfigEditor::on_color_selected;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-on_color_type_changed","title":"slot on_color_type_changed","text":"<pre><code>void ConfigEditor::on_color_type_changed;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-on_contour_selected","title":"slot on_contour_selected","text":"<pre><code>void ConfigEditor::on_contour_selected;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-on_vege_selected","title":"slot on_vege_selected","text":"<pre><code>void ConfigEditor::on_vege_selected;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-on_water_selected","title":"slot on_water_selected","text":"<pre><code>void ConfigEditor::on_water_selected;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-open_config_file","title":"slot open_config_file","text":"<pre><code>void ConfigEditor::open_config_file;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-pick_color","title":"slot pick_color","text":"<pre><code>void ConfigEditor::pick_color;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-remove_color","title":"slot remove_color","text":"<pre><code>void ConfigEditor::remove_color;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-remove_contour","title":"slot remove_contour","text":"<pre><code>void ConfigEditor::remove_contour;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-remove_las_file","title":"slot remove_las_file","text":"<pre><code>void ConfigEditor::remove_las_file;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-remove_vege","title":"slot remove_vege","text":"<pre><code>void ConfigEditor::remove_vege;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-remove_vege_color","title":"slot remove_vege_color","text":"<pre><code>void ConfigEditor::remove_vege_color;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-remove_water","title":"slot remove_water","text":"<pre><code>void ConfigEditor::remove_water;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-save_config_file","title":"slot save_config_file","text":"<pre><code>void ConfigEditor::save_config_file;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-update_color_from_ui","title":"slot update_color_from_ui","text":"<pre><code>void ConfigEditor::update_color_from_ui;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-update_contour_from_ui","title":"slot update_contour_from_ui","text":"<pre><code>void ConfigEditor::update_contour_from_ui;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-update_general_from_ui","title":"slot update_general_from_ui","text":"<pre><code>void ConfigEditor::update_general_from_ui;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-update_vege_color_from_ui","title":"slot update_vege_color_from_ui","text":"<pre><code>void ConfigEditor::update_vege_color_from_ui;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-update_vege_from_ui","title":"slot update_vege_from_ui","text":"<pre><code>void ConfigEditor::update_vege_from_ui;\n</code></pre>"},{"location":"blaze/classConfigEditor/#slot-update_water_from_ui","title":"slot update_water_from_ui","text":"<pre><code>void ConfigEditor::update_water_from_ui;\n</code></pre>"},{"location":"blaze/classConfigEditor/#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"blaze/classConfigEditor/#signal-config_changed","title":"signal config_changed","text":"<pre><code>void ConfigEditor::config_changed;\n</code></pre>"},{"location":"blaze/classConfigEditor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classConfigEditor/#function-configeditor","title":"function ConfigEditor","text":"<pre><code>explicit ConfigEditor::ConfigEditor (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"blaze/classConfigEditor/#function-get_config","title":"function get_config","text":"<pre><code>inline const  Config &amp; ConfigEditor::get_config () \n</code></pre>"},{"location":"blaze/classConfigEditor/#function-is_valid","title":"function is_valid","text":"<pre><code>bool ConfigEditor::is_valid () const\n</code></pre>"},{"location":"blaze/classConfigEditor/#function-configeditor_1","title":"function ~ConfigEditor","text":"<pre><code>ConfigEditor::~ConfigEditor () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/config_editor.hpp</code></p>"},{"location":"blaze/classContour/","title":"Class Contour","text":"<p>ClassList &gt; Contour</p>"},{"location":"blaze/classContour/#public-functions","title":"Public Functions","text":"Type Name Contour (double height, std::vector&lt; Coordinate2D&lt; double &gt; &gt; &amp;&amp; points)  double height () const bool is_loop () const const std::vector&lt; Coordinate2D&lt; double &gt; &gt; &amp; points () const std::vector&lt; Coordinate2D&lt; double &gt; &gt; &amp; points ()  void push_back (const Coordinate2D&lt; double &gt; &amp; point)  Polyline to_polyline (const ContourConfigs &amp; configs) const"},{"location":"blaze/classContour/#public-static-functions","title":"Public Static Functions","text":"Type Name Contour FromGridGraph (const LineCoord2D&lt; size_t &gt; &amp; starting_point, double height, const GeoGrid&lt; double &gt; &amp; grid, GridGraph&lt; std::set&lt; double &gt; &gt; &amp; contour_heights)  Contour from_polyline (const Polyline &amp; polyline)"},{"location":"blaze/classContour/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classContour/#function-contour","title":"function Contour","text":"<pre><code>inline Contour::Contour (\n    double height,\n    std::vector&lt; Coordinate2D &lt; double &gt; &gt; &amp;&amp; points\n) \n</code></pre>"},{"location":"blaze/classContour/#function-height","title":"function height","text":"<pre><code>inline double Contour::height () const\n</code></pre>"},{"location":"blaze/classContour/#function-is_loop","title":"function is_loop","text":"<pre><code>inline bool Contour::is_loop () const\n</code></pre>"},{"location":"blaze/classContour/#function-points-12","title":"function points [1/2]","text":"<pre><code>inline const std::vector&lt; Coordinate2D &lt; double &gt; &gt; &amp; Contour::points () const\n</code></pre>"},{"location":"blaze/classContour/#function-points-22","title":"function points [2/2]","text":"<pre><code>inline std::vector&lt; Coordinate2D &lt; double &gt; &gt; &amp; Contour::points () \n</code></pre>"},{"location":"blaze/classContour/#function-push_back","title":"function push_back","text":"<pre><code>inline void Contour::push_back (\n    const  Coordinate2D &lt; double &gt; &amp; point\n) \n</code></pre>"},{"location":"blaze/classContour/#function-to_polyline","title":"function to_polyline","text":"<pre><code>Polyline Contour::to_polyline (\n    const  ContourConfigs &amp; configs\n) const\n</code></pre>"},{"location":"blaze/classContour/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/classContour/#function-fromgridgraph","title":"function FromGridGraph","text":"<pre><code>static inline Contour Contour::FromGridGraph (\n    const  LineCoord2D &lt; size_t &gt; &amp; starting_point,\n    double height,\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    GridGraph &lt; std::set&lt; double &gt; &gt; &amp; contour_heights\n) \n</code></pre>"},{"location":"blaze/classContour/#function-from_polyline","title":"function from_polyline","text":"<pre><code>static Contour Contour::from_polyline (\n    const  Polyline &amp; polyline\n) \n</code></pre>"},{"location":"blaze/classContour/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classContour/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; Contour::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  Contour &amp; contour\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/contour/contour.hpp</code></p>"},{"location":"blaze/structContourConfig/","title":"Struct ContourConfig","text":"<p>ClassList &gt; ContourConfig</p>"},{"location":"blaze/structContourConfig/#public-attributes","title":"Public Attributes","text":"Type Name ColorVariant color double interval unsigned int min_points double width"},{"location":"blaze/structContourConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structContourConfig/#variable-color","title":"variable color","text":"<pre><code>ColorVariant ContourConfig::color;\n</code></pre>"},{"location":"blaze/structContourConfig/#variable-interval","title":"variable interval","text":"<pre><code>double ContourConfig::interval;\n</code></pre>"},{"location":"blaze/structContourConfig/#variable-min_points","title":"variable min_points","text":"<pre><code>unsigned int ContourConfig::min_points;\n</code></pre>"},{"location":"blaze/structContourConfig/#variable-width","title":"variable width","text":"<pre><code>double ContourConfig::width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/structContourConfigs/","title":"Struct ContourConfigs","text":"<p>ClassList &gt; ContourConfigs</p>"},{"location":"blaze/structContourConfigs/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; std::string, ContourConfig &gt; configs double min_interval"},{"location":"blaze/structContourConfigs/#public-functions","title":"Public Functions","text":"Type Name ContourConfigs ()  ContourConfigs (std::map&lt; std::string, ContourConfig &gt; in_configs)  std::string layer_name_from_height (double height) const const ContourConfig &amp; operator[] (const std::string &amp; key) const const ContourConfig &amp; pick_from_height (double height) const"},{"location":"blaze/structContourConfigs/#public-static-functions","title":"Public Static Functions","text":"Type Name double minimum_interval (const std::map&lt; std::string, ContourConfig &gt; &amp; configs)"},{"location":"blaze/structContourConfigs/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structContourConfigs/#variable-configs","title":"variable configs","text":"<pre><code>std::map&lt;std::string, ContourConfig&gt; ContourConfigs::configs;\n</code></pre>"},{"location":"blaze/structContourConfigs/#variable-min_interval","title":"variable min_interval","text":"<pre><code>double ContourConfigs::min_interval;\n</code></pre>"},{"location":"blaze/structContourConfigs/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/structContourConfigs/#function-contourconfigs-12","title":"function ContourConfigs [1/2]","text":"<pre><code>inline ContourConfigs::ContourConfigs () \n</code></pre>"},{"location":"blaze/structContourConfigs/#function-contourconfigs-22","title":"function ContourConfigs [2/2]","text":"<pre><code>inline explicit ContourConfigs::ContourConfigs (\n    std::map&lt; std::string, ContourConfig &gt; in_configs\n) \n</code></pre>"},{"location":"blaze/structContourConfigs/#function-layer_name_from_height","title":"function layer_name_from_height","text":"<pre><code>inline std::string ContourConfigs::layer_name_from_height (\n    double height\n) const\n</code></pre>"},{"location":"blaze/structContourConfigs/#function-operator","title":"function operator[]","text":"<pre><code>inline const  ContourConfig &amp; ContourConfigs::operator[] (\n    const std::string &amp; key\n) const\n</code></pre>"},{"location":"blaze/structContourConfigs/#function-pick_from_height","title":"function pick_from_height","text":"<pre><code>inline const  ContourConfig &amp; ContourConfigs::pick_from_height (\n    double height\n) const\n</code></pre>"},{"location":"blaze/structContourConfigs/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structContourConfigs/#function-minimum_interval","title":"function minimum_interval","text":"<pre><code>static inline double ContourConfigs::minimum_interval (\n    const std::map&lt; std::string, ContourConfig &gt; &amp; configs\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/classContourPoint/","title":"Class ContourPoint","text":"<p>ClassList &gt; ContourPoint</p> <p>Inherits the following classes: Coordinate2D</p>"},{"location":"blaze/classContourPoint/#public-functions","title":"Public Functions","text":"Type Name ContourPoint (double x, double y, double height)  void find_up_down (const GeoGrid&lt; std::vector&lt; std::shared_ptr&lt; ContourPoint &gt; &gt; &gt; &amp; point_grid)  double height () const void set_next (std::shared_ptr&lt; ContourPoint &gt; next)  void set_previous (std::shared_ptr&lt; ContourPoint &gt; prev)  double slope () const"},{"location":"blaze/classContourPoint/#public-functions-inherited-from-coordinate2d","title":"Public Functions inherited from Coordinate2D","text":"<p>See Coordinate2D</p> Type Name Coordinate2D (T x, T y)  Coordinate2D () = default T magnitude () const T magnitude_sqd () const Coordinate2D&lt; double &gt; offset_to_center () const operator Coordinate2D&lt; U &gt; () const Coordinate2D operator+ (Direction2D dir) const Coordinate2D operator+ (Coordinate2D o) const Coordinate2D operator- (Coordinate2D o) const bool operator== (const Coordinate2D &amp; o) const Coordinate2D&lt; size_t &gt; round () const Coordinate2D&lt; double &gt; round_NW (double grid_size) const const T &amp; x () const T &amp; x ()  const T &amp; y () const T &amp; y ()"},{"location":"blaze/classContourPoint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classContourPoint/#function-contourpoint","title":"function ContourPoint","text":"<pre><code>inline ContourPoint::ContourPoint (\n    double x,\n    double y,\n    double height\n) \n</code></pre>"},{"location":"blaze/classContourPoint/#function-find_up_down","title":"function find_up_down","text":"<pre><code>inline void ContourPoint::find_up_down (\n    const  GeoGrid &lt; std::vector&lt; std::shared_ptr&lt; ContourPoint &gt; &gt; &gt; &amp; point_grid\n) \n</code></pre>"},{"location":"blaze/classContourPoint/#function-height","title":"function height","text":"<pre><code>inline double ContourPoint::height () const\n</code></pre>"},{"location":"blaze/classContourPoint/#function-set_next","title":"function set_next","text":"<pre><code>inline void ContourPoint::set_next (\n    std::shared_ptr&lt; ContourPoint &gt; next\n) \n</code></pre>"},{"location":"blaze/classContourPoint/#function-set_previous","title":"function set_previous","text":"<pre><code>inline void ContourPoint::set_previous (\n    std::shared_ptr&lt; ContourPoint &gt; prev\n) \n</code></pre>"},{"location":"blaze/classContourPoint/#function-slope","title":"function slope","text":"<pre><code>inline double ContourPoint::slope () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/cliff/cliff.hpp</code></p>"},{"location":"blaze/classCoordinate2D/","title":"Class Coordinate2D","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; Coordinate2D</p> <p>Inherited by the following classes: Coordinate3D,  Coordinate3D,  LineCoord2D</p>"},{"location":"blaze/classCoordinate2D/#public-functions","title":"Public Functions","text":"Type Name Coordinate2D (T x, T y)  Coordinate2D () = default T magnitude () const T magnitude_sqd () const Coordinate2D&lt; double &gt; offset_to_center () const operator Coordinate2D&lt; U &gt; () const Coordinate2D operator+ (Direction2D dir) const Coordinate2D operator+ (Coordinate2D o) const Coordinate2D operator- (Coordinate2D o) const bool operator== (const Coordinate2D &amp; o) const Coordinate2D&lt; size_t &gt; round () const Coordinate2D&lt; double &gt; round_NW (double grid_size) const const T &amp; x () const T &amp; x ()  const T &amp; y () const T &amp; y ()"},{"location":"blaze/classCoordinate2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classCoordinate2D/#function-coordinate2d-12","title":"function Coordinate2D [1/2]","text":"<pre><code>inline Coordinate2D::Coordinate2D (\n    T x,\n    T y\n) \n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-coordinate2d-22","title":"function Coordinate2D [2/2]","text":"<pre><code>Coordinate2D::Coordinate2D () = default\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-magnitude","title":"function magnitude","text":"<pre><code>inline T Coordinate2D::magnitude () const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-magnitude_sqd","title":"function magnitude_sqd","text":"<pre><code>inline T Coordinate2D::magnitude_sqd () const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-offset_to_center","title":"function offset_to_center","text":"<pre><code>inline Coordinate2D &lt; double &gt; Coordinate2D::offset_to_center () const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-operator-coordinate2d-u","title":"function operator Coordinate2D&lt; U &gt;","text":"<pre><code>template&lt;typename  U&gt;\ninline Coordinate2D::operator Coordinate2D&lt; U &gt; () const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-operator","title":"function operator+","text":"<pre><code>inline Coordinate2D Coordinate2D::operator+ (\n    Direction2D dir\n) const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-operator_1","title":"function operator+","text":"<pre><code>inline Coordinate2D Coordinate2D::operator+ (\n    Coordinate2D o\n) const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-operator-","title":"function operator-","text":"<pre><code>inline Coordinate2D Coordinate2D::operator- (\n    Coordinate2D o\n) const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-operator_2","title":"function operator==","text":"<pre><code>inline bool Coordinate2D::operator== (\n    const  Coordinate2D &amp; o\n) const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-round","title":"function round","text":"<pre><code>inline Coordinate2D &lt; size_t &gt; Coordinate2D::round () const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-round_nw","title":"function round_NW","text":"<pre><code>inline Coordinate2D &lt; double &gt; Coordinate2D::round_NW (\n    double grid_size\n) const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-x-12","title":"function x [1/2]","text":"<pre><code>inline const T &amp; Coordinate2D::x () const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-x-22","title":"function x [2/2]","text":"<pre><code>inline T &amp; Coordinate2D::x () \n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-y-12","title":"function y [1/2]","text":"<pre><code>inline const T &amp; Coordinate2D::y () const\n</code></pre>"},{"location":"blaze/classCoordinate2D/#function-y-22","title":"function y [2/2]","text":"<pre><code>inline T &amp; Coordinate2D::y () \n</code></pre>"},{"location":"blaze/classCoordinate2D/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classCoordinate2D/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; Coordinate2D::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  Coordinate2D &amp; coord\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/coordinate.hpp</code></p>"},{"location":"blaze/classCoordinate3D/","title":"Class Coordinate3D","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; Coordinate3D</p> <p>Inherits the following classes: Coordinate2D</p>"},{"location":"blaze/classCoordinate3D/#public-functions","title":"Public Functions","text":"Type Name Coordinate3D (T x, T y, T z)  Coordinate3D () = default const T z () const T &amp; z ()"},{"location":"blaze/classCoordinate3D/#public-functions-inherited-from-coordinate2d","title":"Public Functions inherited from Coordinate2D","text":"<p>See Coordinate2D</p> Type Name Coordinate2D (T x, T y)  Coordinate2D () = default T magnitude () const T magnitude_sqd () const Coordinate2D&lt; double &gt; offset_to_center () const operator Coordinate2D&lt; U &gt; () const Coordinate2D operator+ (Direction2D dir) const Coordinate2D operator+ (Coordinate2D o) const Coordinate2D operator- (Coordinate2D o) const bool operator== (const Coordinate2D &amp; o) const Coordinate2D&lt; size_t &gt; round () const Coordinate2D&lt; double &gt; round_NW (double grid_size) const const T &amp; x () const T &amp; x ()  const T &amp; y () const T &amp; y ()"},{"location":"blaze/classCoordinate3D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classCoordinate3D/#function-coordinate3d-12","title":"function Coordinate3D [1/2]","text":"<pre><code>inline Coordinate3D::Coordinate3D (\n    T x,\n    T y,\n    T z\n) \n</code></pre>"},{"location":"blaze/classCoordinate3D/#function-coordinate3d-22","title":"function Coordinate3D [2/2]","text":"<pre><code>Coordinate3D::Coordinate3D () = default\n</code></pre>"},{"location":"blaze/classCoordinate3D/#function-z-12","title":"function z [1/2]","text":"<pre><code>inline const T Coordinate3D::z () const\n</code></pre>"},{"location":"blaze/classCoordinate3D/#function-z-22","title":"function z [2/2]","text":"<pre><code>inline T &amp; Coordinate3D::z () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/coordinate.hpp</code></p>"},{"location":"blaze/classDirection2D/","title":"Class Direction2D","text":"<p>ClassList &gt; Direction2D</p>"},{"location":"blaze/classDirection2D/#public-types","title":"Public Types","text":"Type Name enum Dir"},{"location":"blaze/classDirection2D/#public-functions","title":"Public Functions","text":"Type Name Direction2D (Dir dir)  int dx () const int dy () const operator Dir () const Direction2D opposite () const std::array&lt; Direction2D, 2 &gt; orthogonal_dirs () const bool orthogonal_to (Direction2D other) const"},{"location":"blaze/classDirection2D/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/classDirection2D/#enum-dir","title":"enum Dir","text":"<pre><code>enum Direction2D::Dir {\n    UP,\n    DOWN,\n    LEFT,\n    RIGHT,\n    UR,\n    UL,\n    DR,\n    DL\n};\n</code></pre>"},{"location":"blaze/classDirection2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classDirection2D/#function-direction2d","title":"function Direction2D","text":"<pre><code>inline Direction2D::Direction2D (\n    Dir dir\n) \n</code></pre>"},{"location":"blaze/classDirection2D/#function-dx","title":"function dx","text":"<pre><code>inline int Direction2D::dx () const\n</code></pre>"},{"location":"blaze/classDirection2D/#function-dy","title":"function dy","text":"<pre><code>inline int Direction2D::dy () const\n</code></pre>"},{"location":"blaze/classDirection2D/#function-operator-dir","title":"function operator Dir","text":"<pre><code>inline Direction2D::operator Dir () const\n</code></pre>"},{"location":"blaze/classDirection2D/#function-opposite","title":"function opposite","text":"<pre><code>inline Direction2D Direction2D::opposite () const\n</code></pre>"},{"location":"blaze/classDirection2D/#function-orthogonal_dirs","title":"function orthogonal_dirs","text":"<pre><code>inline std::array&lt; Direction2D , 2 &gt; Direction2D::orthogonal_dirs () const\n</code></pre>"},{"location":"blaze/classDirection2D/#function-orthogonal_to","title":"function orthogonal_to","text":"<pre><code>inline bool Direction2D::orthogonal_to (\n    Direction2D other\n) const\n</code></pre>"},{"location":"blaze/classDirection2D/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classDirection2D/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; Direction2D::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  Direction2D &amp; dir\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/coordinate.hpp</code></p>"},{"location":"blaze/structExtent2D/","title":"Struct Extent2D","text":"<p>ClassList &gt; Extent2D</p> <p>Inherited by the following classes: Extent3D</p>"},{"location":"blaze/structExtent2D/#public-attributes","title":"Public Attributes","text":"Type Name double maxx   = <code>-std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code> double maxy   = <code>-std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code> double minx   = <code>std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code> double miny   = <code>std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code>"},{"location":"blaze/structExtent2D/#public-functions","title":"Public Functions","text":"Type Name bool contains (double x, double y) const void grow (const Extent2D &amp; other)"},{"location":"blaze/structExtent2D/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structExtent2D/#variable-maxx","title":"variable maxx","text":"<pre><code>double Extent2D::maxx;\n</code></pre>"},{"location":"blaze/structExtent2D/#variable-maxy","title":"variable maxy","text":"<pre><code>double Extent2D::maxy;\n</code></pre>"},{"location":"blaze/structExtent2D/#variable-minx","title":"variable minx","text":"<pre><code>double Extent2D::minx;\n</code></pre>"},{"location":"blaze/structExtent2D/#variable-miny","title":"variable miny","text":"<pre><code>double Extent2D::miny;\n</code></pre>"},{"location":"blaze/structExtent2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/structExtent2D/#function-contains","title":"function contains","text":"<pre><code>inline bool Extent2D::contains (\n    double x,\n    double y\n) const\n</code></pre>"},{"location":"blaze/structExtent2D/#function-grow","title":"function grow","text":"<pre><code>inline void Extent2D::grow (\n    const  Extent2D &amp; other\n) \n</code></pre>"},{"location":"blaze/structExtent2D/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/structExtent2D/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; Extent2D::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  Extent2D &amp; extent\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/coordinate.hpp</code></p>"},{"location":"blaze/structExtent3D/","title":"Struct Extent3D","text":"<p>ClassList &gt; Extent3D</p> <p>Inherits the following classes: Extent2D</p>"},{"location":"blaze/structExtent3D/#public-attributes","title":"Public Attributes","text":"Type Name double maxz   = <code>-std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code> double minz   = <code>std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code>"},{"location":"blaze/structExtent3D/#public-attributes-inherited-from-extent2d","title":"Public Attributes inherited from Extent2D","text":"<p>See Extent2D</p> Type Name double maxx   = <code>-std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code> double maxy   = <code>-std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code> double minx   = <code>std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code> double miny   = <code>std::numeric\\_limits&amp;lt;[**double**](classCoordinate2D.md)&amp;gt;[**::infinity**](classCoordinate2D.md)()</code>"},{"location":"blaze/structExtent3D/#public-functions","title":"Public Functions","text":"Type Name Extent3D () = default Extent3D (const Extent2D &amp; extent, double minz, double maxz)  Extent3D (double minx, double maxx, double miny, double maxy, double minz, double maxz)  Coordinate3D&lt; double &gt; center () const void grow (double x, double y, double z)  void grow (double border)  void grow (const Extent3D &amp; other)  Extent3D intersection (const Extent3D &amp; other) const bool intersects (const Extent3D &amp; other) const double max_extent () const bool operator!= (const Extent3D &amp; other) const Extent3D operator- (const Coordinate3D&lt; double &gt; &amp; offset) const"},{"location":"blaze/structExtent3D/#public-functions-inherited-from-extent2d","title":"Public Functions inherited from Extent2D","text":"<p>See Extent2D</p> Type Name bool contains (double x, double y) const void grow (const Extent2D &amp; other)"},{"location":"blaze/structExtent3D/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structExtent3D/#variable-maxz","title":"variable maxz","text":"<pre><code>double Extent3D::maxz;\n</code></pre>"},{"location":"blaze/structExtent3D/#variable-minz","title":"variable minz","text":"<pre><code>double Extent3D::minz;\n</code></pre>"},{"location":"blaze/structExtent3D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/structExtent3D/#function-extent3d-13","title":"function Extent3D [1/3]","text":"<pre><code>Extent3D::Extent3D () = default\n</code></pre>"},{"location":"blaze/structExtent3D/#function-extent3d-23","title":"function Extent3D [2/3]","text":"<pre><code>inline Extent3D::Extent3D (\n    const  Extent2D &amp; extent,\n    double minz,\n    double maxz\n) \n</code></pre>"},{"location":"blaze/structExtent3D/#function-extent3d-33","title":"function Extent3D [3/3]","text":"<pre><code>inline Extent3D::Extent3D (\n    double minx,\n    double maxx,\n    double miny,\n    double maxy,\n    double minz,\n    double maxz\n) \n</code></pre>"},{"location":"blaze/structExtent3D/#function-center","title":"function center","text":"<pre><code>inline Coordinate3D &lt; double &gt; Extent3D::center () const\n</code></pre>"},{"location":"blaze/structExtent3D/#function-grow-13","title":"function grow [1/3]","text":"<pre><code>inline void Extent3D::grow (\n    double x,\n    double y,\n    double z\n) \n</code></pre>"},{"location":"blaze/structExtent3D/#function-grow-23","title":"function grow [2/3]","text":"<pre><code>inline void Extent3D::grow (\n    double border\n) \n</code></pre>"},{"location":"blaze/structExtent3D/#function-grow-33","title":"function grow [3/3]","text":"<pre><code>inline void Extent3D::grow (\n    const  Extent3D &amp; other\n) \n</code></pre>"},{"location":"blaze/structExtent3D/#function-intersection","title":"function intersection","text":"<pre><code>inline Extent3D Extent3D::intersection (\n    const  Extent3D &amp; other\n) const\n</code></pre>"},{"location":"blaze/structExtent3D/#function-intersects","title":"function intersects","text":"<pre><code>inline bool Extent3D::intersects (\n    const  Extent3D &amp; other\n) const\n</code></pre>"},{"location":"blaze/structExtent3D/#function-max_extent","title":"function max_extent","text":"<pre><code>inline double Extent3D::max_extent () const\n</code></pre>"},{"location":"blaze/structExtent3D/#function-operator","title":"function operator!=","text":"<pre><code>inline bool Extent3D::operator!= (\n    const  Extent3D &amp; other\n) const\n</code></pre>"},{"location":"blaze/structExtent3D/#function-operator-","title":"function operator-","text":"<pre><code>inline Extent3D Extent3D::operator- (\n    const  Coordinate3D &lt; double &gt; &amp; offset\n) const\n</code></pre>"},{"location":"blaze/structExtent3D/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/structExtent3D/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; Extent3D::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  Extent3D &amp; extent\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/coordinate.hpp</code></p>"},{"location":"blaze/classFlexGrid/","title":"Class FlexGrid","text":"<p>ClassList &gt; FlexGrid</p> <p>Inherits the following classes: GridData</p>"},{"location":"blaze/classFlexGrid/#public-functions","title":"Public Functions","text":"Type Name FlexGrid (size_t width, size_t height, int n_bytes, int data_type={})  std::byte * data ()  const std::byte * data () const int data_type () const void fill_from (const FlexGrid &amp; other, const Coordinate2D&lt; long long &gt; &amp; top_left={0, 0})  T get (const Coordinate2D&lt; long long &gt; &amp; coord) const unsigned int n_bytes () const std::byte * operator[] (Coordinate2D&lt; size_t &gt; coord)  const std::byte * operator[] (Coordinate2D&lt; size_t &gt; coord) const"},{"location":"blaze/classFlexGrid/#public-functions-inherited-from-griddata","title":"Public Functions inherited from GridData","text":"<p>See GridData</p> Type Name GridData (size_t width, size_t height)  size_t height () const bool in_bounds (const Coordinate2D&lt; size_t &gt; &amp; coord) const size_t width () const"},{"location":"blaze/classFlexGrid/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; std::byte &gt; m_data unsigned int m_data_size int m_data_type"},{"location":"blaze/classFlexGrid/#protected-attributes-inherited-from-griddata","title":"Protected Attributes inherited from GridData","text":"<p>See GridData</p> Type Name size_t m_height size_t m_width"},{"location":"blaze/classFlexGrid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classFlexGrid/#function-flexgrid","title":"function FlexGrid","text":"<pre><code>FlexGrid::FlexGrid (\n    size_t width,\n    size_t height,\n    int n_bytes,\n    int data_type={}\n) \n</code></pre>"},{"location":"blaze/classFlexGrid/#function-data-12","title":"function data [1/2]","text":"<pre><code>inline std::byte * FlexGrid::data () \n</code></pre>"},{"location":"blaze/classFlexGrid/#function-data-22","title":"function data [2/2]","text":"<pre><code>inline const std::byte * FlexGrid::data () const\n</code></pre>"},{"location":"blaze/classFlexGrid/#function-data_type","title":"function data_type","text":"<pre><code>int FlexGrid::data_type () const\n</code></pre>"},{"location":"blaze/classFlexGrid/#function-fill_from","title":"function fill_from","text":"<pre><code>inline void FlexGrid::fill_from (\n    const  FlexGrid &amp; other,\n    const  Coordinate2D &lt; long  long &gt; &amp; top_left={0, 0}\n) \n</code></pre>"},{"location":"blaze/classFlexGrid/#function-get","title":"function get","text":"<pre><code>template&lt;typename T&gt;\ninline T FlexGrid::get (\n    const  Coordinate2D &lt; long  long &gt; &amp; coord\n) const\n</code></pre>"},{"location":"blaze/classFlexGrid/#function-n_bytes","title":"function n_bytes","text":"<pre><code>inline unsigned  int FlexGrid::n_bytes () const\n</code></pre>"},{"location":"blaze/classFlexGrid/#function-operator","title":"function operator[]","text":"<pre><code>inline std::byte * FlexGrid::operator[] (\n    Coordinate2D &lt; size_t &gt; coord\n) \n</code></pre>"},{"location":"blaze/classFlexGrid/#function-operator_1","title":"function operator[]","text":"<pre><code>inline const std::byte * FlexGrid::operator[] (\n    Coordinate2D &lt; size_t &gt; coord\n) const\n</code></pre>"},{"location":"blaze/classFlexGrid/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"blaze/classFlexGrid/#variable-m_data","title":"variable m_data","text":"<pre><code>std::vector&lt;std::byte&gt; FlexGrid::m_data;\n</code></pre>"},{"location":"blaze/classFlexGrid/#variable-m_data_size","title":"variable m_data_size","text":"<pre><code>unsigned int FlexGrid::m_data_size;\n</code></pre>"},{"location":"blaze/classFlexGrid/#variable-m_data_type","title":"variable m_data_type","text":"<pre><code>int FlexGrid::m_data_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/classGDALDataset__w/","title":"Class GDALDataset_w","text":"<p>ClassList &gt; GDALDataset_w</p>"},{"location":"blaze/classGDALDataset__w/#public-functions","title":"Public Functions","text":"Type Name GDALDataset_w (const std::string &amp; filename, const std::string &amp; projection)  GDALDataset * operator-&gt; ()  ~GDALDataset_w ()"},{"location":"blaze/classGDALDataset__w/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGDALDataset__w/#function-gdaldataset_w","title":"function GDALDataset_w","text":"<pre><code>inline GDALDataset_w::GDALDataset_w (\n    const std::string &amp; filename,\n    const std::string &amp; projection\n) \n</code></pre>"},{"location":"blaze/classGDALDataset__w/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline GDALDataset * GDALDataset_w::operator-&gt; () \n</code></pre>"},{"location":"blaze/classGDALDataset__w/#function-gdaldataset_w_1","title":"function ~GDALDataset_w","text":"<pre><code>inline GDALDataset_w::~GDALDataset_w () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/io/gpkg.hpp</code></p>"},{"location":"blaze/classGLWidget/","title":"Class GLWidget","text":"<p>ClassList &gt; GLWidget</p> <p>Inherits the following classes: QOpenGLWidget,  QOpenGLFunctions</p>"},{"location":"blaze/classGLWidget/#public-functions","title":"Public Functions","text":"Type Name GLWidget (QWidget * parent=nullptr)  void add_layer (std::unique_ptr&lt; Layer &gt; layer)  std::vector&lt; std::shared_ptr&lt; Layer &gt; &gt; layers () const ~GLWidget ()"},{"location":"blaze/classGLWidget/#protected-functions","title":"Protected Functions","text":"Type Name void initializeGL () override void keyPressEvent (QKeyEvent * event) override void mouseMoveEvent (QMouseEvent * event) override void mousePressEvent (QMouseEvent * event) override void paintGL () override QSize sizeHint () override const void wheelEvent (QWheelEvent * event) override"},{"location":"blaze/classGLWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGLWidget/#function-glwidget","title":"function GLWidget","text":"<pre><code>GLWidget::GLWidget (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"blaze/classGLWidget/#function-add_layer","title":"function add_layer","text":"<pre><code>inline void GLWidget::add_layer (\n    std::unique_ptr&lt; Layer &gt; layer\n) \n</code></pre>"},{"location":"blaze/classGLWidget/#function-layers","title":"function layers","text":"<pre><code>inline std::vector&lt; std::shared_ptr&lt; Layer &gt; &gt; GLWidget::layers () const\n</code></pre>"},{"location":"blaze/classGLWidget/#function-glwidget_1","title":"function ~GLWidget","text":"<pre><code>GLWidget::~GLWidget () \n</code></pre>"},{"location":"blaze/classGLWidget/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"blaze/classGLWidget/#function-initializegl","title":"function initializeGL","text":"<pre><code>void GLWidget::initializeGL () override\n</code></pre>"},{"location":"blaze/classGLWidget/#function-keypressevent","title":"function keyPressEvent","text":"<pre><code>void GLWidget::keyPressEvent (\n    QKeyEvent * event\n) override\n</code></pre>"},{"location":"blaze/classGLWidget/#function-mousemoveevent","title":"function mouseMoveEvent","text":"<pre><code>void GLWidget::mouseMoveEvent (\n    QMouseEvent * event\n) override\n</code></pre>"},{"location":"blaze/classGLWidget/#function-mousepressevent","title":"function mousePressEvent","text":"<pre><code>void GLWidget::mousePressEvent (\n    QMouseEvent * event\n) override\n</code></pre>"},{"location":"blaze/classGLWidget/#function-paintgl","title":"function paintGL","text":"<pre><code>void GLWidget::paintGL () override\n</code></pre>"},{"location":"blaze/classGLWidget/#function-sizehint","title":"function sizeHint","text":"<pre><code>QSize GLWidget::sizeHint () override const\n</code></pre>"},{"location":"blaze/classGLWidget/#function-wheelevent","title":"function wheelEvent","text":"<pre><code>void GLWidget::wheelEvent (\n    QWheelEvent * event\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/gl_widget.hpp</code></p>"},{"location":"blaze/classGPKGWriter/","title":"Class GPKGWriter","text":"<p>ClassList &gt; GPKGWriter</p>"},{"location":"blaze/classGPKGWriter/#public-functions","title":"Public Functions","text":"Type Name GPKGWriter (const std::string &amp; filename, const std::string &amp; projection)  void add_layer (const std::string &amp; layer_name)  void write_polyline (const Polyline &amp; polyline, const std::map&lt; std::string, std::variant&lt; int, double, std::string &gt; &gt; &amp; data_fields={})"},{"location":"blaze/classGPKGWriter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGPKGWriter/#function-gpkgwriter","title":"function GPKGWriter","text":"<pre><code>inline GPKGWriter::GPKGWriter (\n    const std::string &amp; filename,\n    const std::string &amp; projection\n) \n</code></pre>"},{"location":"blaze/classGPKGWriter/#function-add_layer","title":"function add_layer","text":"<pre><code>inline void GPKGWriter::add_layer (\n    const std::string &amp; layer_name\n) \n</code></pre>"},{"location":"blaze/classGPKGWriter/#function-write_polyline","title":"function write_polyline","text":"<pre><code>inline void GPKGWriter::write_polyline (\n    const  Polyline &amp; polyline,\n    const std::map&lt; std::string, std::variant&lt; int , double , std::string &gt; &gt; &amp; data_fields={}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/io/gpkg.hpp</code></p>"},{"location":"blaze/classGeo/","title":"Class Geo","text":"<p>template &lt;typename GridT&gt;</p> <p>ClassList &gt; Geo</p> <p>Inherits the following classes: GridT,  GeoGridData</p> <p>Inherited by the following classes: TestGrid,  TestGrid</p>"},{"location":"blaze/classGeo/#public-functions","title":"Public Functions","text":"Type Name Geo (size_t width, size_t height, GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection)  Geo (GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection, Args... args)  std::unique_ptr&lt; Extent2D &gt; extent () const void fill_from (const Geo&lt; U &gt; &amp; other)  void fill_from (const U &amp; other)  double height_m () const Geo slice (const Extent2D &amp; extent)  double width_m () const"},{"location":"blaze/classGeo/#public-functions-inherited-from-geogriddata","title":"Public Functions inherited from GeoGridData","text":"<p>See GeoGridData</p> Type Name GeoGridData (GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection)  double dx () const double dy () const const GeoProjection &amp; projection () const const GeoTransform &amp; transform () const"},{"location":"blaze/classGeo/#public-static-functions","title":"Public Static Functions","text":"Type Name Geo&lt; Grid&lt; RGBColor &gt; &gt; FromGeoImg (const GeoImgGrid &amp; grid)  Geo FromPoints (const Geo &amp; grid)"},{"location":"blaze/classGeo/#protected-attributes-inherited-from-geogriddata","title":"Protected Attributes inherited from GeoGridData","text":"<p>See GeoGridData</p> Type Name GeoProjection m_projection GeoTransform m_transform"},{"location":"blaze/classGeo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGeo/#function-geo-12","title":"function Geo [1/2]","text":"<pre><code>inline Geo::Geo (\n    size_t width,\n    size_t height,\n    GeoTransform &amp;&amp; transform,\n    GeoProjection &amp;&amp; projection\n) \n</code></pre>"},{"location":"blaze/classGeo/#function-geo-22","title":"function Geo [2/2]","text":"<pre><code>template&lt;typename... Args&gt;\ninline Geo::Geo (\n    GeoTransform &amp;&amp; transform,\n    GeoProjection &amp;&amp; projection,\n    Args... args\n) \n</code></pre>"},{"location":"blaze/classGeo/#function-extent","title":"function extent","text":"<pre><code>std::unique_ptr&lt; Extent2D &gt; Geo::extent () const\n</code></pre>"},{"location":"blaze/classGeo/#function-fill_from-12","title":"function fill_from [1/2]","text":"<pre><code>template&lt;typename  U&gt;\ninline void Geo::fill_from (\n    const  Geo &lt; U &gt; &amp; other\n) \n</code></pre>"},{"location":"blaze/classGeo/#function-fill_from-22","title":"function fill_from [2/2]","text":"<pre><code>template&lt;typename  U&gt;\ninline void Geo::fill_from (\n    const  U &amp; other\n) \n</code></pre>"},{"location":"blaze/classGeo/#function-height_m","title":"function height_m","text":"<pre><code>inline double Geo::height_m () const\n</code></pre>"},{"location":"blaze/classGeo/#function-slice","title":"function slice","text":"<pre><code>Geo Geo::slice (\n    const  Extent2D &amp; extent\n) \n</code></pre>"},{"location":"blaze/classGeo/#function-width_m","title":"function width_m","text":"<pre><code>inline double Geo::width_m () const\n</code></pre>"},{"location":"blaze/classGeo/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/classGeo/#function-fromgeoimg","title":"function FromGeoImg","text":"<pre><code>static Geo &lt; Grid &lt; RGBColor &gt; &gt; Geo::FromGeoImg (\n    const  GeoImgGrid &amp; grid\n) \n</code></pre>"},{"location":"blaze/classGeo/#function-frompoints","title":"function FromPoints","text":"<pre><code>template&lt;typename  U&gt;\nstatic inline Geo Geo::FromPoints (\n    const  Geo &amp; grid\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/classGeoGridData/","title":"Class GeoGridData","text":"<p>ClassList &gt; GeoGridData</p> <p>Inherited by the following classes: Geo,  GeoImgGrid</p>"},{"location":"blaze/classGeoGridData/#public-functions","title":"Public Functions","text":"Type Name GeoGridData (GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection)  double dx () const double dy () const const GeoProjection &amp; projection () const const GeoTransform &amp; transform () const"},{"location":"blaze/classGeoGridData/#protected-attributes","title":"Protected Attributes","text":"Type Name GeoProjection m_projection GeoTransform m_transform"},{"location":"blaze/classGeoGridData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGeoGridData/#function-geogriddata","title":"function GeoGridData","text":"<pre><code>inline GeoGridData::GeoGridData (\n    GeoTransform &amp;&amp; transform,\n    GeoProjection &amp;&amp; projection\n) \n</code></pre>"},{"location":"blaze/classGeoGridData/#function-dx","title":"function dx","text":"<pre><code>inline double GeoGridData::dx () const\n</code></pre>"},{"location":"blaze/classGeoGridData/#function-dy","title":"function dy","text":"<pre><code>inline double GeoGridData::dy () const\n</code></pre>"},{"location":"blaze/classGeoGridData/#function-projection","title":"function projection","text":"<pre><code>inline const  GeoProjection &amp; GeoGridData::projection () const\n</code></pre>"},{"location":"blaze/classGeoGridData/#function-transform","title":"function transform","text":"<pre><code>inline const  GeoTransform &amp; GeoGridData::transform () const\n</code></pre>"},{"location":"blaze/classGeoGridData/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"blaze/classGeoGridData/#variable-m_projection","title":"variable m_projection","text":"<pre><code>GeoProjection GeoGridData::m_projection;\n</code></pre>"},{"location":"blaze/classGeoGridData/#variable-m_transform","title":"variable m_transform","text":"<pre><code>GeoTransform GeoGridData::m_transform;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/classGeoImgGrid/","title":"Class GeoImgGrid","text":"<p>ClassList &gt; GeoImgGrid</p> <p>Inherits the following classes: ImgGrid,  GeoGridData</p>"},{"location":"blaze/classGeoImgGrid/#public-functions","title":"Public Functions","text":"Type Name GeoImgGrid (size_t width, size_t height, GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection)  GeoImgGrid (const GeoGrid&lt; ColorT &gt; &amp; grid)  void draw (const GeoImgGrid &amp; other, std::optional&lt; int &gt; interpolation={})  void draw (const Contour &amp; contour, const ColorVariant &amp; color, double width)  void draw (const std::vector&lt; Coordinate2D&lt; double &gt; &gt; &amp; in_points, const ColorVariant &amp; color, double width)  void draw_point (const Coordinate2D&lt; double &gt; &amp; point, const ColorVariant &amp; color, double size)  void save_to (const fs::path &amp; path, const Extent2D &amp; extent)"},{"location":"blaze/classGeoImgGrid/#public-functions-inherited-from-imggrid","title":"Public Functions inherited from ImgGrid","text":"<p>See ImgGrid</p> Type Name ImgGrid (size_t height, size_t width, std::optional&lt; int &gt; type={})  RGBColor get_rgb_color (size_t row, size_t col) const void save_to (const fs::path &amp; path)  ~ImgGrid ()"},{"location":"blaze/classGeoImgGrid/#public-functions-inherited-from-griddata","title":"Public Functions inherited from GridData","text":"<p>See GridData</p> Type Name GridData (size_t width, size_t height)  size_t height () const bool in_bounds (const Coordinate2D&lt; size_t &gt; &amp; coord) const size_t width () const"},{"location":"blaze/classGeoImgGrid/#public-functions-inherited-from-geogriddata","title":"Public Functions inherited from GeoGridData","text":"<p>See GeoGridData</p> Type Name GeoGridData (GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection)  double dx () const double dy () const const GeoProjection &amp; projection () const const GeoTransform &amp; transform () const"},{"location":"blaze/classGeoImgGrid/#protected-attributes-inherited-from-imggrid","title":"Protected Attributes inherited from ImgGrid","text":"<p>See ImgGrid</p> Type Name std::unique_ptr&lt; cv::Mat &gt; m_img"},{"location":"blaze/classGeoImgGrid/#protected-attributes-inherited-from-griddata","title":"Protected Attributes inherited from GridData","text":"<p>See GridData</p> Type Name size_t m_height size_t m_width"},{"location":"blaze/classGeoImgGrid/#protected-attributes-inherited-from-geogriddata","title":"Protected Attributes inherited from GeoGridData","text":"<p>See GeoGridData</p> Type Name GeoProjection m_projection GeoTransform m_transform"},{"location":"blaze/classGeoImgGrid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGeoImgGrid/#function-geoimggrid-12","title":"function GeoImgGrid [1/2]","text":"<pre><code>inline GeoImgGrid::GeoImgGrid (\n    size_t width,\n    size_t height,\n    GeoTransform &amp;&amp; transform,\n    GeoProjection &amp;&amp; projection\n) \n</code></pre>"},{"location":"blaze/classGeoImgGrid/#function-geoimggrid-22","title":"function GeoImgGrid [2/2]","text":"<pre><code>template&lt;typename  ColorT, typename&gt;\nexplicit GeoImgGrid::GeoImgGrid (\n    const  GeoGrid &lt; ColorT &gt; &amp; grid\n) \n</code></pre>"},{"location":"blaze/classGeoImgGrid/#function-draw-13","title":"function draw [1/3]","text":"<pre><code>void GeoImgGrid::draw (\n    const  GeoImgGrid &amp; other,\n    std::optional&lt; int &gt; interpolation={}\n) \n</code></pre>"},{"location":"blaze/classGeoImgGrid/#function-draw-23","title":"function draw [2/3]","text":"<pre><code>void GeoImgGrid::draw (\n    const  Contour &amp; contour,\n    const ColorVariant &amp; color,\n    double width\n) \n</code></pre>"},{"location":"blaze/classGeoImgGrid/#function-draw-33","title":"function draw [3/3]","text":"<pre><code>void GeoImgGrid::draw (\n    const std::vector&lt; Coordinate2D &lt; double &gt; &gt; &amp; in_points,\n    const ColorVariant &amp; color,\n    double width\n) \n</code></pre>"},{"location":"blaze/classGeoImgGrid/#function-draw_point","title":"function draw_point","text":"<pre><code>void GeoImgGrid::draw_point (\n    const  Coordinate2D &lt; double &gt; &amp; point,\n    const ColorVariant &amp; color,\n    double size\n) \n</code></pre>"},{"location":"blaze/classGeoImgGrid/#function-save_to","title":"function save_to","text":"<pre><code>void GeoImgGrid::save_to (\n    const fs::path &amp; path,\n    const  Extent2D &amp; extent\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/img_grid.hpp</code></p>"},{"location":"blaze/classGeoProjection/","title":"Class GeoProjection","text":"<p>ClassList &gt; GeoProjection</p>"},{"location":"blaze/classGeoProjection/#public-functions","title":"Public Functions","text":"Type Name GeoProjection (const std::string &amp; projection)  GeoProjection () = default const std::string &amp; to_string () const"},{"location":"blaze/classGeoProjection/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGeoProjection/#function-geoprojection-12","title":"function GeoProjection [1/2]","text":"<pre><code>inline explicit GeoProjection::GeoProjection (\n    const std::string &amp; projection\n) \n</code></pre>"},{"location":"blaze/classGeoProjection/#function-geoprojection-22","title":"function GeoProjection [2/2]","text":"<pre><code>GeoProjection::GeoProjection () = default\n</code></pre>"},{"location":"blaze/classGeoProjection/#function-to_string","title":"function to_string","text":"<pre><code>inline const std::string &amp; GeoProjection::to_string () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/classGeoTransform/","title":"Class GeoTransform","text":"<p>ClassList &gt; GeoTransform</p>"},{"location":"blaze/classGeoTransform/#public-functions","title":"Public Functions","text":"Type Name GeoTransform (double upper_left_x, double upper_left_y, double dx=1.0, double dy=-1.0)  GeoTransform (const Coordinate2D&lt; double &gt; &amp; upper_left, double resolution)  GeoTransform ()  GeoTransform (GDALDataset &amp; dataset)  double dx () const double dy () const const double * get_raw () const Coordinate2D&lt; double &gt; pixel_to_projection (const Coordinate2D&lt; double &gt; &amp; coord) const Coordinate2D&lt; double &gt; projection_to_pixel (const Coordinate2D&lt; double &gt; &amp; coord) const double rot_x () const double rot_y () const void set_dx (double dx)  void set_dy (double dy)  GeoTransform with_new_resolution (double new_resolution) const double x () const double y () const"},{"location":"blaze/classGeoTransform/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGeoTransform/#function-geotransform-14","title":"function GeoTransform [1/4]","text":"<pre><code>inline GeoTransform::GeoTransform (\n    double upper_left_x,\n    double upper_left_y,\n    double dx=1.0,\n    double dy=-1.0\n) \n</code></pre>"},{"location":"blaze/classGeoTransform/#function-geotransform-24","title":"function GeoTransform [2/4]","text":"<pre><code>inline explicit GeoTransform::GeoTransform (\n    const  Coordinate2D &lt; double &gt; &amp; upper_left,\n    double resolution\n) \n</code></pre>"},{"location":"blaze/classGeoTransform/#function-geotransform-34","title":"function GeoTransform [3/4]","text":"<pre><code>inline GeoTransform::GeoTransform () \n</code></pre>"},{"location":"blaze/classGeoTransform/#function-geotransform-44","title":"function GeoTransform [4/4]","text":"<pre><code>explicit GeoTransform::GeoTransform (\n    GDALDataset &amp; dataset\n) \n</code></pre>"},{"location":"blaze/classGeoTransform/#function-dx","title":"function dx","text":"<pre><code>inline double GeoTransform::dx () const\n</code></pre>"},{"location":"blaze/classGeoTransform/#function-dy","title":"function dy","text":"<pre><code>inline double GeoTransform::dy () const\n</code></pre>"},{"location":"blaze/classGeoTransform/#function-get_raw","title":"function get_raw","text":"<pre><code>inline const  double * GeoTransform::get_raw () const\n</code></pre>"},{"location":"blaze/classGeoTransform/#function-pixel_to_projection","title":"function pixel_to_projection","text":"<pre><code>inline Coordinate2D &lt; double &gt; GeoTransform::pixel_to_projection (\n    const  Coordinate2D &lt; double &gt; &amp; coord\n) const\n</code></pre>"},{"location":"blaze/classGeoTransform/#function-projection_to_pixel","title":"function projection_to_pixel","text":"<pre><code>inline Coordinate2D &lt; double &gt; GeoTransform::projection_to_pixel (\n    const  Coordinate2D &lt; double &gt; &amp; coord\n) const\n</code></pre>"},{"location":"blaze/classGeoTransform/#function-rot_x","title":"function rot_x","text":"<pre><code>inline double GeoTransform::rot_x () const\n</code></pre>"},{"location":"blaze/classGeoTransform/#function-rot_y","title":"function rot_y","text":"<pre><code>inline double GeoTransform::rot_y () const\n</code></pre>"},{"location":"blaze/classGeoTransform/#function-set_dx","title":"function set_dx","text":"<pre><code>inline void GeoTransform::set_dx (\n    double dx\n) \n</code></pre>"},{"location":"blaze/classGeoTransform/#function-set_dy","title":"function set_dy","text":"<pre><code>inline void GeoTransform::set_dy (\n    double dy\n) \n</code></pre>"},{"location":"blaze/classGeoTransform/#function-with_new_resolution","title":"function with_new_resolution","text":"<pre><code>inline GeoTransform GeoTransform::with_new_resolution (\n    double new_resolution\n) const\n</code></pre>"},{"location":"blaze/classGeoTransform/#function-x","title":"function x","text":"<pre><code>inline double GeoTransform::x () const\n</code></pre>"},{"location":"blaze/classGeoTransform/#function-y","title":"function y","text":"<pre><code>inline double GeoTransform::y () const\n</code></pre>"},{"location":"blaze/classGeoTransform/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classGeoTransform/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; GeoTransform::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  GeoTransform &amp; transform\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/classGrid/","title":"Class Grid","text":"<p>template &lt;typename U&gt;</p> <p>ClassList &gt; Grid</p> <p>Inherits the following classes: GridData</p>"},{"location":"blaze/classGrid/#public-types","title":"Public Types","text":"Type Name typedef T value_type"},{"location":"blaze/classGrid/#public-functions","title":"Public Functions","text":"Type Name Grid (size_t width, size_t height, int repeats=1)  void copy_from (const Grid &amp; other)  void fill (const T &amp; value)  void fill_from (const Grid &amp; other, const Coordinate2D&lt; size_t &gt; &amp; top_left={0, 0})  void fill_from (const FlexGrid &amp; other, const Coordinate2D&lt; long long &gt; &amp; top_left={0, 0})  std::pair&lt; T, T &gt; get_values (const LineCoord2D&lt; size_t &gt; &amp; coord) const T max_value () const T min_value () const T &amp; operator[] (Coordinate2D&lt; size_t &gt; coord)  const T &amp; operator[] (Coordinate2D&lt; size_t &gt; coord) const"},{"location":"blaze/classGrid/#public-functions-inherited-from-griddata","title":"Public Functions inherited from GridData","text":"<p>See GridData</p> Type Name GridData (size_t width, size_t height)  size_t height () const bool in_bounds (const Coordinate2D&lt; size_t &gt; &amp; coord) const size_t width () const"},{"location":"blaze/classGrid/#protected-types","title":"Protected Types","text":"Type Name typedef std::conditional_t&lt; std::is_same_v&lt; U, bool &gt;, BlazeBool, U &gt; T"},{"location":"blaze/classGrid/#protected-attributes","title":"Protected Attributes","text":"Type Name std::vector&lt; T &gt; m_data int m_repeats"},{"location":"blaze/classGrid/#protected-attributes-inherited-from-griddata","title":"Protected Attributes inherited from GridData","text":"<p>See GridData</p> Type Name size_t m_height size_t m_width"},{"location":"blaze/classGrid/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/classGrid/#typedef-value_type","title":"typedef value_type","text":"<pre><code>typedef T Grid&lt; U &gt;::value_type;\n</code></pre>"},{"location":"blaze/classGrid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGrid/#function-grid","title":"function Grid","text":"<pre><code>inline Grid::Grid (\n    size_t width,\n    size_t height,\n    int repeats=1\n) \n</code></pre>"},{"location":"blaze/classGrid/#function-copy_from","title":"function copy_from","text":"<pre><code>inline void Grid::copy_from (\n    const  Grid &amp; other\n) \n</code></pre>"},{"location":"blaze/classGrid/#function-fill","title":"function fill","text":"<pre><code>inline void Grid::fill (\n    const T &amp; value\n) \n</code></pre>"},{"location":"blaze/classGrid/#function-fill_from-12","title":"function fill_from [1/2]","text":"<pre><code>inline void Grid::fill_from (\n    const  Grid &amp; other,\n    const  Coordinate2D &lt; size_t &gt; &amp; top_left={0, 0}\n) \n</code></pre>"},{"location":"blaze/classGrid/#function-fill_from-22","title":"function fill_from [2/2]","text":"<pre><code>void Grid::fill_from (\n    const  FlexGrid &amp; other,\n    const  Coordinate2D &lt; long  long &gt; &amp; top_left={0, 0}\n) \n</code></pre>"},{"location":"blaze/classGrid/#function-get_values","title":"function get_values","text":"<pre><code>inline std::pair&lt; T, T &gt; Grid::get_values (\n    const  LineCoord2D &lt; size_t &gt; &amp; coord\n) const\n</code></pre>"},{"location":"blaze/classGrid/#function-max_value","title":"function max_value","text":"<pre><code>inline T Grid::max_value () const\n</code></pre>"},{"location":"blaze/classGrid/#function-min_value","title":"function min_value","text":"<pre><code>inline T Grid::min_value () const\n</code></pre>"},{"location":"blaze/classGrid/#function-operator","title":"function operator[]","text":"<pre><code>inline T &amp; Grid::operator[] (\n    Coordinate2D &lt; size_t &gt; coord\n) \n</code></pre>"},{"location":"blaze/classGrid/#function-operator_1","title":"function operator[]","text":"<pre><code>inline const T &amp; Grid::operator[] (\n    Coordinate2D &lt; size_t &gt; coord\n) const\n</code></pre>"},{"location":"blaze/classGrid/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"blaze/classGrid/#typedef-t","title":"typedef T","text":"<pre><code>using Grid&lt; U &gt;::T =  std::conditional_t&lt;std::is_same_v&lt;U, bool&gt;, BlazeBool, U&gt;;\n</code></pre>"},{"location":"blaze/classGrid/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"blaze/classGrid/#variable-m_data","title":"variable m_data","text":"<pre><code>std::vector&lt;T&gt; Grid&lt; U &gt;::m_data;\n</code></pre>"},{"location":"blaze/classGrid/#variable-m_repeats","title":"variable m_repeats","text":"<pre><code>int Grid&lt; U &gt;::m_repeats;\n</code></pre>"},{"location":"blaze/classGrid/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classGrid/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; Grid::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  Grid &amp; grid\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/structGridConfig/","title":"Struct GridConfig","text":"<p>ClassList &gt; GridConfig</p>"},{"location":"blaze/structGridConfig/#public-attributes","title":"Public Attributes","text":"Type Name double bin_resolution unsigned int downsample_factor"},{"location":"blaze/structGridConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structGridConfig/#variable-bin_resolution","title":"variable bin_resolution","text":"<pre><code>double GridConfig::bin_resolution;\n</code></pre>"},{"location":"blaze/structGridConfig/#variable-downsample_factor","title":"variable downsample_factor","text":"<pre><code>unsigned int GridConfig::downsample_factor;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/classGridData/","title":"Class GridData","text":"<p>ClassList &gt; GridData</p> <p>Inherited by the following classes: Grid,  FlexGrid,  Grid,  ImgGrid</p>"},{"location":"blaze/classGridData/#public-functions","title":"Public Functions","text":"Type Name GridData (size_t width, size_t height)  size_t height () const bool in_bounds (const Coordinate2D&lt; size_t &gt; &amp; coord) const size_t width () const"},{"location":"blaze/classGridData/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t m_height size_t m_width"},{"location":"blaze/classGridData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGridData/#function-griddata","title":"function GridData","text":"<pre><code>inline GridData::GridData (\n    size_t width,\n    size_t height\n) \n</code></pre>"},{"location":"blaze/classGridData/#function-height","title":"function height","text":"<pre><code>inline size_t GridData::height () const\n</code></pre>"},{"location":"blaze/classGridData/#function-in_bounds","title":"function in_bounds","text":"<pre><code>inline bool GridData::in_bounds (\n    const  Coordinate2D &lt; size_t &gt; &amp; coord\n) const\n</code></pre>"},{"location":"blaze/classGridData/#function-width","title":"function width","text":"<pre><code>inline size_t GridData::width () const\n</code></pre>"},{"location":"blaze/classGridData/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"blaze/classGridData/#variable-m_height","title":"variable m_height","text":"<pre><code>size_t GridData::m_height;\n</code></pre>"},{"location":"blaze/classGridData/#variable-m_width","title":"variable m_width","text":"<pre><code>size_t GridData::m_width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/classGridGraph/","title":"Class GridGraph","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; GridGraph</p>"},{"location":"blaze/classGridGraph/#public-functions","title":"Public Functions","text":"Type Name GridGraph (const Grid&lt; U &gt; &amp; grid)  size_t height () const Grid&lt; T &gt; &amp; horizontal ()  const Grid&lt; T &gt; &amp; horizontal () const bool in_bounds (const LineCoord2D&lt; U &gt; &amp; coord) const const T &amp; operator[] (const LineCoord2D&lt; size_t &gt; &amp; coord) const T &amp; operator[] (const LineCoord2D&lt; size_t &gt; &amp; coord)  Grid&lt; T &gt; &amp; vertical ()  const Grid&lt; T &gt; &amp; vertical () const size_t width () const"},{"location":"blaze/classGridGraph/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classGridGraph/#function-gridgraph","title":"function GridGraph","text":"<pre><code>template&lt;typename  U&gt;\ninline explicit GridGraph::GridGraph (\n    const  Grid &lt; U &gt; &amp; grid\n) \n</code></pre>"},{"location":"blaze/classGridGraph/#function-height","title":"function height","text":"<pre><code>inline size_t GridGraph::height () const\n</code></pre>"},{"location":"blaze/classGridGraph/#function-horizontal-12","title":"function horizontal [1/2]","text":"<pre><code>inline Grid &lt; T &gt; &amp; GridGraph::horizontal () \n</code></pre>"},{"location":"blaze/classGridGraph/#function-horizontal-22","title":"function horizontal [2/2]","text":"<pre><code>inline const  Grid &lt; T &gt; &amp; GridGraph::horizontal () const\n</code></pre>"},{"location":"blaze/classGridGraph/#function-in_bounds","title":"function in_bounds","text":"<pre><code>template&lt;typename  U&gt;\ninline bool GridGraph::in_bounds (\n    const  LineCoord2D &lt; U &gt; &amp; coord\n) const\n</code></pre>"},{"location":"blaze/classGridGraph/#function-operator","title":"function operator[]","text":"<pre><code>inline const T &amp; GridGraph::operator[] (\n    const  LineCoord2D &lt; size_t &gt; &amp; coord\n) const\n</code></pre>"},{"location":"blaze/classGridGraph/#function-operator_1","title":"function operator[]","text":"<pre><code>inline T &amp; GridGraph::operator[] (\n    const  LineCoord2D &lt; size_t &gt; &amp; coord\n) \n</code></pre>"},{"location":"blaze/classGridGraph/#function-vertical-12","title":"function vertical [1/2]","text":"<pre><code>inline Grid &lt; T &gt; &amp; GridGraph::vertical () \n</code></pre>"},{"location":"blaze/classGridGraph/#function-vertical-22","title":"function vertical [2/2]","text":"<pre><code>inline const  Grid &lt; T &gt; &amp; GridGraph::vertical () const\n</code></pre>"},{"location":"blaze/classGridGraph/#function-width","title":"function width","text":"<pre><code>inline size_t GridGraph::width () const\n</code></pre>"},{"location":"blaze/classGridGraph/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classGridGraph/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; GridGraph::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  GridGraph &amp; graph\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/structGroundConfig/","title":"Struct GroundConfig","text":"<p>ClassList &gt; GroundConfig</p>"},{"location":"blaze/structGroundConfig/#public-attributes","title":"Public Attributes","text":"Type Name int max_ground_intensity int min_ground_intensity double outlier_removal_height_diff"},{"location":"blaze/structGroundConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structGroundConfig/#variable-max_ground_intensity","title":"variable max_ground_intensity","text":"<pre><code>int GroundConfig::max_ground_intensity;\n</code></pre>"},{"location":"blaze/structGroundConfig/#variable-min_ground_intensity","title":"variable min_ground_intensity","text":"<pre><code>int GroundConfig::min_ground_intensity;\n</code></pre>"},{"location":"blaze/structGroundConfig/#variable-outlier_removal_height_diff","title":"variable outlier_removal_height_diff","text":"<pre><code>double GroundConfig::outlier_removal_height_diff;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/classImgGrid/","title":"Class ImgGrid","text":"<p>ClassList &gt; ImgGrid</p> <p>Inherits the following classes: GridData</p> <p>Inherited by the following classes: GeoImgGrid</p>"},{"location":"blaze/classImgGrid/#public-functions","title":"Public Functions","text":"Type Name ImgGrid (size_t height, size_t width, std::optional&lt; int &gt; type={})  RGBColor get_rgb_color (size_t row, size_t col) const void save_to (const fs::path &amp; path)  ~ImgGrid ()"},{"location":"blaze/classImgGrid/#public-functions-inherited-from-griddata","title":"Public Functions inherited from GridData","text":"<p>See GridData</p> Type Name GridData (size_t width, size_t height)  size_t height () const bool in_bounds (const Coordinate2D&lt; size_t &gt; &amp; coord) const size_t width () const"},{"location":"blaze/classImgGrid/#protected-attributes","title":"Protected Attributes","text":"Type Name std::unique_ptr&lt; cv::Mat &gt; m_img"},{"location":"blaze/classImgGrid/#protected-attributes-inherited-from-griddata","title":"Protected Attributes inherited from GridData","text":"<p>See GridData</p> Type Name size_t m_height size_t m_width"},{"location":"blaze/classImgGrid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classImgGrid/#function-imggrid","title":"function ImgGrid","text":"<pre><code>ImgGrid::ImgGrid (\n    size_t height,\n    size_t width,\n    std::optional&lt; int &gt; type={}\n) \n</code></pre>"},{"location":"blaze/classImgGrid/#function-get_rgb_color","title":"function get_rgb_color","text":"<pre><code>RGBColor ImgGrid::get_rgb_color (\n    size_t row,\n    size_t col\n) const\n</code></pre>"},{"location":"blaze/classImgGrid/#function-save_to","title":"function save_to","text":"<pre><code>void ImgGrid::save_to (\n    const fs::path &amp; path\n) \n</code></pre>"},{"location":"blaze/classImgGrid/#function-imggrid_1","title":"function ~ImgGrid","text":"<pre><code>ImgGrid::~ImgGrid () \n</code></pre>"},{"location":"blaze/classImgGrid/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"blaze/classImgGrid/#variable-m_img","title":"variable m_img","text":"<pre><code>std::unique_ptr&lt;cv::Mat&gt; ImgGrid::m_img;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/img_grid.hpp</code></p>"},{"location":"blaze/classLASData/","title":"Class LASData","text":"<p>ClassList &gt; LASData</p> <p>Inherits the following classes: LASFile</p> <p>Inherited by the following classes: AsyncLASData</p>"},{"location":"blaze/classLASData/#public-functions","title":"Public Functions","text":"Type Name LASData (const Extent2D &amp; bounds, const GeoProjection &amp; projection)  LASData (const GeoGrid&lt; T &gt; &amp; grid)  LASData (const fs::path &amp; filename, ProgressTracker progress_tracker, bool skip_reading_points=false, std::optional&lt; Extent2D &gt; bounds=std::nullopt)  auto begin ()  auto end ()  void extract_borders (const fs::path &amp; tmp_dir, double border_width, ProgressTracker progress_tracker) const void insert (const LASPoint &amp; point)  std::pair&lt; uint16_t, uint16_t &gt; intensity_range () const std::size_t n_points () const const LASPoint &amp; operator[] (std::size_t i) const LASPoint &amp; operator[] (std::size_t i)  void push_back (const LASPoint &amp; point)  void write (const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker={}) const"},{"location":"blaze/classLASData/#public-functions-inherited-from-lasfile","title":"Public Functions inherited from LASFile","text":"<p>See LASFile</p> Type Name LASFile (const Extent2D &amp; bounds, GeoProjection &amp;&amp; projection)  LASFile (const fs::path &amp; filename, ProgressTracker progress_tracker)  const Extent3D &amp; bounds () const Extent2D export_bounds () const double height () const std::pair&lt; double, double &gt; height_range () const Extent2D original_bounds () const const GeoProjection &amp; projection () const Coordinate2D&lt; double &gt; top_left () const double width () const"},{"location":"blaze/classLASData/#public-static-functions","title":"Public Static Functions","text":"Type Name LASData with_border (const fs::path &amp; filename, double border_width, const std::vector&lt; std::pair&lt; Extent3D, fs::path &gt; &gt; &amp; all_las_file_extents, ProgressTracker progress_tracker)  LASData with_border (const fs::path &amp; filename, double border_width, ProgressTracker progress_tracker)"},{"location":"blaze/classLASData/#protected-attributes-inherited-from-lasfile","title":"Protected Attributes inherited from LASFile","text":"<p>See LASFile</p> Type Name Extent3D m_bounds std::optional&lt; fs::path &gt; m_filename Extent3D m_original_bounds GeoProjection m_projection laspp::QuadtreeSpatialIndex m_spatial_index"},{"location":"blaze/classLASData/#protected-functions","title":"Protected Functions","text":"Type Name void read_points (laspp::LASReader &amp; reader, ProgressTracker progress_tracker, std::optional&lt; Extent2D &gt; bounds=std::nullopt)"},{"location":"blaze/classLASData/#protected-functions-inherited-from-lasfile","title":"Protected Functions inherited from LASFile","text":"<p>See LASFile</p> Type Name void from_las_reader (const laspp::LASReader &amp; reader)"},{"location":"blaze/classLASData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classLASData/#function-lasdata-13","title":"function LASData [1/3]","text":"<pre><code>inline LASData::LASData (\n    const  Extent2D &amp; bounds,\n    const  GeoProjection &amp; projection\n) \n</code></pre>"},{"location":"blaze/classLASData/#function-lasdata-23","title":"function LASData [2/3]","text":"<pre><code>template&lt;typename T&gt;\ninline explicit LASData::LASData (\n    const  GeoGrid &lt; T &gt; &amp; grid\n) \n</code></pre>"},{"location":"blaze/classLASData/#function-lasdata-33","title":"function LASData [3/3]","text":"<pre><code>inline explicit LASData::LASData (\n    const fs::path &amp; filename,\n    ProgressTracker progress_tracker,\n    bool skip_reading_points=false,\n    std::optional&lt; Extent2D &gt; bounds=std::nullopt\n) \n</code></pre>"},{"location":"blaze/classLASData/#function-begin","title":"function begin","text":"<pre><code>inline auto LASData::begin () \n</code></pre>"},{"location":"blaze/classLASData/#function-end","title":"function end","text":"<pre><code>inline auto LASData::end () \n</code></pre>"},{"location":"blaze/classLASData/#function-extract_borders","title":"function extract_borders","text":"<pre><code>inline void LASData::extract_borders (\n    const fs::path &amp; tmp_dir,\n    double border_width,\n    ProgressTracker progress_tracker\n) const\n</code></pre>"},{"location":"blaze/classLASData/#function-insert","title":"function insert","text":"<pre><code>inline void LASData::insert (\n    const  LASPoint &amp; point\n) \n</code></pre>"},{"location":"blaze/classLASData/#function-intensity_range","title":"function intensity_range","text":"<pre><code>inline std::pair&lt; uint16_t , uint16_t &gt; LASData::intensity_range () const\n</code></pre>"},{"location":"blaze/classLASData/#function-n_points","title":"function n_points","text":"<pre><code>inline std::size_t LASData::n_points () const\n</code></pre>"},{"location":"blaze/classLASData/#function-operator","title":"function operator[]","text":"<pre><code>inline const  LASPoint &amp; LASData::operator[] (\n    std::size_t i\n) const\n</code></pre>"},{"location":"blaze/classLASData/#function-operator_1","title":"function operator[]","text":"<pre><code>inline LASPoint &amp; LASData::operator[] (\n    std::size_t i\n) \n</code></pre>"},{"location":"blaze/classLASData/#function-push_back","title":"function push_back","text":"<pre><code>inline void LASData::push_back (\n    const  LASPoint &amp; point\n) \n</code></pre>"},{"location":"blaze/classLASData/#function-write","title":"function write","text":"<pre><code>inline void LASData::write (\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker={}\n) const\n</code></pre>"},{"location":"blaze/classLASData/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/classLASData/#function-with_border-12","title":"function with_border [1/2]","text":"<pre><code>static inline LASData LASData::with_border (\n    const fs::path &amp; filename,\n    double border_width,\n    const std::vector&lt; std::pair&lt; Extent3D , fs::path &gt; &gt; &amp; all_las_file_extents,\n    ProgressTracker progress_tracker\n) \n</code></pre>"},{"location":"blaze/classLASData/#function-with_border-22","title":"function with_border [2/2]","text":"<pre><code>static inline LASData LASData::with_border (\n    const fs::path &amp; filename,\n    double border_width,\n    ProgressTracker progress_tracker\n) \n</code></pre>"},{"location":"blaze/classLASData/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"blaze/classLASData/#function-read_points","title":"function read_points","text":"<pre><code>inline void LASData::read_points (\n    laspp::LASReader &amp; reader,\n    ProgressTracker progress_tracker,\n    std::optional&lt; Extent2D &gt; bounds=std::nullopt\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/las/las_file.hpp</code></p>"},{"location":"blaze/classLASFile/","title":"Class LASFile","text":"<p>ClassList &gt; LASFile</p> <p>Inherited by the following classes: LASData</p>"},{"location":"blaze/classLASFile/#public-functions","title":"Public Functions","text":"Type Name LASFile (const Extent2D &amp; bounds, GeoProjection &amp;&amp; projection)  LASFile (const fs::path &amp; filename, ProgressTracker progress_tracker)  const Extent3D &amp; bounds () const Extent2D export_bounds () const double height () const std::pair&lt; double, double &gt; height_range () const Extent2D original_bounds () const const GeoProjection &amp; projection () const Coordinate2D&lt; double &gt; top_left () const double width () const"},{"location":"blaze/classLASFile/#protected-attributes","title":"Protected Attributes","text":"Type Name Extent3D m_bounds std::optional&lt; fs::path &gt; m_filename Extent3D m_original_bounds GeoProjection m_projection laspp::QuadtreeSpatialIndex m_spatial_index"},{"location":"blaze/classLASFile/#protected-functions","title":"Protected Functions","text":"Type Name void from_las_reader (const laspp::LASReader &amp; reader)"},{"location":"blaze/classLASFile/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classLASFile/#function-lasfile-12","title":"function LASFile [1/2]","text":"<pre><code>inline explicit LASFile::LASFile (\n    const  Extent2D &amp; bounds,\n    GeoProjection &amp;&amp; projection\n) \n</code></pre>"},{"location":"blaze/classLASFile/#function-lasfile-22","title":"function LASFile [2/2]","text":"<pre><code>inline explicit LASFile::LASFile (\n    const fs::path &amp; filename,\n    ProgressTracker progress_tracker\n) \n</code></pre>"},{"location":"blaze/classLASFile/#function-bounds","title":"function bounds","text":"<pre><code>inline const  Extent3D &amp; LASFile::bounds () const\n</code></pre>"},{"location":"blaze/classLASFile/#function-export_bounds","title":"function export_bounds","text":"<pre><code>inline Extent2D LASFile::export_bounds () const\n</code></pre>"},{"location":"blaze/classLASFile/#function-height","title":"function height","text":"<pre><code>inline double LASFile::height () const\n</code></pre>"},{"location":"blaze/classLASFile/#function-height_range","title":"function height_range","text":"<pre><code>inline std::pair&lt; double , double &gt; LASFile::height_range () const\n</code></pre>"},{"location":"blaze/classLASFile/#function-original_bounds","title":"function original_bounds","text":"<pre><code>inline Extent2D LASFile::original_bounds () const\n</code></pre>"},{"location":"blaze/classLASFile/#function-projection","title":"function projection","text":"<pre><code>inline const  GeoProjection &amp; LASFile::projection () const\n</code></pre>"},{"location":"blaze/classLASFile/#function-top_left","title":"function top_left","text":"<pre><code>inline Coordinate2D &lt; double &gt; LASFile::top_left () const\n</code></pre>"},{"location":"blaze/classLASFile/#function-width","title":"function width","text":"<pre><code>inline double LASFile::width () const\n</code></pre>"},{"location":"blaze/classLASFile/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"blaze/classLASFile/#variable-m_bounds","title":"variable m_bounds","text":"<pre><code>Extent3D LASFile::m_bounds;\n</code></pre>"},{"location":"blaze/classLASFile/#variable-m_filename","title":"variable m_filename","text":"<pre><code>std::optional&lt;fs::path&gt; LASFile::m_filename;\n</code></pre>"},{"location":"blaze/classLASFile/#variable-m_original_bounds","title":"variable m_original_bounds","text":"<pre><code>Extent3D LASFile::m_original_bounds;\n</code></pre>"},{"location":"blaze/classLASFile/#variable-m_projection","title":"variable m_projection","text":"<pre><code>GeoProjection LASFile::m_projection;\n</code></pre>"},{"location":"blaze/classLASFile/#variable-m_spatial_index","title":"variable m_spatial_index","text":"<pre><code>laspp::QuadtreeSpatialIndex LASFile::m_spatial_index;\n</code></pre>"},{"location":"blaze/classLASFile/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"blaze/classLASFile/#function-from_las_reader","title":"function from_las_reader","text":"<pre><code>inline void LASFile::from_las_reader (\n    const laspp::LASReader &amp; reader\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/las/las_file.hpp</code></p>"},{"location":"blaze/classLASLayer/","title":"Class LASLayer","text":"<p>ClassList &gt; LASLayer</p> <p>Inherits the following classes: PointLayer</p>"},{"location":"blaze/classLASLayer/#public-signals-inherited-from-layer","title":"Public Signals inherited from Layer","text":"<p>See Layer</p> Type Name signal void data_updated"},{"location":"blaze/classLASLayer/#public-functions","title":"Public Functions","text":"Type Name LASLayer (const fs::path &amp; file, AsyncProgressTracker progress_tracker)  virtual Extent3D extent () override const const AsyncLASData &amp; las_file () const AsyncLASData &amp; las_file ()  virtual std::string projection () override const"},{"location":"blaze/classLASLayer/#public-functions-inherited-from-pointlayer","title":"Public Functions inherited from PointLayer","text":"<p>See PointLayer</p> Type Name virtual ~PointLayer () = default"},{"location":"blaze/classLASLayer/#public-functions-inherited-from-layer","title":"Public Functions inherited from Layer","text":"<p>See Layer</p> Type Name virtual Extent3D extent () const = 0 virtual std::string name ()  virtual std::string projection () const = 0 virtual ~Layer () = default"},{"location":"blaze/classLASLayer/#protected-attributes-inherited-from-layer","title":"Protected Attributes inherited from Layer","text":"<p>See Layer</p> Type Name std::string m_name"},{"location":"blaze/classLASLayer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classLASLayer/#function-laslayer","title":"function LASLayer","text":"<pre><code>inline explicit LASLayer::LASLayer (\n    const fs::path &amp; file,\n    AsyncProgressTracker progress_tracker\n) \n</code></pre>"},{"location":"blaze/classLASLayer/#function-extent","title":"function extent","text":"<pre><code>inline virtual Extent3D LASLayer::extent () override const\n</code></pre> <p>Implements Layer::extent</p>"},{"location":"blaze/classLASLayer/#function-las_file-12","title":"function las_file [1/2]","text":"<pre><code>inline const  AsyncLASData &amp; LASLayer::las_file () const\n</code></pre>"},{"location":"blaze/classLASLayer/#function-las_file-22","title":"function las_file [2/2]","text":"<pre><code>inline AsyncLASData &amp; LASLayer::las_file () \n</code></pre>"},{"location":"blaze/classLASLayer/#function-projection","title":"function projection","text":"<pre><code>inline virtual std::string LASLayer::projection () override const\n</code></pre> <p>Implements Layer::projection</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/layer.hpp</code></p>"},{"location":"blaze/classLASLayerRenderer/","title":"Class LASLayerRenderer","text":"<p>ClassList &gt; LASLayerRenderer</p> <p>Inherits the following classes: LayerRenderer</p>"},{"location":"blaze/classLASLayerRenderer/#public-signals-inherited-from-layerrenderer","title":"Public Signals inherited from LayerRenderer","text":"<p>See LayerRenderer</p> Type Name signal void repaint_required"},{"location":"blaze/classLASLayerRenderer/#public-functions","title":"Public Functions","text":"Type Name LASLayerRenderer (std::shared_ptr&lt; LASLayer &gt; layer, const Coordinate3D&lt; double &gt; &amp; offset)  void load_data (std::shared_ptr&lt; LASLayer &gt; layer, const Coordinate3D&lt; double &gt; &amp; offset)  virtual void render (const Camera &amp; camera) override virtual ~LASLayerRenderer () = default"},{"location":"blaze/classLASLayerRenderer/#public-functions-inherited-from-layerrenderer","title":"Public Functions inherited from LayerRenderer","text":"<p>See LayerRenderer</p> Type Name void data_update_required ()  virtual void render (const Camera &amp; camera) = 0 virtual ~LayerRenderer () = default"},{"location":"blaze/classLASLayerRenderer/#public-static-functions-inherited-from-layerrenderer","title":"Public Static Functions inherited from LayerRenderer","text":"<p>See LayerRenderer</p> Type Name std::unique_ptr&lt; LayerRenderer &gt; create (std::shared_ptr&lt; Layer &gt; layer, const Coordinate3D&lt; double &gt; &amp; offset)"},{"location":"blaze/classLASLayerRenderer/#protected-attributes-inherited-from-layerrenderer","title":"Protected Attributes inherited from LayerRenderer","text":"<p>See LayerRenderer</p> Type Name bool m_data_update_required   = <code>[**true**](classCoordinate2D.md)</code>"},{"location":"blaze/classLASLayerRenderer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classLASLayerRenderer/#function-laslayerrenderer","title":"function LASLayerRenderer","text":"<pre><code>inline LASLayerRenderer::LASLayerRenderer (\n    std::shared_ptr&lt; LASLayer &gt; layer,\n    const  Coordinate3D &lt; double &gt; &amp; offset\n) \n</code></pre>"},{"location":"blaze/classLASLayerRenderer/#function-load_data","title":"function load_data","text":"<pre><code>inline void LASLayerRenderer::load_data (\n    std::shared_ptr&lt; LASLayer &gt; layer,\n    const  Coordinate3D &lt; double &gt; &amp; offset\n) \n</code></pre>"},{"location":"blaze/classLASLayerRenderer/#function-render","title":"function render","text":"<pre><code>inline virtual void LASLayerRenderer::render (\n    const  Camera &amp; camera\n) override\n</code></pre> <p>Implements LayerRenderer::render</p>"},{"location":"blaze/classLASLayerRenderer/#function-laslayerrenderer_1","title":"function ~LASLayerRenderer","text":"<pre><code>virtual LASLayerRenderer::~LASLayerRenderer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/layer_renderer.hpp</code></p>"},{"location":"blaze/classLASPoint/","title":"Class LASPoint","text":"<p>ClassList &gt; LASPoint</p> <p>Inherits the following classes: Coordinate3D</p>"},{"location":"blaze/classLASPoint/#public-functions","title":"Public Functions","text":"Type Name LASPoint (double x, double y, double z, uint16_t intensity, LASClassification classification)  LASPoint () = default LASClassification classification () const LASClassification &amp; classification ()  uint16_t intensity () const uint16_t &amp; intensity ()"},{"location":"blaze/classLASPoint/#public-functions-inherited-from-coordinate3d","title":"Public Functions inherited from Coordinate3D","text":"<p>See Coordinate3D</p> Type Name Coordinate3D (T x, T y, T z)  Coordinate3D () = default const T z () const T &amp; z ()"},{"location":"blaze/classLASPoint/#public-functions-inherited-from-coordinate2d","title":"Public Functions inherited from Coordinate2D","text":"<p>See Coordinate2D</p> Type Name Coordinate2D (T x, T y)  Coordinate2D () = default T magnitude () const T magnitude_sqd () const Coordinate2D&lt; double &gt; offset_to_center () const operator Coordinate2D&lt; U &gt; () const Coordinate2D operator+ (Direction2D dir) const Coordinate2D operator+ (Coordinate2D o) const Coordinate2D operator- (Coordinate2D o) const bool operator== (const Coordinate2D &amp; o) const Coordinate2D&lt; size_t &gt; round () const Coordinate2D&lt; double &gt; round_NW (double grid_size) const const T &amp; x () const T &amp; x ()  const T &amp; y () const T &amp; y ()"},{"location":"blaze/classLASPoint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classLASPoint/#function-laspoint-12","title":"function LASPoint [1/2]","text":"<pre><code>inline LASPoint::LASPoint (\n    double x,\n    double y,\n    double z,\n    uint16_t intensity,\n    LASClassification classification\n) \n</code></pre>"},{"location":"blaze/classLASPoint/#function-laspoint-22","title":"function LASPoint [2/2]","text":"<pre><code>LASPoint::LASPoint () = default\n</code></pre>"},{"location":"blaze/classLASPoint/#function-classification-12","title":"function classification [1/2]","text":"<pre><code>inline LASClassification LASPoint::classification () const\n</code></pre>"},{"location":"blaze/classLASPoint/#function-classification-22","title":"function classification [2/2]","text":"<pre><code>inline LASClassification &amp; LASPoint::classification () \n</code></pre>"},{"location":"blaze/classLASPoint/#function-intensity-12","title":"function intensity [1/2]","text":"<pre><code>inline uint16_t LASPoint::intensity () const\n</code></pre>"},{"location":"blaze/classLASPoint/#function-intensity-22","title":"function intensity [2/2]","text":"<pre><code>inline uint16_t &amp; LASPoint::intensity () \n</code></pre>"},{"location":"blaze/classLASPoint/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classLASPoint/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; LASPoint::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  LASPoint &amp; point\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/las/las_point.hpp</code></p>"},{"location":"blaze/classLayer/","title":"Class Layer","text":"<p>ClassList &gt; Layer</p> <p>Inherits the following classes: QObject</p> <p>Inherited by the following classes: PointLayer</p>"},{"location":"blaze/classLayer/#public-signals","title":"Public Signals","text":"Type Name signal void data_updated"},{"location":"blaze/classLayer/#public-functions","title":"Public Functions","text":"Type Name virtual Extent3D extent () const = 0 virtual std::string name ()  virtual std::string projection () const = 0 virtual ~Layer () = default"},{"location":"blaze/classLayer/#protected-attributes","title":"Protected Attributes","text":"Type Name std::string m_name"},{"location":"blaze/classLayer/#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"blaze/classLayer/#signal-data_updated","title":"signal data_updated","text":"<pre><code>void Layer::data_updated;\n</code></pre>"},{"location":"blaze/classLayer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classLayer/#function-extent","title":"function extent","text":"<pre><code>virtual Extent3D Layer::extent () const = 0\n</code></pre>"},{"location":"blaze/classLayer/#function-name","title":"function name","text":"<pre><code>inline virtual std::string Layer::name () \n</code></pre>"},{"location":"blaze/classLayer/#function-projection","title":"function projection","text":"<pre><code>virtual std::string Layer::projection () const = 0\n</code></pre>"},{"location":"blaze/classLayer/#function-layer","title":"function ~Layer","text":"<pre><code>virtual Layer::~Layer () = default\n</code></pre>"},{"location":"blaze/classLayer/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"blaze/classLayer/#variable-m_name","title":"variable m_name","text":"<pre><code>std::string Layer::m_name;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/layer.hpp</code></p>"},{"location":"blaze/classLayerRenderer/","title":"Class LayerRenderer","text":"<p>ClassList &gt; LayerRenderer</p> <p>Inherits the following classes: QObject</p> <p>Inherited by the following classes: LASLayerRenderer</p>"},{"location":"blaze/classLayerRenderer/#public-signals","title":"Public Signals","text":"Type Name signal void repaint_required"},{"location":"blaze/classLayerRenderer/#public-functions","title":"Public Functions","text":"Type Name void data_update_required ()  virtual void render (const Camera &amp; camera) = 0 virtual ~LayerRenderer () = default"},{"location":"blaze/classLayerRenderer/#public-static-functions","title":"Public Static Functions","text":"Type Name std::unique_ptr&lt; LayerRenderer &gt; create (std::shared_ptr&lt; Layer &gt; layer, const Coordinate3D&lt; double &gt; &amp; offset)"},{"location":"blaze/classLayerRenderer/#protected-attributes","title":"Protected Attributes","text":"Type Name bool m_data_update_required   = <code>[**true**](classCoordinate2D.md)</code>"},{"location":"blaze/classLayerRenderer/#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"blaze/classLayerRenderer/#signal-repaint_required","title":"signal repaint_required","text":"<pre><code>void LayerRenderer::repaint_required;\n</code></pre>"},{"location":"blaze/classLayerRenderer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classLayerRenderer/#function-data_update_required","title":"function data_update_required","text":"<pre><code>inline void LayerRenderer::data_update_required () \n</code></pre>"},{"location":"blaze/classLayerRenderer/#function-render","title":"function render","text":"<pre><code>virtual void LayerRenderer::render (\n    const  Camera &amp; camera\n) = 0\n</code></pre>"},{"location":"blaze/classLayerRenderer/#function-layerrenderer","title":"function ~LayerRenderer","text":"<pre><code>virtual LayerRenderer::~LayerRenderer () = default\n</code></pre>"},{"location":"blaze/classLayerRenderer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/classLayerRenderer/#function-create","title":"function create","text":"<pre><code>static inline std::unique_ptr&lt; LayerRenderer &gt; LayerRenderer::create (\n    std::shared_ptr&lt; Layer &gt; layer,\n    const  Coordinate3D &lt; double &gt; &amp; offset\n) \n</code></pre>"},{"location":"blaze/classLayerRenderer/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"blaze/classLayerRenderer/#variable-m_data_update_required","title":"variable m_data_update_required","text":"<pre><code>bool LayerRenderer::m_data_update_required;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/layer_renderer.hpp</code></p>"},{"location":"blaze/classLineCoord2D/","title":"Class LineCoord2D","text":"<p>template &lt;typename T, typename&gt;</p> <p>ClassList &gt; LineCoord2D</p> <p>Inherits the following classes: Coordinate2D</p> <p>Inherited by the following classes: LineCoord2DCrossing</p>"},{"location":"blaze/classLineCoord2D/#public-functions","title":"Public Functions","text":"Type Name LineCoord2D (T x, T y, Direction2D dir)  LineCoord2D (const Coordinate2D&lt; T &gt; &amp; coord, Direction2D dir)  Direction2D dir () const Coordinate2D&lt; T &gt; end () const Coordinate2D&lt; T &gt; start () const"},{"location":"blaze/classLineCoord2D/#public-functions-inherited-from-coordinate2d","title":"Public Functions inherited from Coordinate2D","text":"<p>See Coordinate2D</p> Type Name Coordinate2D (T x, T y)  Coordinate2D () = default T magnitude () const T magnitude_sqd () const Coordinate2D&lt; double &gt; offset_to_center () const operator Coordinate2D&lt; U &gt; () const Coordinate2D operator+ (Direction2D dir) const Coordinate2D operator+ (Coordinate2D o) const Coordinate2D operator- (Coordinate2D o) const bool operator== (const Coordinate2D &amp; o) const Coordinate2D&lt; size_t &gt; round () const Coordinate2D&lt; double &gt; round_NW (double grid_size) const const T &amp; x () const T &amp; x ()  const T &amp; y () const T &amp; y ()"},{"location":"blaze/classLineCoord2D/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classLineCoord2D/#function-linecoord2d-12","title":"function LineCoord2D [1/2]","text":"<pre><code>inline LineCoord2D::LineCoord2D (\n    T x,\n    T y,\n    Direction2D dir\n) \n</code></pre>"},{"location":"blaze/classLineCoord2D/#function-linecoord2d-22","title":"function LineCoord2D [2/2]","text":"<pre><code>inline LineCoord2D::LineCoord2D (\n    const  Coordinate2D &lt; T &gt; &amp; coord,\n    Direction2D dir\n) \n</code></pre>"},{"location":"blaze/classLineCoord2D/#function-dir","title":"function dir","text":"<pre><code>inline Direction2D LineCoord2D::dir () const\n</code></pre>"},{"location":"blaze/classLineCoord2D/#function-end","title":"function end","text":"<pre><code>inline Coordinate2D &lt; T &gt; LineCoord2D::end () const\n</code></pre>"},{"location":"blaze/classLineCoord2D/#function-start","title":"function start","text":"<pre><code>inline Coordinate2D &lt; T &gt; LineCoord2D::start () const\n</code></pre>"},{"location":"blaze/classLineCoord2D/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classLineCoord2D/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; LineCoord2D::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  LineCoord2D &amp; line_coord\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/coordinate.hpp</code></p>"},{"location":"blaze/classLineCoord2DCrossing/","title":"Class LineCoord2DCrossing","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; LineCoord2DCrossing</p> <p>Inherits the following classes: LineCoord2D</p>"},{"location":"blaze/classLineCoord2DCrossing/#public-functions","title":"Public Functions","text":"Type Name LineCoord2DCrossing (T x, T y, Direction2D dir, Direction2D crossing_dir)  LineCoord2DCrossing (const LineCoord2D&lt; T &gt; &amp; line_coord, Direction2D crossing_dir)  Direction2D crossing_dir () const LineCoord2DCrossing flip () const std::vector&lt; LineCoord2DCrossing &gt; next_points () const"},{"location":"blaze/classLineCoord2DCrossing/#public-functions-inherited-from-linecoord2d","title":"Public Functions inherited from LineCoord2D","text":"<p>See LineCoord2D</p> Type Name LineCoord2D (T x, T y, Direction2D dir)  LineCoord2D (const Coordinate2D&lt; T &gt; &amp; coord, Direction2D dir)  Direction2D dir () const Coordinate2D&lt; T &gt; end () const Coordinate2D&lt; T &gt; start () const"},{"location":"blaze/classLineCoord2DCrossing/#public-functions-inherited-from-coordinate2d","title":"Public Functions inherited from Coordinate2D","text":"<p>See Coordinate2D</p> Type Name Coordinate2D (T x, T y)  Coordinate2D () = default T magnitude () const T magnitude_sqd () const Coordinate2D&lt; double &gt; offset_to_center () const operator Coordinate2D&lt; U &gt; () const Coordinate2D operator+ (Direction2D dir) const Coordinate2D operator+ (Coordinate2D o) const Coordinate2D operator- (Coordinate2D o) const bool operator== (const Coordinate2D &amp; o) const Coordinate2D&lt; size_t &gt; round () const Coordinate2D&lt; double &gt; round_NW (double grid_size) const const T &amp; x () const T &amp; x ()  const T &amp; y () const T &amp; y ()"},{"location":"blaze/classLineCoord2DCrossing/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classLineCoord2DCrossing/#function-linecoord2dcrossing-12","title":"function LineCoord2DCrossing [1/2]","text":"<pre><code>inline LineCoord2DCrossing::LineCoord2DCrossing (\n    T x,\n    T y,\n    Direction2D dir,\n    Direction2D crossing_dir\n) \n</code></pre>"},{"location":"blaze/classLineCoord2DCrossing/#function-linecoord2dcrossing-22","title":"function LineCoord2DCrossing [2/2]","text":"<pre><code>inline LineCoord2DCrossing::LineCoord2DCrossing (\n    const  LineCoord2D &lt; T &gt; &amp; line_coord,\n    Direction2D crossing_dir\n) \n</code></pre>"},{"location":"blaze/classLineCoord2DCrossing/#function-crossing_dir","title":"function crossing_dir","text":"<pre><code>inline Direction2D LineCoord2DCrossing::crossing_dir () const\n</code></pre>"},{"location":"blaze/classLineCoord2DCrossing/#function-flip","title":"function flip","text":"<pre><code>inline LineCoord2DCrossing LineCoord2DCrossing::flip () const\n</code></pre>"},{"location":"blaze/classLineCoord2DCrossing/#function-next_points","title":"function next_points","text":"<pre><code>inline std::vector&lt; LineCoord2DCrossing &gt; LineCoord2DCrossing::next_points () const\n</code></pre>"},{"location":"blaze/classLineCoord2DCrossing/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classLineCoord2DCrossing/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; LineCoord2DCrossing::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  LineCoord2DCrossing &amp; line_coord\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/coordinate.hpp</code></p>"},{"location":"blaze/classLocalDataRetriever/","title":"Class LocalDataRetriever","text":"<p>ClassList &gt; LocalDataRetriever</p>"},{"location":"blaze/classLocalDataRetriever/#public-static-functions","title":"Public Static Functions","text":"Type Name fs::path get_local_data (const fs::path &amp; asset)"},{"location":"blaze/classLocalDataRetriever/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/classLocalDataRetriever/#function-get_local_data","title":"function get_local_data","text":"<pre><code>static fs::path LocalDataRetriever::get_local_data (\n    const fs::path &amp; asset\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/resources.hpp</code></p>"},{"location":"blaze/classMain3DWindow/","title":"Class Main3DWindow","text":"<p>ClassList &gt; Main3DWindow</p> <p>Inherits the following classes: QMainWindow</p>"},{"location":"blaze/classMain3DWindow/#public-functions","title":"Public Functions","text":"Type Name Main3DWindow ()  void add_layer (std::unique_ptr&lt; Layer &gt; layer)  AsyncProgressTracker add_progress_tracker ()  ~Main3DWindow ()"},{"location":"blaze/classMain3DWindow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classMain3DWindow/#function-main3dwindow","title":"function Main3DWindow","text":"<pre><code>Main3DWindow::Main3DWindow () \n</code></pre>"},{"location":"blaze/classMain3DWindow/#function-add_layer","title":"function add_layer","text":"<pre><code>void Main3DWindow::add_layer (\n    std::unique_ptr&lt; Layer &gt; layer\n) \n</code></pre>"},{"location":"blaze/classMain3DWindow/#function-add_progress_tracker","title":"function add_progress_tracker","text":"<pre><code>AsyncProgressTracker Main3DWindow::add_progress_tracker () \n</code></pre>"},{"location":"blaze/classMain3DWindow/#function-main3dwindow_1","title":"function ~Main3DWindow","text":"<pre><code>Main3DWindow::~Main3DWindow () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/main_3d_window.hpp</code></p>"},{"location":"blaze/classMainWindow/","title":"Class MainWindow","text":"<p>ClassList &gt; MainWindow</p> <p>Inherits the following classes: QMainWindow</p>"},{"location":"blaze/classMainWindow/#public-functions","title":"Public Functions","text":"Type Name MainWindow ()  ~MainWindow ()"},{"location":"blaze/classMainWindow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classMainWindow/#function-mainwindow","title":"function MainWindow","text":"<pre><code>MainWindow::MainWindow () \n</code></pre>"},{"location":"blaze/classMainWindow/#function-mainwindow_1","title":"function ~MainWindow","text":"<pre><code>MainWindow::~MainWindow () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/main_window.hpp</code></p>"},{"location":"blaze/classMultiBand/","title":"Class MultiBand","text":"<p>template &lt;typename GridT&gt;</p> <p>ClassList &gt; MultiBand</p>"},{"location":"blaze/classMultiBand/#public-functions","title":"Public Functions","text":"Type Name MultiBand (int n_bands, Args... args)  MultiBand (size_t width, size_t height)  void fill_from (const MultiBand &amp; other, const Coordinate2D&lt; size_t &gt; &amp; top_left={0, 0})  size_t height () const bool in_bounds (const Coordinate2D&lt; size_t &gt; &amp; coord) const GridT &amp; operator[] (size_t i)  const GridT &amp; operator[] (size_t i) const size_t size () const size_t width () const"},{"location":"blaze/classMultiBand/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classMultiBand/#function-multiband-12","title":"function MultiBand [1/2]","text":"<pre><code>template&lt;typename... Args&gt;\ninline MultiBand::MultiBand (\n    int n_bands,\n    Args... args\n) \n</code></pre>"},{"location":"blaze/classMultiBand/#function-multiband-22","title":"function MultiBand [2/2]","text":"<pre><code>inline MultiBand::MultiBand (\n    size_t width,\n    size_t height\n) \n</code></pre>"},{"location":"blaze/classMultiBand/#function-fill_from","title":"function fill_from","text":"<pre><code>inline void MultiBand::fill_from (\n    const  MultiBand &amp; other,\n    const  Coordinate2D &lt; size_t &gt; &amp; top_left={0, 0}\n) \n</code></pre>"},{"location":"blaze/classMultiBand/#function-height","title":"function height","text":"<pre><code>inline size_t MultiBand::height () const\n</code></pre>"},{"location":"blaze/classMultiBand/#function-in_bounds","title":"function in_bounds","text":"<pre><code>inline bool MultiBand::in_bounds (\n    const  Coordinate2D &lt; size_t &gt; &amp; coord\n) const\n</code></pre>"},{"location":"blaze/classMultiBand/#function-operator","title":"function operator[]","text":"<pre><code>inline GridT &amp; MultiBand::operator[] (\n    size_t i\n) \n</code></pre>"},{"location":"blaze/classMultiBand/#function-operator_1","title":"function operator[]","text":"<pre><code>inline const GridT &amp; MultiBand::operator[] (\n    size_t i\n) const\n</code></pre>"},{"location":"blaze/classMultiBand/#function-size","title":"function size","text":"<pre><code>inline size_t MultiBand::size () const\n</code></pre>"},{"location":"blaze/classMultiBand/#function-width","title":"function width","text":"<pre><code>inline size_t MultiBand::width () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/classParentFolderExistsValidator/","title":"Class ParentFolderExistsValidator","text":"<p>ClassList &gt; ParentFolderExistsValidator</p> <p>Inherits the following classes: QValidator</p>"},{"location":"blaze/classParentFolderExistsValidator/#public-functions","title":"Public Functions","text":"Type Name QValidator::State validate (QString &amp; input, int &amp; pos) override const"},{"location":"blaze/classParentFolderExistsValidator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classParentFolderExistsValidator/#function-validate","title":"function validate","text":"<pre><code>inline QValidator::State ParentFolderExistsValidator::validate (\n    QString &amp; input,\n    int &amp; pos\n) override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/config_editor.cpp</code></p>"},{"location":"blaze/classPointLayer/","title":"Class PointLayer","text":"<p>ClassList &gt; PointLayer</p> <p>Inherits the following classes: Layer</p> <p>Inherited by the following classes: LASLayer</p>"},{"location":"blaze/classPointLayer/#public-signals-inherited-from-layer","title":"Public Signals inherited from Layer","text":"<p>See Layer</p> Type Name signal void data_updated"},{"location":"blaze/classPointLayer/#public-functions","title":"Public Functions","text":"Type Name virtual ~PointLayer () = default"},{"location":"blaze/classPointLayer/#public-functions-inherited-from-layer","title":"Public Functions inherited from Layer","text":"<p>See Layer</p> Type Name virtual Extent3D extent () const = 0 virtual std::string name ()  virtual std::string projection () const = 0 virtual ~Layer () = default"},{"location":"blaze/classPointLayer/#protected-attributes-inherited-from-layer","title":"Protected Attributes inherited from Layer","text":"<p>See Layer</p> Type Name std::string m_name"},{"location":"blaze/classPointLayer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classPointLayer/#function-pointlayer","title":"function ~PointLayer","text":"<pre><code>virtual PointLayer::~PointLayer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/layer.hpp</code></p>"},{"location":"blaze/classPolyline/","title":"Class Polyline","text":"<p>ClassList &gt; Polyline</p>"},{"location":"blaze/classPolyline/#public-attributes","title":"Public Attributes","text":"Type Name std::string layer std::string name std::vector&lt; Coordinate2D&lt; double &gt; &gt; vertices"},{"location":"blaze/classPolyline/#public-functions","title":"Public Functions","text":"Type Name void write_to_dxf (std::ofstream &amp; dxfFile) const"},{"location":"blaze/classPolyline/#public-static-functions","title":"Public Static Functions","text":"Type Name Polyline read_from_dxf (std::ifstream &amp; dxfFile)"},{"location":"blaze/classPolyline/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/classPolyline/#variable-layer","title":"variable layer","text":"<pre><code>std::string Polyline::layer;\n</code></pre>"},{"location":"blaze/classPolyline/#variable-name","title":"variable name","text":"<pre><code>std::string Polyline::name;\n</code></pre>"},{"location":"blaze/classPolyline/#variable-vertices","title":"variable vertices","text":"<pre><code>std::vector&lt;Coordinate2D&lt;double&gt; &gt; Polyline::vertices;\n</code></pre>"},{"location":"blaze/classPolyline/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classPolyline/#function-write_to_dxf","title":"function write_to_dxf","text":"<pre><code>inline void Polyline::write_to_dxf (\n    std::ofstream &amp; dxfFile\n) const\n</code></pre>"},{"location":"blaze/classPolyline/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/classPolyline/#function-read_from_dxf","title":"function read_from_dxf","text":"<pre><code>static inline Polyline Polyline::read_from_dxf (\n    std::ifstream &amp; dxfFile\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/dxf/dxf.hpp</code></p>"},{"location":"blaze/structPriorityPoint/","title":"Struct PriorityPoint","text":"<p>ClassList &gt; PriorityPoint</p>"},{"location":"blaze/structPriorityPoint/#public-attributes","title":"Public Attributes","text":"Type Name Coordinate2D&lt; size_t &gt; coord double priority double secondary_priority"},{"location":"blaze/structPriorityPoint/#public-functions","title":"Public Functions","text":"Type Name bool operator&lt; (const PriorityPoint &amp; other) const"},{"location":"blaze/structPriorityPoint/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structPriorityPoint/#variable-coord","title":"variable coord","text":"<pre><code>Coordinate2D&lt;size_t&gt; PriorityPoint::coord;\n</code></pre>"},{"location":"blaze/structPriorityPoint/#variable-priority","title":"variable priority","text":"<pre><code>double PriorityPoint::priority;\n</code></pre>"},{"location":"blaze/structPriorityPoint/#variable-secondary_priority","title":"variable secondary_priority","text":"<pre><code>double PriorityPoint::secondary_priority;\n</code></pre>"},{"location":"blaze/structPriorityPoint/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/structPriorityPoint/#function-operator","title":"function operator&lt;","text":"<pre><code>inline bool PriorityPoint::operator&lt; (\n    const  PriorityPoint &amp; other\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/water/water.cpp</code></p>"},{"location":"blaze/classProgressBar/","title":"Class ProgressBar","text":"<p>ClassList &gt; ProgressBar</p> <p>Inherits the following classes: ProgressObserver</p>"},{"location":"blaze/classProgressBar/#public-functions-inherited-from-progressobserver","title":"Public Functions inherited from ProgressObserver","text":"<p>See ProgressObserver</p> Type Name ProgressTracker * child ()  virtual ~ProgressObserver ()"},{"location":"blaze/classProgressBar/#protected-functions","title":"Protected Functions","text":"Type Name virtual void text_update (const std::string &amp; text, int depth=0) override virtual void update_progress (double progress) override"},{"location":"blaze/classProgressBar/#protected-functions-inherited-from-progressobserver","title":"Protected Functions inherited from ProgressObserver","text":"<p>See ProgressObserver</p> Type Name ProgressObserver ()  virtual void text_update (const std::string &amp; text, int depth=0) = 0 virtual void update_progress (double progress) = 0"},{"location":"blaze/classProgressBar/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"blaze/classProgressBar/#function-text_update","title":"function text_update","text":"<pre><code>virtual void ProgressBar::text_update (\n    const std::string &amp; text,\n    int depth=0\n) override\n</code></pre> <p>Implements ProgressObserver::text_update</p>"},{"location":"blaze/classProgressBar/#function-update_progress","title":"function update_progress","text":"<pre><code>virtual void ProgressBar::update_progress (\n    double progress\n) override\n</code></pre> <p>Implements ProgressObserver::update_progress</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/progress_tracker.hpp</code></p>"},{"location":"blaze/classProgressBox/","title":"Class ProgressBox","text":"<p>ClassList &gt; ProgressBox</p> <p>Inherits the following classes: QDialog,  ProgressObserver</p>"},{"location":"blaze/classProgressBox/#public-signals","title":"Public Signals","text":"Type Name signal void send_progress_bars (std::vector&lt; double &gt; progress)  signal void send_status_text (std::string text, int depth)"},{"location":"blaze/classProgressBox/#public-functions","title":"Public Functions","text":"Type Name ProgressBox (QWidget * parent=nullptr)  void start_task (std::function&lt; void()&gt; task, std::function&lt; void()&gt; on_finish=[] {})  virtual void text_update (const std::string &amp; text, int depth=0) override virtual void update_progress (double proportion) override"},{"location":"blaze/classProgressBox/#public-functions-inherited-from-progressobserver","title":"Public Functions inherited from ProgressObserver","text":"<p>See ProgressObserver</p> Type Name ProgressTracker * child ()  virtual ~ProgressObserver ()"},{"location":"blaze/classProgressBox/#protected-functions-inherited-from-progressobserver","title":"Protected Functions inherited from ProgressObserver","text":"<p>See ProgressObserver</p> Type Name ProgressObserver ()  virtual void text_update (const std::string &amp; text, int depth=0) = 0 virtual void update_progress (double progress) = 0"},{"location":"blaze/classProgressBox/#public-signals-documentation","title":"Public Signals Documentation","text":""},{"location":"blaze/classProgressBox/#signal-send_progress_bars","title":"signal send_progress_bars","text":"<pre><code>void ProgressBox::send_progress_bars;\n</code></pre>"},{"location":"blaze/classProgressBox/#signal-send_status_text","title":"signal send_status_text","text":"<pre><code>void ProgressBox::send_status_text;\n</code></pre>"},{"location":"blaze/classProgressBox/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classProgressBox/#function-progressbox","title":"function ProgressBox","text":"<pre><code>explicit ProgressBox::ProgressBox (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"blaze/classProgressBox/#function-start_task","title":"function start_task","text":"<pre><code>void ProgressBox::start_task (\n    std::function&lt; void ()&gt; task,\n    std::function&lt; void ()&gt; on_finish=[] {}\n) \n</code></pre>"},{"location":"blaze/classProgressBox/#function-text_update","title":"function text_update","text":"<pre><code>virtual void ProgressBox::text_update (\n    const std::string &amp; text,\n    int depth=0\n) override\n</code></pre> <p>Implements ProgressObserver::text_update</p>"},{"location":"blaze/classProgressBox/#function-update_progress","title":"function update_progress","text":"<pre><code>virtual void ProgressBox::update_progress (\n    double proportion\n) override\n</code></pre> <p>Implements ProgressObserver::update_progress</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/progress_box.hpp</code></p>"},{"location":"blaze/classProgressObserver/","title":"Class ProgressObserver","text":"<p>ClassList &gt; ProgressObserver</p> <p>Inherited by the following classes: ProgressBar,  ProgressBox,  ProgressTracker,  ProgressTrackerBar</p>"},{"location":"blaze/classProgressObserver/#public-functions","title":"Public Functions","text":"Type Name ProgressTracker * child ()  virtual ~ProgressObserver ()"},{"location":"blaze/classProgressObserver/#protected-functions","title":"Protected Functions","text":"Type Name ProgressObserver ()  virtual void text_update (const std::string &amp; text, int depth=0) = 0 virtual void update_progress (double progress) = 0"},{"location":"blaze/classProgressObserver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classProgressObserver/#function-child","title":"function child","text":"<pre><code>inline ProgressTracker * ProgressObserver::child () \n</code></pre>"},{"location":"blaze/classProgressObserver/#function-progressobserver","title":"function ~ProgressObserver","text":"<pre><code>virtual ProgressObserver::~ProgressObserver () \n</code></pre>"},{"location":"blaze/classProgressObserver/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"blaze/classProgressObserver/#function-progressobserver_1","title":"function ProgressObserver","text":"<pre><code>inline ProgressObserver::ProgressObserver () \n</code></pre>"},{"location":"blaze/classProgressObserver/#function-text_update","title":"function text_update","text":"<pre><code>virtual void ProgressObserver::text_update (\n    const std::string &amp; text,\n    int depth=0\n) = 0\n</code></pre>"},{"location":"blaze/classProgressObserver/#function-update_progress","title":"function update_progress","text":"<pre><code>virtual void ProgressObserver::update_progress (\n    double progress\n) = 0\n</code></pre>"},{"location":"blaze/classProgressObserver/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classProgressObserver/#friend-progresstracker","title":"friend ProgressTracker","text":"<pre><code>class ProgressObserver::ProgressTracker (\n    ProgressTracker\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/progress_tracker.hpp</code></p>"},{"location":"blaze/classProgressTracker/","title":"Class ProgressTracker","text":"<p>ClassList &gt; ProgressTracker</p> <p>Inherits the following classes: ProgressObserver</p>"},{"location":"blaze/classProgressTracker/#public-functions","title":"Public Functions","text":"Type Name ProgressTracker (ProgressObserver * observer=nullptr)  ProgressTracker (const ProgressTracker &amp; other) = delete ProgressTracker (ProgressTracker &amp;&amp; other)  ProgressTracker &amp; operator= (const ProgressTracker &amp; other) = delete ProgressTracker &amp; operator= (ProgressTracker &amp;&amp; other) = delete double proportion () const void set_proportion (double proportion)  ProgressTracker subtracker (double start, double end)  virtual void text_update (const std::string &amp; text, int depth=0) override virtual ~ProgressTracker ()"},{"location":"blaze/classProgressTracker/#public-functions-inherited-from-progressobserver","title":"Public Functions inherited from ProgressObserver","text":"<p>See ProgressObserver</p> Type Name ProgressTracker * child ()  virtual ~ProgressObserver ()"},{"location":"blaze/classProgressTracker/#protected-functions","title":"Protected Functions","text":"Type Name virtual void update_progress (double progress) override"},{"location":"blaze/classProgressTracker/#protected-functions-inherited-from-progressobserver","title":"Protected Functions inherited from ProgressObserver","text":"<p>See ProgressObserver</p> Type Name ProgressObserver ()  virtual void text_update (const std::string &amp; text, int depth=0) = 0 virtual void update_progress (double progress) = 0"},{"location":"blaze/classProgressTracker/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classProgressTracker/#function-progresstracker-13","title":"function ProgressTracker [1/3]","text":"<pre><code>explicit ProgressTracker::ProgressTracker (\n    ProgressObserver * observer=nullptr\n) \n</code></pre>"},{"location":"blaze/classProgressTracker/#function-progresstracker-23","title":"function ProgressTracker [2/3]","text":"<pre><code>ProgressTracker::ProgressTracker (\n    const  ProgressTracker &amp; other\n) = delete\n</code></pre>"},{"location":"blaze/classProgressTracker/#function-progresstracker-33","title":"function ProgressTracker [3/3]","text":"<pre><code>ProgressTracker::ProgressTracker (\n    ProgressTracker &amp;&amp; other\n) \n</code></pre>"},{"location":"blaze/classProgressTracker/#function-operator","title":"function operator=","text":"<pre><code>ProgressTracker &amp; ProgressTracker::operator= (\n    const  ProgressTracker &amp; other\n) = delete\n</code></pre>"},{"location":"blaze/classProgressTracker/#function-operator_1","title":"function operator=","text":"<pre><code>ProgressTracker &amp; ProgressTracker::operator= (\n    ProgressTracker &amp;&amp; other\n) = delete\n</code></pre>"},{"location":"blaze/classProgressTracker/#function-proportion","title":"function proportion","text":"<pre><code>inline double ProgressTracker::proportion () const\n</code></pre>"},{"location":"blaze/classProgressTracker/#function-set_proportion","title":"function set_proportion","text":"<pre><code>void ProgressTracker::set_proportion (\n    double proportion\n) \n</code></pre>"},{"location":"blaze/classProgressTracker/#function-subtracker","title":"function subtracker","text":"<pre><code>ProgressTracker ProgressTracker::subtracker (\n    double start,\n    double end\n) \n</code></pre>"},{"location":"blaze/classProgressTracker/#function-text_update","title":"function text_update","text":"<pre><code>virtual void ProgressTracker::text_update (\n    const std::string &amp; text,\n    int depth=0\n) override\n</code></pre> <p>Implements ProgressObserver::text_update</p>"},{"location":"blaze/classProgressTracker/#function-progresstracker","title":"function ~ProgressTracker","text":"<pre><code>virtual ProgressTracker::~ProgressTracker () \n</code></pre>"},{"location":"blaze/classProgressTracker/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"blaze/classProgressTracker/#function-update_progress","title":"function update_progress","text":"<pre><code>virtual void ProgressTracker::update_progress (\n    double progress\n) override\n</code></pre> <p>Implements ProgressObserver::update_progress</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/progress_tracker.hpp</code></p>"},{"location":"blaze/classProgressTrackerBar/","title":"Class ProgressTrackerBar","text":"<p>ClassList &gt; ProgressTrackerBar</p> <p>Inherits the following classes: QProgressBar,  ProgressObserver</p>"},{"location":"blaze/classProgressTrackerBar/#public-functions","title":"Public Functions","text":"Type Name ProgressTrackerBar (QWidget * parent)  virtual void text_update (const std::string &amp; text, int depth=0) override AsyncProgressTracker tracker ()  virtual void update_progress (double progress) override"},{"location":"blaze/classProgressTrackerBar/#public-functions-inherited-from-progressobserver","title":"Public Functions inherited from ProgressObserver","text":"<p>See ProgressObserver</p> Type Name ProgressTracker * child ()  virtual ~ProgressObserver ()"},{"location":"blaze/classProgressTrackerBar/#protected-functions-inherited-from-progressobserver","title":"Protected Functions inherited from ProgressObserver","text":"<p>See ProgressObserver</p> Type Name ProgressObserver ()  virtual void text_update (const std::string &amp; text, int depth=0) = 0 virtual void update_progress (double progress) = 0"},{"location":"blaze/classProgressTrackerBar/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classProgressTrackerBar/#function-progresstrackerbar","title":"function ProgressTrackerBar","text":"<pre><code>inline explicit ProgressTrackerBar::ProgressTrackerBar (\n    QWidget * parent\n) \n</code></pre>"},{"location":"blaze/classProgressTrackerBar/#function-text_update","title":"function text_update","text":"<pre><code>inline virtual void ProgressTrackerBar::text_update (\n    const std::string &amp; text,\n    int depth=0\n) override\n</code></pre> <p>Implements ProgressObserver::text_update</p>"},{"location":"blaze/classProgressTrackerBar/#function-tracker","title":"function tracker","text":"<pre><code>inline AsyncProgressTracker ProgressTrackerBar::tracker () \n</code></pre>"},{"location":"blaze/classProgressTrackerBar/#function-update_progress","title":"function update_progress","text":"<pre><code>inline virtual void ProgressTrackerBar::update_progress (\n    double progress\n) override\n</code></pre> <p>Implements ProgressObserver::update_progress</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/main_3d_window.hpp</code></p>"},{"location":"blaze/classRGBColor/","title":"Class RGBColor","text":"<p>ClassList &gt; RGBColor</p> <p>Inherits the following classes: Color</p>"},{"location":"blaze/classRGBColor/#public-functions","title":"Public Functions","text":"Type Name RGBColor (unsigned char r, unsigned char g, unsigned char b, unsigned char a=255)  RGBColor ()  unsigned char getAlpha () const unsigned char getBlue () const unsigned char getGreen () const unsigned char getRed () const const unsigned char &amp; operator[] (size_t index) const unsigned char &amp; operator[] (size_t index)  virtual CMYKColor toCMYK () override const virtual RGBColor toRGB () override const cv::Scalar toScalar () const"},{"location":"blaze/classRGBColor/#public-functions-inherited-from-color","title":"Public Functions inherited from Color","text":"<p>See Color</p> Type Name Color (const Color &amp;) = default Color () = default Color &amp; operator= (const Color &amp;) = default virtual CMYKColor toCMYK () const = 0 virtual RGBColor toRGB () const = 0 virtual ~Color () = default"},{"location":"blaze/classRGBColor/#public-static-functions","title":"Public Static Functions","text":"Type Name RGBColor FromCMYK (const CMYKColor &amp; cmyk)"},{"location":"blaze/classRGBColor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classRGBColor/#function-rgbcolor-12","title":"function RGBColor [1/2]","text":"<pre><code>RGBColor::RGBColor (\n    unsigned  char r,\n    unsigned  char g,\n    unsigned  char b,\n    unsigned  char a=255\n) \n</code></pre>"},{"location":"blaze/classRGBColor/#function-rgbcolor-22","title":"function RGBColor [2/2]","text":"<pre><code>inline RGBColor::RGBColor () \n</code></pre>"},{"location":"blaze/classRGBColor/#function-getalpha","title":"function getAlpha","text":"<pre><code>inline unsigned  char RGBColor::getAlpha () const\n</code></pre>"},{"location":"blaze/classRGBColor/#function-getblue","title":"function getBlue","text":"<pre><code>inline unsigned  char RGBColor::getBlue () const\n</code></pre>"},{"location":"blaze/classRGBColor/#function-getgreen","title":"function getGreen","text":"<pre><code>inline unsigned  char RGBColor::getGreen () const\n</code></pre>"},{"location":"blaze/classRGBColor/#function-getred","title":"function getRed","text":"<pre><code>inline unsigned  char RGBColor::getRed () const\n</code></pre>"},{"location":"blaze/classRGBColor/#function-operator","title":"function operator[]","text":"<pre><code>inline const  unsigned  char &amp; RGBColor::operator[] (\n    size_t index\n) const\n</code></pre>"},{"location":"blaze/classRGBColor/#function-operator_1","title":"function operator[]","text":"<pre><code>inline unsigned  char &amp; RGBColor::operator[] (\n    size_t index\n) \n</code></pre>"},{"location":"blaze/classRGBColor/#function-tocmyk","title":"function toCMYK","text":"<pre><code>virtual CMYKColor RGBColor::toCMYK () override const\n</code></pre> <p>Implements Color::toCMYK</p>"},{"location":"blaze/classRGBColor/#function-torgb","title":"function toRGB","text":"<pre><code>inline virtual RGBColor RGBColor::toRGB () override const\n</code></pre> <p>Implements Color::toRGB</p>"},{"location":"blaze/classRGBColor/#function-toscalar","title":"function toScalar","text":"<pre><code>cv::Scalar RGBColor::toScalar () const\n</code></pre>"},{"location":"blaze/classRGBColor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/classRGBColor/#function-fromcmyk","title":"function FromCMYK","text":"<pre><code>static RGBColor RGBColor::FromCMYK (\n    const  CMYKColor &amp; cmyk\n) \n</code></pre>"},{"location":"blaze/classRGBColor/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classRGBColor/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; RGBColor::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  RGBColor &amp; c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/isom/colors.hpp</code></p>"},{"location":"blaze/structRenderConfig/","title":"Struct RenderConfig","text":"<p>ClassList &gt; RenderConfig</p>"},{"location":"blaze/structRenderConfig/#public-attributes","title":"Public Attributes","text":"Type Name double dpi double scale"},{"location":"blaze/structRenderConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structRenderConfig/#variable-dpi","title":"variable dpi","text":"<pre><code>double RenderConfig::dpi;\n</code></pre>"},{"location":"blaze/structRenderConfig/#variable-scale","title":"variable scale","text":"<pre><code>double RenderConfig::scale;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/structStream/","title":"Struct Stream","text":"<p>ClassList &gt; Stream</p>"},{"location":"blaze/structStream/#public-attributes","title":"Public Attributes","text":"Type Name double catchment std::vector&lt; Coordinate2D&lt; double &gt; &gt; coords"},{"location":"blaze/structStream/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structStream/#variable-catchment","title":"variable catchment","text":"<pre><code>double Stream::catchment;\n</code></pre>"},{"location":"blaze/structStream/#variable-coords","title":"variable coords","text":"<pre><code>std::vector&lt;Coordinate2D&lt;double&gt; &gt; Stream::coords;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/water/water.hpp</code></p>"},{"location":"blaze/classTaskException/","title":"Class TaskException","text":"<p>ClassList &gt; TaskException</p> <p>Inherits the following classes: QException</p>"},{"location":"blaze/classTaskException/#public-functions","title":"Public Functions","text":"Type Name TaskException (const char * what)  QException * clone () const void raise () const virtual const char * what () noexcept const"},{"location":"blaze/classTaskException/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classTaskException/#function-taskexception","title":"function TaskException","text":"<pre><code>inline TaskException::TaskException (\n    const  char * what\n) \n</code></pre>"},{"location":"blaze/classTaskException/#function-clone","title":"function clone","text":"<pre><code>inline QException * TaskException::clone () const\n</code></pre>"},{"location":"blaze/classTaskException/#function-raise","title":"function raise","text":"<pre><code>inline void TaskException::raise () const\n</code></pre>"},{"location":"blaze/classTaskException/#function-what","title":"function what","text":"<pre><code>inline virtual const  char * TaskException::what () noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/progress_box.cpp</code></p>"},{"location":"blaze/classTestGrid/","title":"Class TestGrid","text":"<p>ClassList &gt; TestGrid</p> <p>Inherits the following classes: Geo,  Geo</p>"},{"location":"blaze/classTestGrid/#public-functions","title":"Public Functions","text":"Type Name TestGrid (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp; data)  TestGrid (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp; data)"},{"location":"blaze/classTestGrid/#public-functions-inherited-from-geo","title":"Public Functions inherited from Geo","text":"<p>See Geo</p> Type Name Geo (size_t width, size_t height, GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection)  Geo (GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection, Args... args)  std::unique_ptr&lt; Extent2D &gt; extent () const void fill_from (const Geo&lt; U &gt; &amp; other)  void fill_from (const U &amp; other)  double height_m () const Geo slice (const Extent2D &amp; extent)  double width_m () const"},{"location":"blaze/classTestGrid/#public-functions-inherited-from-geogriddata","title":"Public Functions inherited from GeoGridData","text":"<p>See GeoGridData</p> Type Name GeoGridData (GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection)  double dx () const double dy () const const GeoProjection &amp; projection () const const GeoTransform &amp; transform () const"},{"location":"blaze/classTestGrid/#public-functions-inherited-from-geo_1","title":"Public Functions inherited from Geo","text":"<p>See Geo</p> Type Name Geo (size_t width, size_t height, GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection)  Geo (GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection, Args... args)  std::unique_ptr&lt; Extent2D &gt; extent () const void fill_from (const Geo&lt; U &gt; &amp; other)  void fill_from (const U &amp; other)  double height_m () const Geo slice (const Extent2D &amp; extent)  double width_m () const"},{"location":"blaze/classTestGrid/#public-functions-inherited-from-geogriddata_1","title":"Public Functions inherited from GeoGridData","text":"<p>See GeoGridData</p> Type Name GeoGridData (GeoTransform &amp;&amp; transform, GeoProjection &amp;&amp; projection)  double dx () const double dy () const const GeoProjection &amp; projection () const const GeoTransform &amp; transform () const"},{"location":"blaze/classTestGrid/#public-static-functions-inherited-from-geo","title":"Public Static Functions inherited from Geo","text":"<p>See Geo</p> Type Name Geo&lt; Grid&lt; RGBColor &gt; &gt; FromGeoImg (const GeoImgGrid &amp; grid)  Geo FromPoints (const Geo &amp; grid)"},{"location":"blaze/classTestGrid/#public-static-functions-inherited-from-geo_1","title":"Public Static Functions inherited from Geo","text":"<p>See Geo</p> Type Name Geo&lt; Grid&lt; RGBColor &gt; &gt; FromGeoImg (const GeoImgGrid &amp; grid)  Geo FromPoints (const Geo &amp; grid)"},{"location":"blaze/classTestGrid/#protected-attributes-inherited-from-geogriddata","title":"Protected Attributes inherited from GeoGridData","text":"<p>See GeoGridData</p> Type Name GeoProjection m_projection GeoTransform m_transform"},{"location":"blaze/classTestGrid/#protected-attributes-inherited-from-geogriddata_1","title":"Protected Attributes inherited from GeoGridData","text":"<p>See GeoGridData</p> Type Name GeoProjection m_projection GeoTransform m_transform"},{"location":"blaze/classTestGrid/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classTestGrid/#function-testgrid-12","title":"function TestGrid [1/2]","text":"<pre><code>inline explicit TestGrid::TestGrid (\n    const std::vector&lt; std::vector&lt; double &gt; &gt; &amp; data\n) \n</code></pre>"},{"location":"blaze/classTestGrid/#function-testgrid-12_1","title":"function TestGrid [1/2]","text":"<pre><code>inline explicit TestGrid::TestGrid (\n    const std::vector&lt; std::vector&lt; double &gt; &gt; &amp; data\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/contour/tests/test_contour_gen.cpp</code></p>"},{"location":"blaze/classTimeFunction/","title":"Class TimeFunction","text":"<p>ClassList &gt; TimeFunction</p> <p>Inherits the following classes: Timer</p>"},{"location":"blaze/classTimeFunction/#public-functions","title":"Public Functions","text":"Type Name TimeFunction (const std::string &amp; name, ProgressTracker * progress_tracker=nullptr)  TimeFunction (const std::string &amp; name, std::optional&lt; ProgressTracker &gt; &amp; progress_tracker)  ~TimeFunction ()"},{"location":"blaze/classTimeFunction/#public-functions-inherited-from-timer","title":"Public Functions inherited from Timer","text":"<p>See Timer</p> Type Name Timer ()  std::chrono::duration&lt; double &gt; duration () const"},{"location":"blaze/classTimeFunction/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classTimeFunction/#function-timefunction-12","title":"function TimeFunction [1/2]","text":"<pre><code>inline TimeFunction::TimeFunction (\n    const std::string &amp; name,\n    ProgressTracker * progress_tracker=nullptr\n) \n</code></pre>"},{"location":"blaze/classTimeFunction/#function-timefunction-22","title":"function TimeFunction [2/2]","text":"<pre><code>inline TimeFunction::TimeFunction (\n    const std::string &amp; name,\n    std::optional&lt; ProgressTracker &gt; &amp; progress_tracker\n) \n</code></pre>"},{"location":"blaze/classTimeFunction/#function-timefunction","title":"function ~TimeFunction","text":"<pre><code>inline TimeFunction::~TimeFunction () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/timer.hpp</code></p>"},{"location":"blaze/classTimer/","title":"Class Timer","text":"<p>ClassList &gt; Timer</p> <p>Inherited by the following classes: TimeFunction</p>"},{"location":"blaze/classTimer/#public-functions","title":"Public Functions","text":"Type Name Timer ()  std::chrono::duration&lt; double &gt; duration () const"},{"location":"blaze/classTimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/classTimer/#function-timer","title":"function Timer","text":"<pre><code>inline Timer::Timer () \n</code></pre>"},{"location":"blaze/classTimer/#function-duration","title":"function duration","text":"<pre><code>inline std::chrono::duration&lt; double &gt; Timer::duration () const\n</code></pre>"},{"location":"blaze/classTimer/#friends-documentation","title":"Friends Documentation","text":""},{"location":"blaze/classTimer/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; Timer::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  Timer &amp; timer\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/timer.hpp</code></p>"},{"location":"blaze/namespaceUi/","title":"Namespace Ui","text":"<p>Namespace List &gt; Ui</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/config_editor.hpp</code></p>"},{"location":"blaze/structVegeConfig/","title":"Struct VegeConfig","text":"<p>ClassList &gt; VegeConfig</p>"},{"location":"blaze/structVegeConfig/#public-attributes","title":"Public Attributes","text":"Type Name ColorVariant background_color std::vector&lt; VegeHeightConfig &gt; height_configs"},{"location":"blaze/structVegeConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structVegeConfig/#variable-background_color","title":"variable background_color","text":"<pre><code>ColorVariant VegeConfig::background_color;\n</code></pre>"},{"location":"blaze/structVegeConfig/#variable-height_configs","title":"variable height_configs","text":"<pre><code>std::vector&lt;VegeHeightConfig&gt; VegeConfig::height_configs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/structVegeHeightConfig/","title":"Struct VegeHeightConfig","text":"<p>ClassList &gt; VegeHeightConfig</p>"},{"location":"blaze/structVegeHeightConfig/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; BlockingThresholdColorPair &gt; colors double max_height double min_height std::string name"},{"location":"blaze/structVegeHeightConfig/#public-functions","title":"Public Functions","text":"Type Name std::optional&lt; ColorVariant &gt; pick_from_blocked_proportion (double bp) const"},{"location":"blaze/structVegeHeightConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structVegeHeightConfig/#variable-colors","title":"variable colors","text":"<pre><code>std::vector&lt;BlockingThresholdColorPair&gt; VegeHeightConfig::colors;\n</code></pre>"},{"location":"blaze/structVegeHeightConfig/#variable-max_height","title":"variable max_height","text":"<pre><code>double VegeHeightConfig::max_height;\n</code></pre>"},{"location":"blaze/structVegeHeightConfig/#variable-min_height","title":"variable min_height","text":"<pre><code>double VegeHeightConfig::min_height;\n</code></pre>"},{"location":"blaze/structVegeHeightConfig/#variable-name","title":"variable name","text":"<pre><code>std::string VegeHeightConfig::name;\n</code></pre>"},{"location":"blaze/structVegeHeightConfig/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/structVegeHeightConfig/#function-pick_from_blocked_proportion","title":"function pick_from_blocked_proportion","text":"<pre><code>inline std::optional&lt; ColorVariant &gt; VegeHeightConfig::pick_from_blocked_proportion (\n    double bp\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/structWaterConfig/","title":"Struct WaterConfig","text":"<p>ClassList &gt; WaterConfig</p>"},{"location":"blaze/structWaterConfig/#public-attributes","title":"Public Attributes","text":"Type Name double catchment ColorVariant color double width"},{"location":"blaze/structWaterConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structWaterConfig/#variable-catchment","title":"variable catchment","text":"<pre><code>double WaterConfig::catchment;\n</code></pre>"},{"location":"blaze/structWaterConfig/#variable-color","title":"variable color","text":"<pre><code>ColorVariant WaterConfig::color;\n</code></pre>"},{"location":"blaze/structWaterConfig/#variable-width","title":"variable width","text":"<pre><code>double WaterConfig::width;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/structWaterConfigs/","title":"Struct WaterConfigs","text":"<p>ClassList &gt; WaterConfigs</p>"},{"location":"blaze/structWaterConfigs/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; std::string, WaterConfig &gt; configs"},{"location":"blaze/structWaterConfigs/#public-functions","title":"Public Functions","text":"Type Name const WaterConfig &amp; config_from_catchment (double catchment) const double minimum_catchment () const"},{"location":"blaze/structWaterConfigs/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/structWaterConfigs/#variable-configs","title":"variable configs","text":"<pre><code>std::map&lt;std::string, WaterConfig&gt; WaterConfigs::configs;\n</code></pre>"},{"location":"blaze/structWaterConfigs/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/structWaterConfigs/#function-config_from_catchment","title":"function config_from_catchment","text":"<pre><code>inline const  WaterConfig &amp; WaterConfigs::config_from_catchment (\n    double catchment\n) const\n</code></pre>"},{"location":"blaze/structWaterConfigs/#function-minimum_catchment","title":"function minimum_catchment","text":"<pre><code>inline double WaterConfigs::minimum_catchment () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/namespacecv/","title":"Namespace cv","text":"<p>Namespace List &gt; cv</p>"},{"location":"blaze/namespacecv/#classes","title":"Classes","text":"Type Name class Scalar_ &lt;typename T&gt;"},{"location":"blaze/namespacecv/#public-types","title":"Public Types","text":"Type Name typedef Scalar_&lt; double &gt; Scalar"},{"location":"blaze/namespacecv/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/namespacecv/#typedef-scalar","title":"typedef Scalar","text":"<pre><code>typedef Scalar_&lt; double &gt; cv::Scalar;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/img_grid.hpp</code></p>"},{"location":"blaze/classcv_1_1Scalar__/","title":"Class cv::Scalar_","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; cv &gt; Scalar_</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/isom/colors.hpp</code></p>"},{"location":"blaze/structis__specialization/","title":"Struct is_specialization","text":"<p>template &lt;typename Test, template&lt; typename... &gt; class Ref&gt;</p> <p>ClassList &gt; is_specialization</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/structis__specialization_3_01Ref_3_01Args_8_8_8_01_4_00_01Ref_01_4/","title":"Struct is_specialization&lt; Ref&lt; Args... &gt;, Ref &gt;","text":"<p>template &lt;template&lt; typename... &gt; class Ref, typename... Args&gt;</p> <p>ClassList &gt; is_specialization&lt; Ref&lt; Args... &gt;, Ref &gt;</p> <p>Inherits the following classes: std::true_type</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/structis__std__optional/","title":"Struct is_std_optional","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; is_std_optional</p> <p>Inherits the following classes: std::false_type</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/tif/tif.cpp</code></p>"},{"location":"blaze/structis__std__optional_3_01std_1_1optional_3_01T_01_4_01_4/","title":"Struct is_std_optional&lt; std::optional&lt; T &gt; &gt;","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; is_std_optional&lt; std::optional&lt; T &gt; &gt;</p> <p>Inherits the following classes: std::true_type</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/tif/tif.cpp</code></p>"},{"location":"blaze/namespacenlohmann/","title":"Namespace nlohmann","text":"<p>Namespace List &gt; nlohmann</p>"},{"location":"blaze/namespacenlohmann/#classes","title":"Classes","text":"Type Name struct adl_serializer&lt; BlockingThresholdColorPair &gt; &lt;&gt; struct adl_serializer&lt; BuildingsConfig &gt; &lt;&gt; struct adl_serializer&lt; CMYKColor &gt; &lt;&gt; struct adl_serializer&lt; CanopyConfig &gt; &lt;&gt; struct adl_serializer&lt; ColorVariant &gt; &lt;&gt; struct adl_serializer&lt; ContourConfig &gt; &lt;&gt; struct adl_serializer&lt; ContourConfigs &gt; &lt;&gt; struct adl_serializer&lt; GridConfig &gt; &lt;&gt; struct adl_serializer&lt; GroundConfig &gt; &lt;&gt; struct adl_serializer&lt; RGBColor &gt; &lt;&gt; struct adl_serializer&lt; RenderConfig &gt; &lt;&gt; struct adl_serializer&lt; VegeConfig &gt; &lt;&gt; struct adl_serializer&lt; VegeHeightConfig &gt; &lt;&gt; struct adl_serializer&lt; WaterConfig &gt; &lt;&gt; struct adl_serializer&lt; WaterConfigs &gt; &lt;&gt;"},{"location":"blaze/namespacenlohmann/#public-functions","title":"Public Functions","text":"Type Name SERIALIZE_ENUM_STRICT (ProcessingStep, { {ProcessingStep::Tiles, \"tiles\"}, {ProcessingStep::Combine, \"combine\"}, })"},{"location":"blaze/namespacenlohmann/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/namespacenlohmann/#function-serialize_enum_strict","title":"function SERIALIZE_ENUM_STRICT","text":"<pre><code>nlohmann::SERIALIZE_ENUM_STRICT (\n    ProcessingStep,\n    { {ProcessingStep::Tiles, \"tiles\"}, {ProcessingStep::Combine, \"combine\"}, }\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BlockingThresholdColorPair_01_4/","title":"Struct nlohmann::adl_serializer&lt; BlockingThresholdColorPair &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; BlockingThresholdColorPair &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BlockingThresholdColorPair_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name BlockingThresholdColorPair from_json (const json &amp; j)  void to_json (json &amp; j, BlockingThresholdColorPair btc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BlockingThresholdColorPair_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BlockingThresholdColorPair_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline BlockingThresholdColorPair nlohmann::adl_serializer&lt; BlockingThresholdColorPair &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BlockingThresholdColorPair_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; BlockingThresholdColorPair &gt;::to_json (\n    json &amp; j,\n    BlockingThresholdColorPair btc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BuildingsConfig_01_4/","title":"Struct nlohmann::adl_serializer&lt; BuildingsConfig &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; BuildingsConfig &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BuildingsConfig_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name BuildingsConfig from_json (const json &amp; j)  void to_json (json &amp; j, BuildingsConfig bc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BuildingsConfig_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BuildingsConfig_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline BuildingsConfig nlohmann::adl_serializer&lt; BuildingsConfig &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01BuildingsConfig_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; BuildingsConfig &gt;::to_json (\n    json &amp; j,\n    BuildingsConfig bc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CMYKColor_01_4/","title":"Struct nlohmann::adl_serializer&lt; CMYKColor &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; CMYKColor &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CMYKColor_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name CMYKColor from_json (const json &amp; j)  void to_json (json &amp; j, CMYKColor c)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CMYKColor_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CMYKColor_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline CMYKColor nlohmann::adl_serializer&lt; CMYKColor &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CMYKColor_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; CMYKColor &gt;::to_json (\n    json &amp; j,\n    CMYKColor c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CanopyConfig_01_4/","title":"Struct nlohmann::adl_serializer&lt; CanopyConfig &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; CanopyConfig &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CanopyConfig_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name CanopyConfig from_json (const json &amp; j)  void to_json (json &amp; j, CanopyConfig vc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CanopyConfig_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CanopyConfig_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline CanopyConfig nlohmann::adl_serializer&lt; CanopyConfig &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01CanopyConfig_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; CanopyConfig &gt;::to_json (\n    json &amp; j,\n    CanopyConfig vc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ColorVariant_01_4/","title":"Struct nlohmann::adl_serializer&lt; ColorVariant &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; ColorVariant &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ColorVariant_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name ColorVariant from_json (const json &amp; j)  void to_json (json &amp; j, ColorVariant cv)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ColorVariant_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ColorVariant_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline ColorVariant nlohmann::adl_serializer&lt; ColorVariant &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ColorVariant_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; ColorVariant &gt;::to_json (\n    json &amp; j,\n    ColorVariant cv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfig_01_4/","title":"Struct nlohmann::adl_serializer&lt; ContourConfig &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; ContourConfig &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfig_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name ContourConfig from_json (const json &amp; j)  void to_json (json &amp; j, ContourConfig cc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfig_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfig_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline ContourConfig nlohmann::adl_serializer&lt; ContourConfig &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfig_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; ContourConfig &gt;::to_json (\n    json &amp; j,\n    ContourConfig cc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfigs_01_4/","title":"Struct nlohmann::adl_serializer&lt; ContourConfigs &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; ContourConfigs &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfigs_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name ContourConfigs from_json (const json &amp; j)  void to_json (json &amp; j, ContourConfigs cc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfigs_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfigs_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline ContourConfigs nlohmann::adl_serializer&lt; ContourConfigs &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01ContourConfigs_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; ContourConfigs &gt;::to_json (\n    json &amp; j,\n    ContourConfigs cc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GridConfig_01_4/","title":"Struct nlohmann::adl_serializer&lt; GridConfig &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; GridConfig &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GridConfig_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name GridConfig from_json (const json &amp; j)  void to_json (json &amp; j, GridConfig gc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GridConfig_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GridConfig_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline GridConfig nlohmann::adl_serializer&lt; GridConfig &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GridConfig_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; GridConfig &gt;::to_json (\n    json &amp; j,\n    GridConfig gc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GroundConfig_01_4/","title":"Struct nlohmann::adl_serializer&lt; GroundConfig &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; GroundConfig &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GroundConfig_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name GroundConfig from_json (const json &amp; j)  void to_json (json &amp; j, GroundConfig gc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GroundConfig_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GroundConfig_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline GroundConfig nlohmann::adl_serializer&lt; GroundConfig &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01GroundConfig_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; GroundConfig &gt;::to_json (\n    json &amp; j,\n    GroundConfig gc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RGBColor_01_4/","title":"Struct nlohmann::adl_serializer&lt; RGBColor &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; RGBColor &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RGBColor_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name RGBColor from_json (const json &amp; j)  void to_json (json &amp; j, RGBColor c)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RGBColor_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RGBColor_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline RGBColor nlohmann::adl_serializer&lt; RGBColor &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RGBColor_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; RGBColor &gt;::to_json (\n    json &amp; j,\n    RGBColor c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RenderConfig_01_4/","title":"Struct nlohmann::adl_serializer&lt; RenderConfig &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; RenderConfig &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RenderConfig_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name RenderConfig from_json (const json &amp; j)  void to_json (json &amp; j, RenderConfig rc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RenderConfig_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RenderConfig_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline RenderConfig nlohmann::adl_serializer&lt; RenderConfig &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01RenderConfig_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; RenderConfig &gt;::to_json (\n    json &amp; j,\n    RenderConfig rc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeConfig_01_4/","title":"Struct nlohmann::adl_serializer&lt; VegeConfig &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; VegeConfig &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeConfig_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name VegeConfig from_json (const json &amp; j)  void to_json (json &amp; j, VegeConfig vc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeConfig_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeConfig_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline VegeConfig nlohmann::adl_serializer&lt; VegeConfig &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeConfig_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; VegeConfig &gt;::to_json (\n    json &amp; j,\n    VegeConfig vc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeHeightConfig_01_4/","title":"Struct nlohmann::adl_serializer&lt; VegeHeightConfig &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; VegeHeightConfig &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeHeightConfig_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name VegeHeightConfig from_json (const json &amp; j)  void to_json (json &amp; j, VegeHeightConfig vhc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeHeightConfig_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeHeightConfig_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline VegeHeightConfig nlohmann::adl_serializer&lt; VegeHeightConfig &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01VegeHeightConfig_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; VegeHeightConfig &gt;::to_json (\n    json &amp; j,\n    VegeHeightConfig vhc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfig_01_4/","title":"Struct nlohmann::adl_serializer&lt; WaterConfig &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; WaterConfig &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfig_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name WaterConfig from_json (const json &amp; j)  void to_json (json &amp; j, WaterConfig cc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfig_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfig_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline WaterConfig nlohmann::adl_serializer&lt; WaterConfig &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfig_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; WaterConfig &gt;::to_json (\n    json &amp; j,\n    WaterConfig cc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfigs_01_4/","title":"Struct nlohmann::adl_serializer&lt; WaterConfigs &gt;","text":"<p>template &lt;&gt;</p> <p>ClassList &gt; nlohmann &gt; adl_serializer&lt; WaterConfigs &gt;</p>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfigs_01_4/#public-static-functions","title":"Public Static Functions","text":"Type Name WaterConfigs from_json (const json &amp; j)  void to_json (json &amp; j, WaterConfigs cc)"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfigs_01_4/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfigs_01_4/#function-from_json","title":"function from_json","text":"<pre><code>static inline WaterConfigs nlohmann::adl_serializer&lt; WaterConfigs &gt;::from_json (\n    const json &amp; j\n) \n</code></pre>"},{"location":"blaze/structnlohmann_1_1adl__serializer_3_01WaterConfigs_01_4/#function-to_json","title":"function to_json","text":"<pre><code>static inline void nlohmann::adl_serializer&lt; WaterConfigs &gt;::to_json (\n    json &amp; j,\n    WaterConfigs cc\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p>"},{"location":"blaze/namespacestd/#public-types","title":"Public Types","text":"Type Name typedef std::experimental::source_location source_location"},{"location":"blaze/namespacestd/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/namespacestd/#typedef-source_location","title":"typedef source_location","text":"<pre><code>using std::source_location = typedef std::experimental::source_location;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/assert/assert.hpp</code></p>"},{"location":"blaze/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir /home/runner/work/Blaze/Blaze/src","text":"<p>FileList &gt; src</p>"},{"location":"blaze/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file blaze.cpp file precompiled_headers.hpp file process.cpp file process.hpp file run.cpp file run.hpp file unit_tests.cpp"},{"location":"blaze/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","title":"Directories","text":"Type Name dir gui dir lib dir methods <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/</code></p>"},{"location":"blaze/dir_99d0482cf009f9d97a0877749b817f19/","title":"Dir /home/runner/work/Blaze/Blaze/src/gui","text":"<p>FileList &gt; gui</p>"},{"location":"blaze/dir_99d0482cf009f9d97a0877749b817f19/#files","title":"Files","text":"Type Name file camera.hpp file config_editor.cpp file config_editor.hpp file gl_widget.cpp file gl_widget.hpp file layer.hpp file layer_renderer.hpp file main.cpp file main_3d.cpp file main_3d_window.cpp file main_3d_window.hpp file main_window.cpp file main_window.hpp file progress_box.cpp file progress_box.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/</code></p>"},{"location":"blaze/camera_8hpp/","title":"File camera.hpp","text":"<p>FileList &gt; gui &gt; camera.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QMatrix4x4&gt;</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> </ul>"},{"location":"blaze/camera_8hpp/#classes","title":"Classes","text":"Type Name class Camera"},{"location":"blaze/camera_8hpp/#public-functions","title":"Public Functions","text":"Type Name double deg2rad (double deg)  double rad2deg (double rad)"},{"location":"blaze/camera_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/camera_8hpp/#function-deg2rad","title":"function deg2rad","text":"<pre><code>inline double deg2rad (\n    double deg\n) \n</code></pre>"},{"location":"blaze/camera_8hpp/#function-rad2deg","title":"function rad2deg","text":"<pre><code>inline double rad2deg (\n    double rad\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/camera.hpp</code></p>"},{"location":"blaze/camera_8hpp_source/","title":"File camera.hpp","text":"<p>File List &gt; gui &gt; camera.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;QMatrix4x4&gt;\n\n#include \"utilities/coordinate.hpp\"\n\ninline double deg2rad(double deg) { return deg * M_PI / 180.0f; }\n\ninline double rad2deg(double rad) { return rad * 180.0f / M_PI; }\n\nclass Camera {\n  QVector3D m_position;\n  QVector3D m_direction;\n  QVector3D m_up;\n\n  Coordinate3D&lt;double&gt; m_world_offset;\n\n  int m_width;\n  int m_height;\n\n  double m_fov = 45.0f;\n\n public:\n  Camera(int width, int height)\n      : m_position(1, 1, 1),\n        m_direction(-1, -1, -1),\n        m_up(0, 0, 1),\n        m_width(width),\n        m_height(height) {}\n\n  Camera(const QVector3D&amp; position, const QVector3D&amp; direction, const QVector3D&amp; up)\n      : m_position(position), m_direction(direction), m_up(up) {}\n\n  void move(const QVector3D&amp; direction) { m_position += direction; }\n  void move_towards(const QVector3D&amp; world_pos, double distance, bool shrink_direction = false) {\n    QVector3D direction = world_pos - m_position;\n    m_position += direction.normalized() * distance;\n    if (shrink_direction) {\n      if (distance &lt; 0 || (m_direction.length() &gt; 1 &amp;&amp; m_direction.length() &gt; distance))\n        m_direction -= m_direction.normalized() * distance;\n      else\n        m_direction = m_direction.normalized();\n    }\n  }\n\n  const Coordinate3D&lt;double&gt;&amp; world_offset() const { return m_world_offset; }\n  Coordinate3D&lt;double&gt;&amp; world_offset() { return m_world_offset; }\n\n  void set_screen_size(int width, int height) {\n    m_width = width;\n    m_height = height;\n  }\n\n  void reset_to_origin() {\n    m_position = QVector3D(1, 1, 1);\n    m_direction = QVector3D(-1, -1, -1);\n    m_up = QVector3D(0, 0, 1);\n  }\n\n  QVector3D view_right() const { return QVector3D::crossProduct(m_up, m_direction).normalized(); }\n  QVector3D view_up() const {\n    return QVector3D::crossProduct(m_direction, view_right()).normalized();\n  }\n  QVector3D planar_direction() const {\n    return QVector3D(m_direction.x(), m_direction.y(), 0).normalized();\n  }\n\n  void pan(double dx, double dy) {\n    m_position += (view_right() * dx + view_up() * dy) * m_direction.length();\n  }\n\n  void fly(double dx, double dy, double dz) {\n    m_position += (planar_direction() * dx + view_right() * dy + m_up * dz) * m_direction.length();\n  }\n\n  void zoom_to_fit(const Extent3D&amp; extent) {\n    // Coordinate3D&lt;double&gt; center = extent.center();\n    double max_extent = extent.max_extent();\n    QVector3D qcenter(extent.maxx + extent.minx, extent.maxy + extent.miny,\n                      extent.maxz + extent.minz);\n    qcenter /= 2;\n    m_position = qcenter - 10 * m_direction.normalized() * max_extent;\n\n    QMatrix4x4 proj = proj_matrix();\n\n    float zoom_out_amount = 0.0f;\n    for (size_t i = 0; i &lt; 2; i++) {\n      for (size_t j = 0; j &lt; 2; j++) {\n        for (size_t k = 0; k &lt; 2; k++) {\n          QVector3D corner(i == 0 ? 0 : extent.maxx - extent.minx,\n                           j == 0 ? 0 : extent.maxy - extent.miny,\n                           k == 0 ? 0 : extent.maxz - extent.minz);\n          QVector3D screen_pos = proj.map(corner);\n          zoom_out_amount = std::max(zoom_out_amount,\n                                     std::max(std::abs(screen_pos.x()), std::abs(screen_pos.y())));\n        }\n      }\n    }\n\n    m_position = qcenter - m_direction.normalized() * 10 * max_extent * zoom_out_amount;\n    m_direction = qcenter - m_position;\n    std::cout &lt;&lt; \"New position: \" &lt;&lt; m_position.x() &lt;&lt; \" \" &lt;&lt; m_position.y() &lt;&lt; \" \"\n              &lt;&lt; m_position.z() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"New direction: \" &lt;&lt; m_direction.x() &lt;&lt; \" \" &lt;&lt; m_direction.y() &lt;&lt; \" \"\n              &lt;&lt; m_direction.z() &lt;&lt; std::endl;\n  }\n\n  void rotate_view(double dx, double dy) { rotate_around_center(dx, dy, m_position); }\n\n  double current_altitude_angle() const {\n    return std::asin(m_direction.z() / m_direction.length());\n  }\n\n  double projection_scale() const { return m_height / (2.0f * std::tan(deg2rad(m_fov) / 2)); }\n\n private:\n  double bound_rotation(double current_angle, double angle, double min_angle, double max_angle) {\n    std::cout &lt;&lt; \"Bounding rotation: \" &lt;&lt; current_angle &lt;&lt; \" \" &lt;&lt; angle &lt;&lt; \" \" &lt;&lt; min_angle &lt;&lt; \" \"\n              &lt;&lt; max_angle &lt;&lt; std::endl;\n    if (current_angle + angle &gt; max_angle) {\n      angle = max_angle - current_angle;\n    } else if (current_angle + angle &lt; min_angle) {\n      angle = min_angle - current_angle;\n    }\n    return angle;\n  }\n\n public:\n  void rotate_around_center(double dx, double dy,\n                            const std::optional&lt;QVector3D&gt;&amp; center = std::nullopt) {\n    QVector3D cor = center.value_or(m_position + m_direction);\n\n    QMatrix4x4 rotation;\n    rotation.rotate(-dx, m_up);\n    double angle_to_rotate =\n        bound_rotation(rad2deg(current_altitude_angle()), -dy, -90 + 1e-2, 90 - 1e-2);\n    rotation.rotate(-angle_to_rotate, view_right());\n    m_direction = rotation.map(m_direction);\n    m_position = cor - (m_position - cor).length() * m_direction.normalized();\n  }\n\n  QMatrix4x4 proj_matrix() const {\n    QMatrix4x4 proj;\n    proj.perspective(m_fov, (double)m_width / m_height, 1e-2f, 1e5f);\n    proj.lookAt(m_position, m_position + m_direction, m_up);\n    return proj;\n  }\n\n  QVector3D unproject(const QPointF&amp; screen_pos) const {\n    QVector3D screen(screen_pos.x(), m_height - screen_pos.y(), 0);\n    return screen.unproject(proj_matrix(), QMatrix4x4(), QRect(0, 0, m_width, m_height));\n  }\n\n  const QVector3D&amp; position() const { return m_position; }\n  const QVector3D&amp; direction() const { return m_direction; }\n  const QVector3D&amp; up() const { return m_up; }\n};\n</code></pre>"},{"location":"blaze/config__editor_8cpp/","title":"File config_editor.cpp","text":"<p>FileList &gt; gui &gt; config_editor.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"config_editor.hpp\"</code></li> <li><code>#include &lt;qdebug.h&gt;</code></li> <li><code>#include &lt;QColorDialog&gt;</code></li> <li><code>#include &lt;QDoubleValidator&gt;</code></li> <li><code>#include &lt;QFileDialog&gt;</code></li> <li><code>#include &lt;QIntValidator&gt;</code></li> <li><code>#include &lt;QListWidget&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> <li><code>#include &lt;QSpinBox&gt;</code></li> <li><code>#include &lt;QTableWidget&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include \"assert/assert.hpp\"</code></li> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"printing/to_string.hpp\"</code></li> <li><code>#include \"ui_config_editor.h\"</code></li> </ul>"},{"location":"blaze/config__editor_8cpp/#classes","title":"Classes","text":"Type Name class ParentFolderExistsValidator"},{"location":"blaze/config__editor_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool color_equals (const ColorVariant &amp; v1, const ColorVariant &amp; v2)  QIcon create_color_icon (const ColorVariant &amp; color)  QString get_color_name (const ColorVariant &amp; color)  bool validated (T * box)"},{"location":"blaze/config__editor_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/config__editor_8cpp/#function-color_equals","title":"function color_equals","text":"<pre><code>bool color_equals (\n    const ColorVariant &amp; v1,\n    const ColorVariant &amp; v2\n) \n</code></pre>"},{"location":"blaze/config__editor_8cpp/#function-create_color_icon","title":"function create_color_icon","text":"<pre><code>QIcon create_color_icon (\n    const ColorVariant &amp; color\n) \n</code></pre>"},{"location":"blaze/config__editor_8cpp/#function-get_color_name","title":"function get_color_name","text":"<pre><code>QString get_color_name (\n    const ColorVariant &amp; color\n) \n</code></pre>"},{"location":"blaze/config__editor_8cpp/#function-validated","title":"function validated","text":"<pre><code>template&lt;typename T&gt;\nbool validated (\n    T * box\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/config_editor.cpp</code></p>"},{"location":"blaze/config__editor_8cpp_source/","title":"File config_editor.cpp","text":"<p>File List &gt; gui &gt; config_editor.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"config_editor.hpp\"\n\n#include &lt;qdebug.h&gt;\n\n#include &lt;QColorDialog&gt;\n#include &lt;QDoubleValidator&gt;\n#include &lt;QFileDialog&gt;\n#include &lt;QIntValidator&gt;\n#include &lt;QListWidget&gt;\n#include &lt;QPainter&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QSpinBox&gt;\n#include &lt;QTableWidget&gt;\n#include &lt;filesystem&gt;\n\n#include \"assert/assert.hpp\"\n#include \"config_input/config_input.hpp\"\n#include \"printing/to_string.hpp\"\n#include \"ui_config_editor.h\"\n\nclass ParentFolderExistsValidator : public QValidator {\n public:\n  QValidator::State validate(QString&amp; input, [[maybe_unused]] int&amp; pos) const override {\n    if (fs::exists(fs::path(input.toStdString()).parent_path())) {\n      return QValidator::Acceptable;\n    }\n    return QValidator::Invalid;\n  }\n};\n\ntemplate &lt;typename T&gt;\nbool validated(T* box) {\n  QString text;\n  if constexpr (std::is_same_v&lt;T, QLineEdit&gt;) {\n    text = box-&gt;text();\n  } else if constexpr (std::is_same_v&lt;T, QComboBox&gt;) {\n    text = box-&gt;currentText();\n  }\n  int pos = 0;\n  QValidator::State state = box-&gt;validator()-&gt;validate(text, pos);\n  switch (state) {\n    case QValidator::Acceptable:\n      box-&gt;setStyleSheet(\"\");\n      return true;\n    case QValidator::Intermediate:\n    case QValidator::Invalid:\n      box-&gt;setStyleSheet(\"QComboBox { border: 2px solid red; }\");\n      return false;\n  }\n  unreachable();\n}\n\nbool color_equals(const ColorVariant&amp; v1, const ColorVariant&amp; v2) {\n  if (v1.index() != v2.index()) return false;\n  if (std::holds_alternative&lt;RGBColor&gt;(v1)) {\n    const auto&amp; c1 = std::get&lt;RGBColor&gt;(v1);\n    const auto&amp; c2 = std::get&lt;RGBColor&gt;(v2);\n    return c1.getRed() == c2.getRed() &amp;&amp; c1.getGreen() == c2.getGreen() &amp;&amp;\n           c1.getBlue() == c2.getBlue() &amp;&amp; c1.getAlpha() == c2.getAlpha();\n  } else {\n    const auto&amp; c1 = std::get&lt;CMYKColor&gt;(v1);\n    const auto&amp; c2 = std::get&lt;CMYKColor&gt;(v2);\n    return c1.getCyan() == c2.getCyan() &amp;&amp; c1.getMagenta() == c2.getMagenta() &amp;&amp;\n           c1.getYellow() == c2.getYellow() &amp;&amp; c1.getBlack() == c2.getBlack();\n  }\n}\n\nQString get_color_name(const ColorVariant&amp; color) {\n  for (const auto&amp; [name, map_color] : COLOR_MAP) {\n    if (color_equals(color, map_color)) {\n      return QString::fromStdString(name);\n    }\n  }\n  return \"\";\n}\n\nQIcon create_color_icon(const ColorVariant&amp; color) {\n  QPixmap pixmap(16, 16);\n  pixmap.fill(Qt::transparent);\n  QPainter painter(&amp;pixmap);\n\n  RGBColor rgb = to_rgb(color);\n  QColor qcolor(rgb.getRed(), rgb.getGreen(), rgb.getBlue(), rgb.getAlpha());\n\n  painter.setBrush(qcolor);\n  painter.setPen(Qt::black);\n  painter.drawRect(0, 0, 15, 15);\n\n  return QIcon(pixmap);\n}\n\nbool ConfigEditor::is_valid() const {\n  bool all_las_files_exist = std::all_of(\n      m_config-&gt;las_files.begin(), m_config-&gt;las_files.end(),\n      [this](const fs::path&amp; las_file) { return m_config-&gt;get_las_files(las_file).size(); });\n  return validated(ui-&gt;scale_dropdown) &amp;&amp; validated(ui-&gt;dpi_dropdown) &amp;&amp;\n         validated(ui-&gt;out_dir_line_edit) &amp;&amp; !m_config-&gt;processing_steps.empty() &amp;&amp;\n         !m_config-&gt;las_files.empty() &amp;&amp; all_las_files_exist;\n}\n\nConfigEditor::ConfigEditor(QWidget* parent)\n    : QWidget(parent),\n      ui(new Ui::ConfigEditor),\n      m_config(std::make_unique&lt;Config&gt;(Config::Default())) {\n  ui-&gt;setupUi(this);\n\n  ui-&gt;scale_dropdown-&gt;setValidator(new QDoubleValidator(100.0, 100000.0, 2, this));\n  connect(ui-&gt;scale_dropdown, &amp;QComboBox::currentTextChanged, [this](const QString&amp; text) {\n    if (validated(ui-&gt;scale_dropdown)) {\n      m_config-&gt;render.scale = std::stod(text.toStdString());\n    }\n    config_changed();\n  });\n\n  ui-&gt;out_dir_line_edit-&gt;setValidator(new ParentFolderExistsValidator());\n  connect(ui-&gt;out_dir_line_edit, &amp;QLineEdit::textChanged, [this](const QString&amp; text) {\n    if (validated(ui-&gt;out_dir_line_edit)) {\n      m_config-&gt;set_output_directory(text.toStdString());\n      config_changed();\n    }\n  });\n\n  ui-&gt;dpi_dropdown-&gt;setValidator(new QDoubleValidator(1.0, 2400.0, 2, this));\n  connect(ui-&gt;dpi_dropdown, &amp;QComboBox::currentTextChanged, [this](const QString&amp; text) {\n    if (validated(ui-&gt;dpi_dropdown)) {\n      m_config-&gt;render.dpi = std::stod(text.toStdString());\n    }\n    config_changed();\n  });\n\n  connect(ui-&gt;add_las_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::add_las_file);\n  connect(ui-&gt;add_las_folder_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::add_las_folder);\n  connect(ui-&gt;remove_las_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::remove_las_file);\n\n  connect(ui-&gt;out_dir_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::open_output_directory);\n\n  for (const auto&amp; [checkbox, step] : std::vector&lt;std::pair&lt;QCheckBox*, ProcessingStep&gt;&gt;{\n           {ui-&gt;process_tiles_checkbox, ProcessingStep::Tiles},\n           {ui-&gt;combine_tiles_checkbox, ProcessingStep::Combine}}) {\n    ProcessingStep ps = step;\n    connect(checkbox, &amp;QCheckBox::stateChanged, [this, ps](int state) {\n      if (state == Qt::Checked) {\n        m_config-&gt;processing_steps.insert(ps);\n      } else {\n        m_config-&gt;processing_steps.erase(ps);\n      }\n      config_changed();\n    });\n  }\n\n  // General Tab\n  ui-&gt;grid_bin_resolution-&gt;setValidator(new QDoubleValidator(0.0, 1000.0, 3, this));\n  ui-&gt;ground_outlier_removal-&gt;setValidator(new QDoubleValidator(0.0, 1000.0, 3, this));\n  ui-&gt;border_width-&gt;setValidator(new QDoubleValidator(0.0, 10000.0, 2, this));\n\n  auto connect_general = [this](QWidget* widget) {\n    if (auto* le = qobject_cast&lt;QLineEdit*&gt;(widget)) {\n      connect(le, &amp;QLineEdit::textChanged, this, &amp;ConfigEditor::update_general_from_ui);\n    } else if (auto* sb = qobject_cast&lt;QSpinBox*&gt;(widget)) {\n      connect(sb, QOverload&lt;int&gt;::of(&amp;QSpinBox::valueChanged), this,\n              &amp;ConfigEditor::update_general_from_ui);\n    }\n  };\n  connect_general(ui-&gt;grid_bin_resolution);\n  connect_general(ui-&gt;grid_downsample_factor);\n  connect_general(ui-&gt;ground_outlier_removal);\n  connect_general(ui-&gt;ground_min_intensity);\n  connect_general(ui-&gt;ground_max_intensity);\n  connect(ui-&gt;buildings_color, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this,\n          &amp;ConfigEditor::update_general_from_ui);\n  connect_general(ui-&gt;border_width);\n\n  // Contours Tab\n  connect(ui-&gt;contours_list_widget, &amp;QListWidget::itemSelectionChanged, this,\n          &amp;ConfigEditor::on_contour_selected);\n  connect(ui-&gt;add_contour_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::add_contour);\n  connect(ui-&gt;remove_contour_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::remove_contour);\n\n  // Use currentIndexChanged for combos to handle \"Add new color\"\n  connect(ui-&gt;contour_color_combo, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this,\n          &amp;ConfigEditor::update_contour_from_ui);\n\n  auto connect_contour = [this](QWidget* widget) {\n    if (auto* le = qobject_cast&lt;QLineEdit*&gt;(widget)) {\n      connect(le, &amp;QLineEdit::textChanged, this, &amp;ConfigEditor::update_contour_from_ui);\n    } else if (auto* sb = qobject_cast&lt;QSpinBox*&gt;(widget)) {\n      connect(sb, QOverload&lt;int&gt;::of(&amp;QSpinBox::valueChanged), this,\n              &amp;ConfigEditor::update_contour_from_ui);\n    }\n  };\n  connect_contour(ui-&gt;contour_name_edit);\n  connect_contour(ui-&gt;contour_interval_edit);\n  connect_contour(ui-&gt;contour_min_points_edit);\n  // contour_color_combo connected separately\n  connect_contour(ui-&gt;contour_width_edit);\n\n  // Water Tab\n  connect(ui-&gt;water_list_widget, &amp;QListWidget::itemSelectionChanged, this,\n          &amp;ConfigEditor::on_water_selected);\n  connect(ui-&gt;add_water_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::add_water);\n  connect(ui-&gt;remove_water_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::remove_water);\n\n  connect(ui-&gt;water_color_combo, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this,\n          &amp;ConfigEditor::update_water_from_ui);\n\n  auto connect_water = [this](QWidget* widget) {\n    if (auto* le = qobject_cast&lt;QLineEdit*&gt;(widget)) {\n      connect(le, &amp;QLineEdit::textChanged, this, &amp;ConfigEditor::update_water_from_ui);\n    }\n  };\n  connect_water(ui-&gt;water_name_edit);\n  connect_water(ui-&gt;water_catchment_edit);\n  // water_color_combo connected separately\n  connect_water(ui-&gt;water_width_edit);\n\n  // Vegetation Tab\n  connect(ui-&gt;vege_list_widget, &amp;QListWidget::itemSelectionChanged, this,\n          &amp;ConfigEditor::on_vege_selected);\n  connect(ui-&gt;add_vege_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::add_vege);\n  connect(ui-&gt;remove_vege_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::remove_vege);\n  connect(ui-&gt;add_vege_color_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::add_vege_color);\n  connect(ui-&gt;remove_vege_color_button, &amp;QPushButton::clicked, this,\n          &amp;ConfigEditor::remove_vege_color);\n  connect(ui-&gt;vege_colors_table, &amp;QTableWidget::cellChanged, this,\n          &amp;ConfigEditor::update_vege_color_from_ui);\n\n  connect(ui-&gt;vege_bg_color_combo, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this,\n          &amp;ConfigEditor::update_vege_from_ui);\n\n  auto connect_vege = [this](QWidget* widget) {\n    if (auto* le = qobject_cast&lt;QLineEdit*&gt;(widget)) {\n      connect(le, &amp;QLineEdit::textChanged, this, &amp;ConfigEditor::update_vege_from_ui);\n    }\n  };\n  connect_vege(ui-&gt;vege_name_edit);\n  connect_vege(ui-&gt;vege_min_height_edit);\n  connect_vege(ui-&gt;vege_max_height_edit);\n\n  // Colors Tab\n  connect(ui-&gt;colors_list_widget, &amp;QListWidget::itemSelectionChanged, this,\n          &amp;ConfigEditor::on_color_selected);\n  connect(ui-&gt;add_color_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::add_color);\n  connect(ui-&gt;remove_color_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::remove_color);\n  connect(ui-&gt;pick_color_button, &amp;QPushButton::clicked, this, &amp;ConfigEditor::pick_color);\n  connect(ui-&gt;color_type_combo, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged), this,\n          &amp;ConfigEditor::on_color_type_changed);\n\n  auto connect_color = [this](QWidget* widget) {\n    if (auto* le = qobject_cast&lt;QLineEdit*&gt;(widget)) {\n      connect(le, &amp;QLineEdit::textChanged, this, &amp;ConfigEditor::update_color_from_ui);\n    } else if (auto* sb = qobject_cast&lt;QSpinBox*&gt;(widget)) {\n      connect(sb, QOverload&lt;int&gt;::of(&amp;QSpinBox::valueChanged), this,\n              &amp;ConfigEditor::update_color_from_ui);\n    }\n  };\n  connect_color(ui-&gt;color_name_edit);\n  connect_color(ui-&gt;color_c1_spin);\n  connect_color(ui-&gt;color_c2_spin);\n  connect_color(ui-&gt;color_c3_spin);\n  connect_color(ui-&gt;color_c4_spin);\n\n  set_ui_to_config(*m_config);\n}\n\nConfigEditor::~ConfigEditor() {}\n\nvoid ConfigEditor::open_config_file() {\n  QString config_file_name = QFileDialog::getOpenFileName(\n      this, (\"Open Config\"), m_config-&gt;relative_path_to_config.string().c_str(),\n      (\"Config Files (*.json *.jsonc);;All files (*)\"), nullptr, QFileDialog::ReadOnly);\n  if (config_file_name.isEmpty()) {\n    return;\n  }\n  m_config = std::make_unique&lt;Config&gt;(Config::FromFile(config_file_name.toStdString()));\n  set_ui_to_config(*m_config);\n}\n\nvoid ConfigEditor::add_las_file() {\n  fs::path directory;\n  QStringList las_file_names = QFileDialog::getOpenFileNames(\n      this, (\"Open LAS file/s\"), m_config-&gt;relative_path_to_config.string().c_str(),\n      (\"LAS Files (*.las *.laz);;All files (*)\"), nullptr, QFileDialog::ReadOnly);\n  if (las_file_names.isEmpty()) {\n    return;\n  }\n  for (const QString&amp; las_file_name : las_file_names) {\n    m_config-&gt;las_files.push_back(las_file_name.toStdString());\n  }\n  set_ui_to_config(*m_config);\n}\n\nvoid ConfigEditor::remove_las_file() {\n  QList&lt;QTreeWidgetItem*&gt; items = ui-&gt;treeWidget-&gt;selectedItems();\n  for (QTreeWidgetItem* item : items) {\n    m_config-&gt;las_files.erase(std::remove(m_config-&gt;las_files.begin(), m_config-&gt;las_files.end(),\n                                          item-&gt;text(1).toStdString()),\n                              m_config-&gt;las_files.end());\n    delete item;\n  }\n  set_ui_to_config(*m_config);\n}\n\nvoid ConfigEditor::add_las_folder() {\n  fs::path directory;\n  QString las_folder_name = QFileDialog::getExistingDirectory(\n      this, tr(\"Choose LAS Folder\"), m_config-&gt;relative_path_to_config.string().c_str(),\n      QFileDialog::DontResolveSymlinks);\n  if (las_folder_name.isEmpty()) {\n    return;\n  }\n  m_config-&gt;las_files.push_back(las_folder_name.toStdString());\n  set_ui_to_config(*m_config);\n}\n\nvoid ConfigEditor::save_config_file() {\n  QString config_file_name = QFileDialog::getSaveFileName(\n      this, (\"Save Config\"), m_config-&gt;relative_path_to_config.string().c_str(),\n      (\"Config Files (*.json *.jsonc);;All files (*)\"), nullptr, QFileDialog::ReadOnly);\n  if (config_file_name.isEmpty()) {\n    return;\n  }\n  m_config-&gt;write_to_file(config_file_name.toStdString());\n}\n\nvoid ConfigEditor::open_output_directory() {\n  QString output_dir_name = QFileDialog::getExistingDirectory(\n      this, tr(\"Choose Output Directory\"), m_config-&gt;output_path().string().c_str(),\n      QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);\n  if (output_dir_name.isEmpty()) {\n    return;\n  }\n  m_config-&gt;set_output_directory(output_dir_name.toStdString());\n  ui-&gt;out_dir_line_edit-&gt;setText(output_dir_name);\n  config_changed();\n}\n\nvoid ConfigEditor::populate_color_combo(QComboBox* combo) {\n  bool was_blocked = combo-&gt;blockSignals(true);\n  combo-&gt;clear();\n  for (const auto&amp; [name, color] : COLOR_MAP) {\n    combo-&gt;addItem(create_color_icon(color), QString::fromStdString(name));\n  }\n  combo-&gt;addItem(\"Add new color...\");\n  combo-&gt;blockSignals(was_blocked);\n}\n\nvoid ConfigEditor::set_ui_to_config(const Config&amp; config) {\n  m_updating_ui = true;\n\n  // 1. Populate all color combos first\n  populate_color_combo(ui-&gt;buildings_color);\n  populate_color_combo(ui-&gt;contour_color_combo);\n  populate_color_combo(ui-&gt;water_color_combo);\n  populate_color_combo(ui-&gt;vege_bg_color_combo);\n\n  ui-&gt;out_dir_line_edit-&gt;setText(config.output_path().string().c_str());\n\n  ui-&gt;scale_dropdown-&gt;setCurrentText(double_to_string(config.render.scale).c_str());\n  ui-&gt;dpi_dropdown-&gt;setCurrentText(double_to_string(config.render.dpi).c_str());\n\n  ui-&gt;process_tiles_checkbox-&gt;setChecked(\n      std::find(config.processing_steps.begin(), config.processing_steps.end(),\n                ProcessingStep::Tiles) != config.processing_steps.end());\n  ui-&gt;combine_tiles_checkbox-&gt;setChecked(\n      std::find(config.processing_steps.begin(), config.processing_steps.end(),\n                ProcessingStep::Combine) != config.processing_steps.end());\n\n  ui-&gt;treeWidget-&gt;clear();\n  ui-&gt;treeWidget-&gt;setColumnWidth(0, 60);\n  for (const fs::path&amp; path : config.las_files) {\n    QTreeWidgetItem* item = new QTreeWidgetItem(ui-&gt;treeWidget);\n    item-&gt;setText(1, path.string().c_str());\n    std::vector&lt;fs::path&gt; las_files = config.get_las_files(path);\n    item-&gt;setExpanded(las_files.size() &gt; 1);\n    item-&gt;setText(0, QString::number(las_files.size()));\n    item-&gt;setTextAlignment(0, Qt::AlignCenter);\n    ui-&gt;treeWidget-&gt;addTopLevelItem(item);\n    if (las_files.size() == 0) {\n      item-&gt;setForeground(0, QBrush(Qt::red));\n      item-&gt;setForeground(1, QBrush(Qt::red));\n    } else if (fs::is_directory(path)) {\n      for (const fs::path&amp; entry : las_files) {\n        QTreeWidgetItem* child = new QTreeWidgetItem(item);\n        child-&gt;setText(1, entry.string().c_str());\n        child-&gt;setDisabled(true);\n        item-&gt;addChild(child);\n      }\n    }\n  }\n\n  // 2. Set General Tab fields and specific color selections\n  ui-&gt;grid_bin_resolution-&gt;setText(QString::number(config.grid.bin_resolution));\n  ui-&gt;grid_downsample_factor-&gt;setValue(config.grid.downsample_factor);\n  ui-&gt;ground_outlier_removal-&gt;setText(QString::number(config.ground.outlier_removal_height_diff));\n  ui-&gt;ground_min_intensity-&gt;setValue(config.ground.min_ground_intensity);\n  ui-&gt;ground_max_intensity-&gt;setValue(config.ground.max_ground_intensity);\n  ui-&gt;buildings_color-&gt;setCurrentText(get_color_name(config.buildings.color));\n  ui-&gt;border_width-&gt;setText(QString::number(config.border_width));\n\n  ui-&gt;vege_bg_color_combo-&gt;setCurrentText(get_color_name(config.vege.background_color));\n\n  // 3. Populate Lists (these trigger detail loading for the first items via signals)\n  // Since combos are already populated, details loading will correctly set the selections.\n  populate_contour_list();\n  populate_water_list();\n  populate_vege_list();\n  populate_color_list();\n\n  m_updating_ui = false;\n  config_changed();\n}\n\n// Helpers for General Tab\nvoid ConfigEditor::update_general_from_ui() {\n  if (m_updating_ui) return;\n\n  if (ui-&gt;buildings_color-&gt;currentText() == \"Add new color...\") {\n    ui-&gt;tabWidget-&gt;setCurrentWidget(ui-&gt;Colors_tab);\n    add_color();\n    return;\n  }\n\n  m_config-&gt;grid.bin_resolution = ui-&gt;grid_bin_resolution-&gt;text().toDouble();\n  m_config-&gt;grid.downsample_factor = ui-&gt;grid_downsample_factor-&gt;value();\n  m_config-&gt;ground.outlier_removal_height_diff = ui-&gt;ground_outlier_removal-&gt;text().toDouble();\n  m_config-&gt;ground.min_ground_intensity = ui-&gt;ground_min_intensity-&gt;value();\n  m_config-&gt;ground.max_ground_intensity = ui-&gt;ground_max_intensity-&gt;value();\n  m_config-&gt;border_width = ui-&gt;border_width-&gt;text().toDouble();\n\n  QString b_color = ui-&gt;buildings_color-&gt;currentText();\n  if (COLOR_MAP.count(b_color.toStdString())) {\n    m_config-&gt;buildings.color = COLOR_MAP.at(b_color.toStdString());\n  }\n\n  config_changed();\n}\n\n// Helpers for Contours\nvoid ConfigEditor::populate_contour_list() {\n  QString selected;\n  if (auto* item = ui-&gt;contours_list_widget-&gt;currentItem()) {\n    selected = item-&gt;text();\n  }\n\n  ui-&gt;contours_list_widget-&gt;clear();\n  for (const auto&amp; [name, config] : m_config-&gt;contours.configs) {\n    ui-&gt;contours_list_widget-&gt;addItem(QString::fromStdString(name));\n  }\n\n  if (!selected.isEmpty()) {\n    auto items = ui-&gt;contours_list_widget-&gt;findItems(selected, Qt::MatchExactly);\n    if (!items.empty()) {\n      ui-&gt;contours_list_widget-&gt;setCurrentItem(items.front());\n    } else if (ui-&gt;contours_list_widget-&gt;count() &gt; 0) {\n      ui-&gt;contours_list_widget-&gt;setCurrentRow(0);\n    }\n  } else if (ui-&gt;contours_list_widget-&gt;count() &gt; 0) {\n    ui-&gt;contours_list_widget-&gt;setCurrentRow(0);\n  }\n}\n\nvoid ConfigEditor::add_contour() {\n  std::string name = \"new_contour\";\n  int i = 1;\n  while (m_config-&gt;contours.configs.count(name)) {\n    name = \"new_contour_\" + std::to_string(i++);\n  }\n  m_config-&gt;contours.configs[name] = ContourConfig();\n  populate_contour_list();\n}\n\nvoid ConfigEditor::remove_contour() {\n  auto items = ui-&gt;contours_list_widget-&gt;selectedItems();\n  if (items.empty()) return;\n  std::string name = items.front()-&gt;text().toStdString();\n  m_config-&gt;contours.configs.erase(name);\n  populate_contour_list();\n}\n\nvoid ConfigEditor::on_contour_selected() {\n  auto items = ui-&gt;contours_list_widget-&gt;selectedItems();\n  if (items.empty()) return;\n  load_contour_details(items.front()-&gt;text().toStdString());\n}\n\nvoid ConfigEditor::load_contour_details(const std::string&amp; name) {\n  bool was_updating = m_updating_ui;\n  m_updating_ui = true;\n  const auto&amp; config = m_config-&gt;contours.configs.at(name);\n  ui-&gt;contour_name_edit-&gt;setText(QString::fromStdString(name));\n  ui-&gt;contour_interval_edit-&gt;setText(QString::number(config.interval));\n  ui-&gt;contour_min_points_edit-&gt;setValue(config.min_points);\n  ui-&gt;contour_width_edit-&gt;setText(QString::number(config.width));\n  ui-&gt;contour_color_combo-&gt;setCurrentText(get_color_name(config.color));\n  m_updating_ui = was_updating;\n}\n\nvoid ConfigEditor::update_contour_from_ui() {\n  if (m_updating_ui) return;\n  auto items = ui-&gt;contours_list_widget-&gt;selectedItems();\n  if (items.empty()) return;\n\n  if (ui-&gt;contour_color_combo-&gt;currentText() == \"Add new color...\") {\n    ui-&gt;tabWidget-&gt;setCurrentWidget(ui-&gt;Colors_tab);\n    add_color();\n    return;\n  }\n\n  std::string old_name = items.front()-&gt;text().toStdString();\n  std::string new_name = ui-&gt;contour_name_edit-&gt;text().toStdString();\n\n  ContourConfig config = m_config-&gt;contours.configs.at(old_name);\n  config.interval = ui-&gt;contour_interval_edit-&gt;text().toDouble();\n  config.min_points = ui-&gt;contour_min_points_edit-&gt;value();\n  config.width = ui-&gt;contour_width_edit-&gt;text().toDouble();\n\n  QString color = ui-&gt;contour_color_combo-&gt;currentText();\n  if (COLOR_MAP.count(color.toStdString())) {\n    config.color = COLOR_MAP.at(color.toStdString());\n  }\n\n  if (old_name != new_name &amp;&amp; !new_name.empty() &amp;&amp; !m_config-&gt;contours.configs.count(new_name)) {\n    m_config-&gt;contours.configs.erase(old_name);\n    m_config-&gt;contours.configs[new_name] = config;\n    items.front()-&gt;setText(QString::fromStdString(new_name));\n  } else {\n    m_config-&gt;contours.configs[old_name] = config;\n  }\n\n  config_changed();\n}\n\n// Helpers for Water\nvoid ConfigEditor::populate_water_list() {\n  QString selected;\n  if (auto* item = ui-&gt;water_list_widget-&gt;currentItem()) {\n    selected = item-&gt;text();\n  }\n\n  ui-&gt;water_list_widget-&gt;clear();\n  for (const auto&amp; [name, config] : m_config-&gt;water.configs) {\n    ui-&gt;water_list_widget-&gt;addItem(QString::fromStdString(name));\n  }\n\n  if (!selected.isEmpty()) {\n    auto items = ui-&gt;water_list_widget-&gt;findItems(selected, Qt::MatchExactly);\n    if (!items.empty()) {\n      ui-&gt;water_list_widget-&gt;setCurrentItem(items.front());\n    } else if (ui-&gt;water_list_widget-&gt;count() &gt; 0) {\n      ui-&gt;water_list_widget-&gt;setCurrentRow(0);\n    }\n  } else if (ui-&gt;water_list_widget-&gt;count() &gt; 0) {\n    ui-&gt;water_list_widget-&gt;setCurrentRow(0);\n  }\n}\n\nvoid ConfigEditor::add_water() {\n  std::string name = \"new_water\";\n  int i = 1;\n  while (m_config-&gt;water.configs.count(name)) {\n    name = \"new_water_\" + std::to_string(i++);\n  }\n  m_config-&gt;water.configs[name] = WaterConfig();\n  populate_water_list();\n}\n\nvoid ConfigEditor::remove_water() {\n  auto items = ui-&gt;water_list_widget-&gt;selectedItems();\n  if (items.empty()) return;\n  std::string name = items.front()-&gt;text().toStdString();\n  m_config-&gt;water.configs.erase(name);\n  populate_water_list();\n}\n\nvoid ConfigEditor::on_water_selected() {\n  auto items = ui-&gt;water_list_widget-&gt;selectedItems();\n  if (items.empty()) return;\n  load_water_details(items.front()-&gt;text().toStdString());\n}\n\nvoid ConfigEditor::load_water_details(const std::string&amp; name) {\n  bool was_updating = m_updating_ui;\n  m_updating_ui = true;\n  const auto&amp; config = m_config-&gt;water.configs.at(name);\n  ui-&gt;water_name_edit-&gt;setText(QString::fromStdString(name));\n  ui-&gt;water_catchment_edit-&gt;setText(QString::number(config.catchment));\n  ui-&gt;water_width_edit-&gt;setText(QString::number(config.width));\n  ui-&gt;water_color_combo-&gt;setCurrentText(get_color_name(config.color));\n  m_updating_ui = was_updating;\n}\n\nvoid ConfigEditor::update_water_from_ui() {\n  if (m_updating_ui) return;\n  auto items = ui-&gt;water_list_widget-&gt;selectedItems();\n  if (items.empty()) return;\n\n  if (ui-&gt;water_color_combo-&gt;currentText() == \"Add new color...\") {\n    ui-&gt;tabWidget-&gt;setCurrentWidget(ui-&gt;Colors_tab);\n    add_color();\n    return;\n  }\n\n  std::string old_name = items.front()-&gt;text().toStdString();\n  std::string new_name = ui-&gt;water_name_edit-&gt;text().toStdString();\n\n  WaterConfig config = m_config-&gt;water.configs.at(old_name);\n  config.catchment = ui-&gt;water_catchment_edit-&gt;text().toDouble();\n  config.width = ui-&gt;water_width_edit-&gt;text().toDouble();\n\n  QString color = ui-&gt;water_color_combo-&gt;currentText();\n  if (COLOR_MAP.count(color.toStdString())) {\n    config.color = COLOR_MAP.at(color.toStdString());\n  }\n\n  if (old_name != new_name &amp;&amp; !new_name.empty() &amp;&amp; !m_config-&gt;water.configs.count(new_name)) {\n    m_config-&gt;water.configs.erase(old_name);\n    m_config-&gt;water.configs[new_name] = config;\n    items.front()-&gt;setText(QString::fromStdString(new_name));\n  } else {\n    m_config-&gt;water.configs[old_name] = config;\n  }\n  config_changed();\n}\n\n// Helpers for Vegetation\nvoid ConfigEditor::populate_vege_list() {\n  QString selected;\n  if (auto* item = ui-&gt;vege_list_widget-&gt;currentItem()) {\n    selected = item-&gt;text();\n  }\n\n  ui-&gt;vege_list_widget-&gt;clear();\n  for (const auto&amp; config : m_config-&gt;vege.height_configs) {\n    ui-&gt;vege_list_widget-&gt;addItem(QString::fromStdString(config.name));\n  }\n\n  if (!selected.isEmpty()) {\n    auto items = ui-&gt;vege_list_widget-&gt;findItems(selected, Qt::MatchExactly);\n    if (!items.empty()) {\n      ui-&gt;vege_list_widget-&gt;setCurrentItem(items.front());\n    } else if (ui-&gt;vege_list_widget-&gt;count() &gt; 0) {\n      ui-&gt;vege_list_widget-&gt;setCurrentRow(0);\n    }\n  } else if (ui-&gt;vege_list_widget-&gt;count() &gt; 0) {\n    ui-&gt;vege_list_widget-&gt;setCurrentRow(0);\n  }\n}\n\nvoid ConfigEditor::add_vege() {\n  VegeHeightConfig config;\n  config.name = \"new_vege\";\n  m_config-&gt;vege.height_configs.push_back(config);\n  populate_vege_list();\n}\n\nvoid ConfigEditor::remove_vege() {\n  int row = ui-&gt;vege_list_widget-&gt;currentRow();\n  if (row &lt; 0 || row &gt;= (int)m_config-&gt;vege.height_configs.size()) return;\n  m_config-&gt;vege.height_configs.erase(m_config-&gt;vege.height_configs.begin() + row);\n  populate_vege_list();\n}\n\nvoid ConfigEditor::on_vege_selected() {\n  int row = ui-&gt;vege_list_widget-&gt;currentRow();\n  if (row &lt; 0) return;\n  load_vege_details(row);\n}\n\nvoid ConfigEditor::load_vege_details(int index) {\n  if (index &lt; 0 || index &gt;= (int)m_config-&gt;vege.height_configs.size()) return;\n  bool was_updating = m_updating_ui;\n  m_updating_ui = true;\n  const auto&amp; config = m_config-&gt;vege.height_configs[index];\n  ui-&gt;vege_name_edit-&gt;setText(QString::fromStdString(config.name));\n  ui-&gt;vege_min_height_edit-&gt;setText(QString::number(config.min_height));\n  ui-&gt;vege_max_height_edit-&gt;setText(QString::number(config.max_height));\n\n  ui-&gt;vege_colors_table-&gt;setRowCount(0);\n  for (const auto&amp; pair : config.colors) {\n    int r = ui-&gt;vege_colors_table-&gt;rowCount();\n    ui-&gt;vege_colors_table-&gt;insertRow(r);\n    ui-&gt;vege_colors_table-&gt;setItem(r, 0,\n                                   new QTableWidgetItem(QString::number(pair.blocking_threshold)));\n\n    QComboBox* combo = new QComboBox();\n    populate_color_combo(combo);\n    combo-&gt;setCurrentText(get_color_name(pair.color));\n    connect(combo, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged),\n            [this, r]() { update_vege_color_from_ui(r, 1); });\n    ui-&gt;vege_colors_table-&gt;setCellWidget(r, 1, combo);\n  }\n  m_updating_ui = was_updating;\n}\n\nvoid ConfigEditor::update_vege_from_ui() {\n  if (m_updating_ui) return;\n\n  if (ui-&gt;vege_bg_color_combo-&gt;currentText() == \"Add new color...\") {\n    ui-&gt;tabWidget-&gt;setCurrentWidget(ui-&gt;Colors_tab);\n    add_color();\n    return;\n  }\n\n  int row = ui-&gt;vege_list_widget-&gt;currentRow();\n  if (row &lt; 0 || row &gt;= (int)m_config-&gt;vege.height_configs.size()) return;\n\n  auto&amp; config = m_config-&gt;vege.height_configs[row];\n  config.name = ui-&gt;vege_name_edit-&gt;text().toStdString();\n  config.min_height = ui-&gt;vege_min_height_edit-&gt;text().toDouble();\n  config.max_height = ui-&gt;vege_max_height_edit-&gt;text().toDouble();\n\n  QString bg_color = ui-&gt;vege_bg_color_combo-&gt;currentText();\n  if (COLOR_MAP.count(bg_color.toStdString())) {\n    m_config-&gt;vege.background_color = COLOR_MAP.at(bg_color.toStdString());\n  }\n\n  ui-&gt;vege_list_widget-&gt;item(row)-&gt;setText(QString::fromStdString(config.name));\n  config_changed();\n}\n\nvoid ConfigEditor::add_vege_color() {\n  int row = ui-&gt;vege_list_widget-&gt;currentRow();\n  if (row &lt; 0 || row &gt;= (int)m_config-&gt;vege.height_configs.size()) return;\n\n  m_config-&gt;vege.height_configs[row].colors.push_back({0.0, RGBColor(255, 255, 255)});\n  load_vege_details(row);\n  config_changed();\n}\n\nvoid ConfigEditor::remove_vege_color() {\n  int row = ui-&gt;vege_list_widget-&gt;currentRow();\n  if (row &lt; 0 || row &gt;= (int)m_config-&gt;vege.height_configs.size()) return;\n\n  int color_row = ui-&gt;vege_colors_table-&gt;currentRow();\n  if (color_row &lt; 0 || color_row &gt;= (int)m_config-&gt;vege.height_configs[row].colors.size()) return;\n\n  auto&amp; colors = m_config-&gt;vege.height_configs[row].colors;\n  colors.erase(colors.begin() + color_row);\n  load_vege_details(row);\n  config_changed();\n}\n\nvoid ConfigEditor::update_vege_color_from_ui(int row, int column) {\n  if (m_updating_ui) return;\n  int vege_row = ui-&gt;vege_list_widget-&gt;currentRow();\n  if (vege_row &lt; 0 || vege_row &gt;= (int)m_config-&gt;vege.height_configs.size()) return;\n\n  auto&amp; pair = m_config-&gt;vege.height_configs[vege_row].colors[row];\n  if (column == 0) {\n    pair.blocking_threshold = ui-&gt;vege_colors_table-&gt;item(row, column)-&gt;text().toDouble();\n  } else if (column == 1) {\n    QComboBox* combo = qobject_cast&lt;QComboBox*&gt;(ui-&gt;vege_colors_table-&gt;cellWidget(row, column));\n    if (combo) {\n      if (combo-&gt;currentText() == \"Add new color...\") {\n        ui-&gt;tabWidget-&gt;setCurrentWidget(ui-&gt;Colors_tab);\n        add_color();\n        return;\n      }\n      QString color = combo-&gt;currentText();\n      if (COLOR_MAP.count(color.toStdString())) {\n        pair.color = COLOR_MAP.at(color.toStdString());\n      }\n    }\n  }\n  config_changed();\n}\n\n// Helpers for Colors\nvoid ConfigEditor::populate_color_list() {\n  QString selected;\n  if (auto* item = ui-&gt;colors_list_widget-&gt;currentItem()) {\n    selected = item-&gt;text();\n  }\n\n  ui-&gt;colors_list_widget-&gt;clear();\n  for (const auto&amp; [name, color] : COLOR_MAP) {\n    ui-&gt;colors_list_widget-&gt;addItem(\n        new QListWidgetItem(create_color_icon(color), QString::fromStdString(name)));\n  }\n\n  if (!selected.isEmpty()) {\n    auto items = ui-&gt;colors_list_widget-&gt;findItems(selected, Qt::MatchExactly);\n    if (!items.empty()) {\n      ui-&gt;colors_list_widget-&gt;setCurrentItem(items.front());\n    } else if (ui-&gt;colors_list_widget-&gt;count() &gt; 0) {\n      ui-&gt;colors_list_widget-&gt;setCurrentRow(0);\n    }\n  } else if (ui-&gt;colors_list_widget-&gt;count() &gt; 0) {\n    ui-&gt;colors_list_widget-&gt;setCurrentRow(0);\n  }\n}\n\nvoid ConfigEditor::add_color() {\n  std::string name = \"new_color\";\n  int i = 1;\n  while (COLOR_MAP.count(name)) {\n    name = \"new_color_\" + std::to_string(i++);\n  }\n  COLOR_MAP[name] = RGBColor(255, 255, 255);\n  set_ui_to_config(*m_config);  // Re-populate all lists\n  // Select the new color in the Colors tab\n  auto items = ui-&gt;colors_list_widget-&gt;findItems(QString::fromStdString(name), Qt::MatchExactly);\n  if (!items.empty()) {\n    ui-&gt;colors_list_widget-&gt;setCurrentItem(items.front());\n  }\n}\n\nvoid ConfigEditor::remove_color() {\n  auto items = ui-&gt;colors_list_widget-&gt;selectedItems();\n  if (items.empty()) return;\n  std::string name = items.front()-&gt;text().toStdString();\n  COLOR_MAP.erase(name);\n  set_ui_to_config(*m_config);  // Re-populate all lists\n  config_changed();\n}\n\nvoid ConfigEditor::on_color_selected() {\n  auto items = ui-&gt;colors_list_widget-&gt;selectedItems();\n  if (items.empty()) return;\n  load_color_details(items.front()-&gt;text().toStdString());\n}\n\nvoid ConfigEditor::load_color_details(const std::string&amp; name) {\n  if (!COLOR_MAP.count(name)) return;\n  bool was_updating = m_updating_ui;\n  m_updating_ui = true;\n  const auto&amp; color = COLOR_MAP.at(name);\n  ui-&gt;color_name_edit-&gt;setText(QString::fromStdString(name));\n\n  if (std::holds_alternative&lt;RGBColor&gt;(color)) {\n    ui-&gt;color_type_combo-&gt;setCurrentIndex(0);  // RGB\n    const auto&amp; rgb = std::get&lt;RGBColor&gt;(color);\n    ui-&gt;color_c1_spin-&gt;setValue(rgb.getRed());\n    ui-&gt;color_c2_spin-&gt;setValue(rgb.getGreen());\n    ui-&gt;color_c3_spin-&gt;setValue(rgb.getBlue());\n    ui-&gt;color_c4_spin-&gt;setValue(rgb.getAlpha());\n  } else {\n    ui-&gt;color_type_combo-&gt;setCurrentIndex(1);  // CMYK\n    const auto&amp; cmyk = std::get&lt;CMYKColor&gt;(color);\n    ui-&gt;color_c1_spin-&gt;setValue(cmyk.getCyan());\n    ui-&gt;color_c2_spin-&gt;setValue(cmyk.getMagenta());\n    ui-&gt;color_c3_spin-&gt;setValue(cmyk.getYellow());\n    ui-&gt;color_c4_spin-&gt;setValue(cmyk.getBlack());\n  }\n  on_color_type_changed(ui-&gt;color_type_combo-&gt;currentIndex());  // Update labels\n  m_updating_ui = was_updating;\n}\n\nvoid ConfigEditor::on_color_type_changed(int index) {\n  if (m_updating_ui) {\n    // Just update labels and maximums during loading\n    if (index == 0) {  // RGB\n      ui-&gt;label_c1-&gt;setText(\"Red:\");\n      ui-&gt;label_c2-&gt;setText(\"Green:\");\n      ui-&gt;label_c3-&gt;setText(\"Blue:\");\n      ui-&gt;label_c4-&gt;setText(\"Alpha:\");\n      ui-&gt;color_c1_spin-&gt;setMaximum(255);\n      ui-&gt;color_c2_spin-&gt;setMaximum(255);\n      ui-&gt;color_c3_spin-&gt;setMaximum(255);\n      ui-&gt;color_c4_spin-&gt;setMaximum(255);\n      ui-&gt;pick_color_button-&gt;setEnabled(true);\n    } else {  // CMYK\n      ui-&gt;label_c1-&gt;setText(\"Cyan:\");\n      ui-&gt;label_c2-&gt;setText(\"Magenta:\");\n      ui-&gt;label_c3-&gt;setText(\"Yellow:\");\n      ui-&gt;label_c4-&gt;setText(\"Black:\");\n      ui-&gt;color_c1_spin-&gt;setMaximum(100);\n      ui-&gt;color_c2_spin-&gt;setMaximum(100);\n      ui-&gt;color_c3_spin-&gt;setMaximum(100);\n      ui-&gt;color_c4_spin-&gt;setMaximum(100);\n      ui-&gt;pick_color_button-&gt;setEnabled(false);\n    }\n    return;\n  }\n\n  // Capture \"old\" values for conversion\n  int v1 = ui-&gt;color_c1_spin-&gt;value();\n  int v2 = ui-&gt;color_c2_spin-&gt;value();\n  int v3 = ui-&gt;color_c3_spin-&gt;value();\n  int v4 = ui-&gt;color_c4_spin-&gt;value();\n\n  m_updating_ui = true;\n\n  if (index == 0) {  // Switching TO RGB (from CMYK)\n    CMYKColor cmyk(v1, v2, v3, v4);\n    RGBColor rgb = RGBColor::FromCMYK(cmyk);\n\n    ui-&gt;label_c1-&gt;setText(\"Red:\");\n    ui-&gt;label_c2-&gt;setText(\"Green:\");\n    ui-&gt;label_c3-&gt;setText(\"Blue:\");\n    ui-&gt;label_c4-&gt;setText(\"Alpha:\");\n    ui-&gt;color_c1_spin-&gt;setMaximum(255);\n    ui-&gt;color_c2_spin-&gt;setMaximum(255);\n    ui-&gt;color_c3_spin-&gt;setMaximum(255);\n    ui-&gt;color_c4_spin-&gt;setMaximum(255);\n\n    ui-&gt;color_c1_spin-&gt;setValue(rgb.getRed());\n    ui-&gt;color_c2_spin-&gt;setValue(rgb.getGreen());\n    ui-&gt;color_c3_spin-&gt;setValue(rgb.getBlue());\n    ui-&gt;color_c4_spin-&gt;setValue(rgb.getAlpha());\n\n    ui-&gt;pick_color_button-&gt;setEnabled(true);\n  } else {  // Switching TO CMYK (from RGB)\n    RGBColor rgb(v1, v2, v3, v4);\n    CMYKColor cmyk = CMYKColor::FromRGB(rgb);\n\n    ui-&gt;label_c1-&gt;setText(\"Cyan:\");\n    ui-&gt;label_c2-&gt;setText(\"Magenta:\");\n    ui-&gt;label_c3-&gt;setText(\"Yellow:\");\n    ui-&gt;label_c4-&gt;setText(\"Black:\");\n    ui-&gt;color_c1_spin-&gt;setMaximum(100);\n    ui-&gt;color_c2_spin-&gt;setMaximum(100);\n    ui-&gt;color_c3_spin-&gt;setMaximum(100);\n    ui-&gt;color_c4_spin-&gt;setMaximum(100);\n\n    ui-&gt;color_c1_spin-&gt;setValue(cmyk.getCyan());\n    ui-&gt;color_c2_spin-&gt;setValue(cmyk.getMagenta());\n    ui-&gt;color_c3_spin-&gt;setValue(cmyk.getYellow());\n    ui-&gt;color_c4_spin-&gt;setValue(cmyk.getBlack());\n\n    ui-&gt;pick_color_button-&gt;setEnabled(false);\n  }\n\n  m_updating_ui = false;\n  update_color_from_ui();\n}\n\nvoid ConfigEditor::update_color_from_ui() {\n  if (m_updating_ui) return;\n  auto items = ui-&gt;colors_list_widget-&gt;selectedItems();\n  if (items.empty()) return;\n  std::string old_name = items.front()-&gt;text().toStdString();\n  std::string new_name = ui-&gt;color_name_edit-&gt;text().toStdString();\n\n  ColorVariant new_color;\n  if (ui-&gt;color_type_combo-&gt;currentIndex() == 0) {  // RGB\n    new_color = RGBColor(ui-&gt;color_c1_spin-&gt;value(), ui-&gt;color_c2_spin-&gt;value(),\n                         ui-&gt;color_c3_spin-&gt;value(), ui-&gt;color_c4_spin-&gt;value());\n  } else {  // CMYK\n    new_color = CMYKColor(ui-&gt;color_c1_spin-&gt;value(), ui-&gt;color_c2_spin-&gt;value(),\n                          ui-&gt;color_c3_spin-&gt;value(), ui-&gt;color_c4_spin-&gt;value());\n  }\n\n  if (old_name != new_name &amp;&amp; !new_name.empty()) {\n    if (!COLOR_MAP.count(new_name)) {\n      COLOR_MAP.erase(old_name);\n      COLOR_MAP[new_name] = new_color;\n      items.front()-&gt;setText(QString::fromStdString(new_name));\n      set_ui_to_config(*m_config);  // Name changed, refresh combos\n    }\n  } else {\n    COLOR_MAP[old_name] = new_color;\n    // Color value changed, refresh icons?\n    // Yes, need to refresh UI to show new color icons\n    set_ui_to_config(*m_config);\n  }\n  config_changed();\n}\n\nvoid ConfigEditor::pick_color() {\n  QColor color =\n      QColorDialog::getColor(Qt::white, this, \"Pick Color\", QColorDialog::ShowAlphaChannel);\n  if (color.isValid()) {\n    ui-&gt;color_type_combo-&gt;setCurrentIndex(0);  // Ensure RGB\n    ui-&gt;color_c1_spin-&gt;setValue(color.red());\n    ui-&gt;color_c2_spin-&gt;setValue(color.green());\n    ui-&gt;color_c3_spin-&gt;setValue(color.blue());\n    ui-&gt;color_c4_spin-&gt;setValue(color.alpha());\n    // update_color_from_ui called by value changes\n  }\n}\n</code></pre>"},{"location":"blaze/config__editor_8hpp/","title":"File config_editor.hpp","text":"<p>FileList &gt; gui &gt; config_editor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QToolBox&gt;</code></li> </ul>"},{"location":"blaze/config__editor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace Ui"},{"location":"blaze/config__editor_8hpp/#classes","title":"Classes","text":"Type Name class ConfigEditor <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/config_editor.hpp</code></p>"},{"location":"blaze/config__editor_8hpp_source/","title":"File config_editor.hpp","text":"<p>File List &gt; gui &gt; config_editor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;QToolBox&gt;\n\nstruct Config;\nclass QComboBox;\n\nnamespace Ui {\nclass ConfigEditor;\n}\n\nclass ConfigEditor : public QWidget {\n  Q_OBJECT\n\n public:\n  explicit ConfigEditor(QWidget* parent = nullptr);\n  ~ConfigEditor();\n\n  const Config&amp; get_config() { return *m_config; }\n\n  bool is_valid() const;\n\n public slots:\n  void open_config_file();\n  void save_config_file();\n  void add_las_file();\n  void remove_las_file();\n  void add_las_folder();\n\n  // Contours\n  void add_contour();\n  void remove_contour();\n  void on_contour_selected();\n  void update_contour_from_ui();\n\n  // Water\n  void add_water();\n  void remove_water();\n  void on_water_selected();\n  void update_water_from_ui();\n\n  // Vegetation\n  void add_vege();\n  void remove_vege();\n  void on_vege_selected();\n  void update_vege_from_ui();\n  void add_vege_color();\n  void remove_vege_color();\n  void update_vege_color_from_ui(int row, int column);\n\n  // Colors\n  void add_color();\n  void remove_color();\n  void on_color_selected();\n  void update_color_from_ui();\n  void pick_color();\n  void on_color_type_changed(int index);\n\n  // General\n  void update_general_from_ui();\n\n signals:\n  void config_changed();\n\n private:\n  void set_ui_to_config(const Config&amp; config);\n\n  void open_output_directory();\n\n  std::unique_ptr&lt;Ui::ConfigEditor&gt; ui;\n  std::unique_ptr&lt;Config&gt; m_config;\n\n  // Helpers\n  void populate_contour_list();\n  void populate_water_list();\n  void populate_vege_list();\n  void populate_color_list();\n  void load_contour_details(const std::string&amp; name);\n  void load_water_details(const std::string&amp; name);\n  void load_vege_details(int index);\n  void load_color_details(const std::string&amp; name);\n  void populate_color_combo(QComboBox* combo);\n\n  bool m_updating_ui = false;\n};\n</code></pre>"},{"location":"blaze/gl__widget_8cpp/","title":"File gl_widget.cpp","text":"<p>FileList &gt; gui &gt; gl_widget.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"gl_widget.hpp\"</code></li> <li><code>#include &lt;math.h&gt;</code></li> <li><code>#include &lt;QCoreApplication&gt;</code></li> <li><code>#include &lt;QMatrix4x4&gt;</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QOpenGLFunctions&gt;</code></li> <li><code>#include &lt;QOpenGLShaderProgram&gt;</code></li> <li><code>#include &lt;QVector3D&gt;</code></li> <li><code>#include &lt;QtWidgets&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/gl_widget.cpp</code></p>"},{"location":"blaze/gl__widget_8cpp_source/","title":"File gl_widget.cpp","text":"<p>File List &gt; gui &gt; gl_widget.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"gl_widget.hpp\"\n\n#include &lt;math.h&gt;\n\n#include &lt;QCoreApplication&gt;\n#include &lt;QMatrix4x4&gt;\n#include &lt;QMouseEvent&gt;\n#include &lt;QOpenGLFunctions&gt;\n#include &lt;QOpenGLShaderProgram&gt;\n#include &lt;QVector3D&gt;\n#include &lt;QtWidgets&gt;\n#include &lt;iostream&gt;\n\nGLWidget::GLWidget(QWidget* parent) : QOpenGLWidget(parent), m_camera(width(), height()) {}\n\nGLWidget::~GLWidget() {}\n\nQSize GLWidget::sizeHint() const { return QSize(1000, 1000); }\n\nvoid GLWidget::initializeGL() {\n  initializeOpenGLFunctions();\n\n  setFocusPolicy(Qt::StrongFocus);\n\n  QOpenGLFunctions* f = QOpenGLContext::currentContext()-&gt;functions();\n\n  std::cout &lt;&lt; \"Detected OpenGL version: \" &lt;&lt; f-&gt;glGetString(GL_VERSION) &lt;&lt; std::endl;\n\n  Assert(f-&gt;glGetError() == GL_NO_ERROR, \"OpenGL error\");\n  Assert(QOpenGLContext::currentContext()-&gt;isValid(), \"OpenGL context is invalid\");\n\n  f-&gt;glEnable(GL_PROGRAM_POINT_SIZE);\n  f-&gt;glEnable(GL_DEPTH_TEST);\n  QPair&lt;int, int&gt; version = QOpenGLContext::currentContext()-&gt;format().version();\n  if (version.first &lt; 3 || (version.first == 3 &amp;&amp; version.second &lt; 3)) {\n    f-&gt;glEnable(GL_POINT_SPRITE);\n  }\n  f-&gt;glEnable(GL_BLEND);\n  f-&gt;glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n  f-&gt;glClearColor(0.2f, 0.2f, 0.2f, 1.0f);\n\n  QSurfaceFormat format = QOpenGLContext::currentContext()-&gt;format();\n\n  if (format.profile() == QSurfaceFormat::CompatibilityProfile) {\n    QOpenGLFunctions* opengl_functions = QOpenGLContext::currentContext()-&gt;functions();\n    GLint point_sprite_coord_origin;\n    opengl_functions-&gt;glGetIntegerv(GL_POINT_SPRITE_COORD_ORIGIN, &amp;point_sprite_coord_origin);\n    AssertEQ(point_sprite_coord_origin, GL_UPPER_LEFT);\n  }\n\n  GLenum err;\n  while ((err = glGetError()) != GL_NO_ERROR) {\n    std::cout &lt;&lt; \"OpenGL Initialization Error: \" &lt;&lt; err &lt;&lt; std::endl;\n  }\n}\n\nvoid GLWidget::paintGL() {\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n  m_camera.set_screen_size(width(), height());\n\n  for (const auto&amp; renderer : m_renderers) {\n    renderer-&gt;render(m_camera);\n  }\n\n  GLenum err;\n  while ((err = glGetError()) != GL_NO_ERROR) {\n    std::cout &lt;&lt; \"OpenGL Error: \" &lt;&lt; err &lt;&lt; std::endl;\n  }\n}\n\nvoid GLWidget::mousePressEvent(QMouseEvent* event) {\n  m_last_mouse_pos = event-&gt;position().toPoint();\n}\n\nvoid GLWidget::mouseMoveEvent(QMouseEvent* event) {\n  int dx = event-&gt;position().toPoint().x() - m_last_mouse_pos.x();\n  int dy = event-&gt;position().toPoint().y() - m_last_mouse_pos.y();\n\n  if (event-&gt;buttons() &amp; Qt::LeftButton) {\n    m_camera.rotate_around_center(0.2 * dx, 0.2 * dy);\n  } else if (event-&gt;buttons() &amp; Qt::MiddleButton) {\n    m_camera.rotate_view(0.2 * dx, 0.2 * dy);\n  } else if (event-&gt;buttons() &amp; Qt::RightButton) {\n    m_camera.pan(dx / 400.0f, dy / 400.0f);\n  }\n\n  m_last_mouse_pos = event-&gt;position().toPoint();\n  update();\n}\n\nvoid GLWidget::wheelEvent(QWheelEvent* event) {\n  QVector3D world_pos = m_camera.unproject(event-&gt;position());\n  m_camera.move_towards(world_pos,\n                        m_camera.direction().length() * event-&gt;angleDelta().y() / 2000.0f, true);\n  update();\n}\n\nvoid GLWidget::keyPressEvent(QKeyEvent* event) {\n  if (event-&gt;key() == Qt::Key_W) {\n    m_camera.fly(1 / 20., 0, 0);\n  } else if (event-&gt;key() == Qt::Key_S) {\n    m_camera.fly(-1 / 20., 0, 0);\n  } else if (event-&gt;key() == Qt::Key_A) {\n    m_camera.fly(0, 1 / 20., 0);\n  } else if (event-&gt;key() == Qt::Key_D) {\n    m_camera.fly(0, -1 / 20., 0);\n  } else if (event-&gt;key() == Qt::Key_Q) {\n    m_camera.fly(0, 0, -1 / 10.);\n  } else if (event-&gt;key() == Qt::Key_E) {\n    m_camera.fly(0, 0, 1 / 10.);\n  } else if (event-&gt;key() == Qt::Key_R) {\n    m_camera.reset_to_origin();\n  } else if (event-&gt;key() == Qt::Key_F) {\n    Extent3D bounds;\n    for (const auto&amp; layer : m_layers) {\n      bounds.grow(layer-&gt;extent() - m_camera.world_offset());\n    }\n    m_camera.zoom_to_fit(bounds);\n  }\n  update();\n}\n</code></pre>"},{"location":"blaze/gl__widget_8hpp/","title":"File gl_widget.hpp","text":"<p>FileList &gt; gui &gt; gl_widget.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QEvent&gt;</code></li> <li><code>#include &lt;QFutureWatcher&gt;</code></li> <li><code>#include &lt;QMatrix4x4&gt;</code></li> <li><code>#include &lt;QOpenGLBuffer&gt;</code></li> <li><code>#include &lt;QOpenGLFunctions&gt;</code></li> <li><code>#include &lt;QOpenGLVertexArrayObject&gt;</code></li> <li><code>#include &lt;QOpenGLWidget&gt;</code></li> <li><code>#include &lt;QtConcurrent&gt;</code></li> <li><code>#include \"gui/camera.hpp\"</code></li> <li><code>#include \"gui/layer.hpp\"</code></li> <li><code>#include \"gui/layer_renderer.hpp\"</code></li> </ul>"},{"location":"blaze/gl__widget_8hpp/#classes","title":"Classes","text":"Type Name class GLWidget <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/gl_widget.hpp</code></p>"},{"location":"blaze/gl__widget_8hpp_source/","title":"File gl_widget.hpp","text":"<p>File List &gt; gui &gt; gl_widget.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;QEvent&gt;\n#include &lt;QFutureWatcher&gt;\n#include &lt;QMatrix4x4&gt;\n#include &lt;QOpenGLBuffer&gt;\n#include &lt;QOpenGLFunctions&gt;\n#include &lt;QOpenGLVertexArrayObject&gt;\n#include &lt;QOpenGLWidget&gt;\n#include &lt;QtConcurrent&gt;\n\n#include \"gui/camera.hpp\"\n#include \"gui/layer.hpp\"\n#include \"gui/layer_renderer.hpp\"\n\nQT_FORWARD_DECLARE_CLASS(QOpenGLShaderProgram)\n\nclass GLWidget : public QOpenGLWidget, protected QOpenGLFunctions {\n  Q_OBJECT\n\n public:\n  GLWidget(QWidget* parent = nullptr);\n  ~GLWidget();\n\n  void add_layer(std::unique_ptr&lt;Layer&gt; layer) {\n    if (m_layers.empty()) {\n      m_projection = layer-&gt;projection();\n      m_camera.world_offset() = layer-&gt;extent().center();\n    } else if (m_projection != layer-&gt;projection()) {\n      throw std::runtime_error(\n          \"New layer must have same projection as existing layers. New layer has projection: \" +\n          layer-&gt;projection() + \", existing layers have projection: \" + m_projection + \".\");\n    }\n    makeCurrent();\n    m_layers.emplace_back(std::move(layer));\n\n    m_renderers.emplace_back(LayerRenderer::create(m_layers.back(), m_camera.world_offset()));\n    connect(m_layers.back().get(), &amp;Layer::data_updated, m_renderers.back().get(),\n            &amp;LayerRenderer::data_update_required);\n    connect(m_renderers.back().get(), &amp;LayerRenderer::repaint_required, this, [this] { update(); });\n    m_camera.zoom_to_fit(m_layers.back()-&gt;extent() - m_camera.world_offset());\n  }\n\n  std::vector&lt;std::shared_ptr&lt;Layer&gt;&gt; layers() const { return m_layers; }\n\n protected:\n  QSize sizeHint() const override;\n  void initializeGL() override;\n  void paintGL() override;\n  void mousePressEvent(QMouseEvent* event) override;\n  void mouseMoveEvent(QMouseEvent* event) override;\n  void wheelEvent(QWheelEvent* event) override;\n  void keyPressEvent(QKeyEvent* event) override;\n\n private:\n  QPoint m_last_mouse_pos;\n\n  QOpenGLVertexArrayObject m_vao;\n  QOpenGLBuffer m_vbo;\n\n  int m_proj_matrix_loc = 0;\n  int m_point_radius_loc = 0;\n\n  Camera m_camera;\n\n  std::vector&lt;std::shared_ptr&lt;Layer&gt;&gt; m_layers;\n  std::vector&lt;std::unique_ptr&lt;LayerRenderer&gt;&gt; m_renderers;\n\n  std::string m_projection;\n};\n</code></pre>"},{"location":"blaze/layer_8hpp/","title":"File layer.hpp","text":"<p>FileList &gt; gui &gt; layer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"las/las_file.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> <li><code>#include \"utilities/filesystem.hpp\"</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> </ul>"},{"location":"blaze/layer_8hpp/#classes","title":"Classes","text":"Type Name class LASLayer class Layer class PointLayer <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/layer.hpp</code></p>"},{"location":"blaze/layer_8hpp_source/","title":"File layer.hpp","text":"<p>File List &gt; gui &gt; layer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"las/las_file.hpp\"\n#include \"utilities/coordinate.hpp\"\n#include \"utilities/filesystem.hpp\"\n#include \"utilities/progress_tracker.hpp\"\n\nclass Layer : public QObject {\n  Q_OBJECT\n\n protected:\n  std::string m_name;\n\n signals:\n  void data_updated() const;\n\n public:\n  virtual Extent3D extent() const = 0;\n  virtual std::string projection() const = 0;\n  virtual std::string name() { return m_name; }\n  virtual ~Layer() = default;\n};\n\nclass PointLayer : public Layer {\n public:\n  virtual ~PointLayer() = default;\n};\n\nclass LASLayer : public PointLayer {\n  AsyncLASData m_las_file;\n\n public:\n  explicit LASLayer(const fs::path&amp; file, AsyncProgressTracker progress_tracker)\n      : m_las_file(file, progress_tracker, {[this] { emit this-&gt;data_updated(); }}) {\n    m_name = file.filename().string();\n  }\n\n  virtual Extent3D extent() const override { return m_las_file.bounds(); }\n  virtual std::string projection() const override { return m_las_file.projection().to_string(); }\n\n  const AsyncLASData&amp; las_file() const { return m_las_file; }\n  AsyncLASData&amp; las_file() { return m_las_file; }\n};\n</code></pre>"},{"location":"blaze/layer__renderer_8hpp/","title":"File layer_renderer.hpp","text":"<p>FileList &gt; gui &gt; layer_renderer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QOpenGLBuffer&gt;</code></li> <li><code>#include &lt;QOpenGLFunctions&gt;</code></li> <li><code>#include &lt;QOpenGLShaderProgram&gt;</code></li> <li><code>#include &lt;QOpenGLVertexArrayObject&gt;</code></li> <li><code>#include &lt;future&gt;</code></li> <li><code>#include \"gui/camera.hpp\"</code></li> <li><code>#include \"gui/layer.hpp\"</code></li> </ul>"},{"location":"blaze/layer__renderer_8hpp/#classes","title":"Classes","text":"Type Name class LASLayerRenderer class LayerRenderer"},{"location":"blaze/layer__renderer_8hpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const char * fragmentShaderSource   = <code>/* multi line expression */</code> const char * vertexShaderSource   = <code>/* multi line expression */</code>"},{"location":"blaze/layer__renderer_8hpp/#macros","title":"Macros","text":"Type Name define CHECK_SHADER_BIND (shader) <code>/* multi line expression */</code>"},{"location":"blaze/layer__renderer_8hpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"blaze/layer__renderer_8hpp/#variable-fragmentshadersource","title":"variable fragmentShaderSource","text":"<pre><code>const char* fragmentShaderSource;\n</code></pre>"},{"location":"blaze/layer__renderer_8hpp/#variable-vertexshadersource","title":"variable vertexShaderSource","text":"<pre><code>const char* vertexShaderSource;\n</code></pre>"},{"location":"blaze/layer__renderer_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"blaze/layer__renderer_8hpp/#define-check_shader_bind","title":"define CHECK_SHADER_BIND","text":"<pre><code>#define CHECK_SHADER_BIND (\n    shader\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/layer_renderer.hpp</code></p>"},{"location":"blaze/layer__renderer_8hpp_source/","title":"File layer_renderer.hpp","text":"<p>File List &gt; gui &gt; layer_renderer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;QOpenGLBuffer&gt;\n#include &lt;QOpenGLFunctions&gt;\n#include &lt;QOpenGLShaderProgram&gt;\n#include &lt;QOpenGLVertexArrayObject&gt;\n#include &lt;future&gt;\n\n#include \"gui/camera.hpp\"\n#include \"gui/layer.hpp\"\n\nclass LayerRenderer : public QObject {\n  Q_OBJECT\n\n protected:\n  bool m_data_update_required = true;\n\n signals:\n  void repaint_required() const;\n\n public:\n  virtual void render(const Camera&amp; camera) = 0;\n  virtual ~LayerRenderer() = default;\n  void data_update_required() {\n    m_data_update_required = true;\n    emit repaint_required();\n  }\n\n  static std::unique_ptr&lt;LayerRenderer&gt; create(std::shared_ptr&lt;Layer&gt; layer,\n                                               const Coordinate3D&lt;double&gt;&amp; offset);\n};\n\nstatic const char* vertexShaderSource =\n    R\"(\n        #version 330 core\n        in vec3 position;\n        uniform float point_radius;\n        uniform mat4 proj_matrix;\n        out vec4 color;\n        void main() {\n            color = vec4(1.0, 1.0, 1.0, 0.5);\n            vec4 pos = proj_matrix * vec4(position, 1.0);\n            gl_Position = pos;\n            float out_point_radius = point_radius / pos.w;\n            if (out_point_radius &lt; 1.0) {\n                out_point_radius = 1.0;\n            }\n            gl_PointSize = out_point_radius;\n        }\n      )\";\n\nstatic const char* fragmentShaderSource =\n    R\"(\n        #version 330 core\n        in vec4 color;\n        out vec4 fragColor;\n        void main() {\n            if (length(gl_PointCoord - vec2(0.5, 0.5)) &gt; 0.5) {\n                discard;\n            }\n            vec4 new_color = color * (gl_PointCoord.x + 1 - gl_PointCoord.y) * 0.6;\n            fragColor = new_color;\n        }\n      )\";\n\n#define CHECK_SHADER_BIND(shader)                                                          \\\n  if (!shader-&gt;bind()) {                                                                   \\\n    std::cout &lt;&lt; \"Error: unable to bind a shader program: \" &lt;&lt; shader-&gt;log().toStdString() \\\n              &lt;&lt; std::endl;                                                                \\\n    return;                                                                                \\\n  }\n\nclass LASLayerRenderer : public LayerRenderer {\n  std::weak_ptr&lt;LASLayer&gt; m_layer;\n\n  std::mutex m_data_mutex;\n  bool m_data_updated;\n  std::vector&lt;GLfloat&gt; m_points;\n\n  QOpenGLVertexArrayObject m_vao;\n  QOpenGLBuffer m_vbo;\n  std::unique_ptr&lt;QOpenGLShaderProgram&gt; m_shader;\n\n  int m_proj_matrix_loc = 0;\n  int m_point_radius_loc = 0;\n\n public:\n  LASLayerRenderer(std::shared_ptr&lt;LASLayer&gt; layer, const Coordinate3D&lt;double&gt;&amp; offset)\n      : m_layer(layer), m_data_updated(false) {\n    std::future&lt;void&gt; future =\n        std::async(std::launch::async, [this, layer, offset]() { load_data(layer, offset); });\n  }\n\n  void load_data(std::shared_ptr&lt;LASLayer&gt; layer, const Coordinate3D&lt;double&gt;&amp; offset) {\n    std::unique_lock&lt;std::mutex&gt; lock(layer-&gt;las_file().mutex(), std::try_to_lock);\n    if (!lock.owns_lock()) {\n      m_data_update_required = true;\n      return;\n    }\n    m_data_update_required = false;\n    m_points.reserve(layer-&gt;las_file().n_points() * 3);\n    for (size_t i = 0; i &lt; layer-&gt;las_file().n_points(); ++i) {\n      auto point = layer-&gt;las_file()[i];\n      m_points.push_back(point.x() - offset.x());\n      m_points.push_back(point.y() - offset.y());\n      m_points.push_back(point.z() - offset.z());\n    }\n    m_data_updated = true;\n    emit repaint_required();\n  }\n\n  virtual void render(const Camera&amp; camera) override {\n    if (m_data_update_required) {\n      Coordinate3D&lt;double&gt; world_offset = camera.world_offset();\n      std::future&lt;void&gt; future = std::async(std::launch::async, [this, world_offset]() {\n        if (auto layer = m_layer.lock()) {\n          load_data(layer, world_offset);\n        }\n      });\n      return;\n    }\n    if (!m_shader &amp;&amp; m_data_updated) {\n      std::unique_lock&lt;std::mutex&gt; lock(m_data_mutex, std::try_to_lock);\n      if (!lock.owns_lock()) {\n        return;\n      }\n      m_shader = std::make_unique&lt;QOpenGLShaderProgram&gt;();\n      if (!m_shader-&gt;addShaderFromSourceCode(QOpenGLShader::Vertex, vertexShaderSource)) {\n        std::cout &lt;&lt; \"Error: unable to add a vertex shader: \" &lt;&lt; m_shader-&gt;log().toStdString()\n                  &lt;&lt; std::endl;\n        return;\n      }\n      if (!m_shader-&gt;addShaderFromSourceCode(QOpenGLShader::Fragment, fragmentShaderSource)) {\n        std::cout &lt;&lt; \"Error: unable to add a fragment shader: \" &lt;&lt; m_shader-&gt;log().toStdString()\n                  &lt;&lt; std::endl;\n        return;\n      }\n      m_shader-&gt;bindAttributeLocation(\"position\", 0);\n      if (!m_shader-&gt;link()) {\n        std::cout &lt;&lt; \"Error: unable to link a shader program: \" &lt;&lt; m_shader-&gt;log().toStdString()\n                  &lt;&lt; std::endl;\n        return;\n      }\n      CHECK_SHADER_BIND(m_shader);\n\n      m_vao.create();\n      {\n        QOpenGLVertexArrayObject::Binder vaoBinder(&amp;m_vao);\n\n        m_vbo.create();\n        m_vbo.bind();\n\n        m_data_updated = false;\n        m_vbo.allocate(m_points.data(), m_points.size() * sizeof(GLfloat));\n\n        m_shader-&gt;enableAttributeArray(0);\n        m_shader-&gt;setAttributeBuffer(0, GL_FLOAT, 0, 3);\n\n        m_proj_matrix_loc = m_shader-&gt;uniformLocation(\"proj_matrix\");\n        m_point_radius_loc = m_shader-&gt;uniformLocation(\"point_radius\");\n\n        m_vbo.release();\n      }\n      m_shader-&gt;release();\n    }\n\n    CHECK_SHADER_BIND(m_shader);\n    QOpenGLFunctions* f = QOpenGLContext::currentContext()-&gt;functions();\n\n    QMatrix4x4 camera_proj = camera.proj_matrix();\n\n    CHECK_SHADER_BIND(m_shader);\n    m_shader-&gt;setUniformValue(m_proj_matrix_loc, camera_proj);\n    float point_radius = 0.1f * camera.projection_scale();\n    m_shader-&gt;setUniformValue(m_point_radius_loc, point_radius);\n\n    {\n      QOpenGLVertexArrayObject::Binder vaoBinder(&amp;m_vao);\n\n      f-&gt;glDrawArrays(GL_POINTS, 0, m_points.size() / 3);\n    }\n\n    m_shader-&gt;release();\n  }\n\n  virtual ~LASLayerRenderer() = default;\n};\n\ninline std::unique_ptr&lt;LayerRenderer&gt; LayerRenderer::create(std::shared_ptr&lt;Layer&gt; layer,\n                                                            const Coordinate3D&lt;double&gt;&amp; offset) {\n  if (auto las_layer = std::dynamic_pointer_cast&lt;LASLayer&gt;(layer)) {\n    return std::make_unique&lt;LASLayerRenderer&gt;(las_layer, offset);\n  }\n  return nullptr;\n}\n</code></pre>"},{"location":"blaze/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; gui &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include \"main_window.hpp\"</code></li> </ul>"},{"location":"blaze/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char * argv)"},{"location":"blaze/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/main.cpp</code></p>"},{"location":"blaze/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; gui &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;QApplication&gt;\n\n#include \"main_window.hpp\"\n\nint main(int argc, char* argv[]) {\n  QApplication a(argc, argv);\n\n  MainWindow window;\n  window.show();\n  return QApplication::exec();\n}\n</code></pre>"},{"location":"blaze/main__3d_8cpp/","title":"File main_3d.cpp","text":"<p>FileList &gt; gui &gt; main_3d.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QMainWindow&gt;</code></li> <li><code>#include \"gl_widget.hpp\"</code></li> <li><code>#include \"main_3d_window.hpp\"</code></li> <li><code>#include \"utilities/resources.hpp\"</code></li> </ul>"},{"location":"blaze/main__3d_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char * argv)"},{"location":"blaze/main__3d_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/main__3d_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/main_3d.cpp</code></p>"},{"location":"blaze/main__3d_8cpp_source/","title":"File main_3d.cpp","text":"<p>File List &gt; gui &gt; main_3d.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;QApplication&gt;\n#include &lt;QMainWindow&gt;\n\n#include \"gl_widget.hpp\"\n#include \"main_3d_window.hpp\"\n#include \"utilities/resources.hpp\"\n\n#ifdef _WIN32\n#include &lt;windows.h&gt;\n#endif\n\nint main(int argc, char* argv[]) {\n#ifdef _WIN32\n  AllocConsole();\n  freopen(\"CONOUT$\", \"w\", stdout);\n  freopen(\"CONOUT$\", \"w\", stderr);\n#endif\n\n  QSurfaceFormat format;\n  format.setVersion(3, 3);\n  format.setProfile(QSurfaceFormat::CoreProfile);\n#ifdef GL_DEBUG\n  format.setOption(QSurfaceFormat::DebugContext);\n#endif\n  QSurfaceFormat::setDefaultFormat(format);\n\n  std::optional&lt;fs::path&gt; file_path;\n  if (argc &gt; 1) {\n    file_path = argv[1];\n  }\n\n  QApplication a(argc, argv);\n\n  QSurfaceFormat::setDefaultFormat(QSurfaceFormat::defaultFormat());\n\n  Main3DWindow window;\n\n  window.show();\n\n  window.add_layer(std::make_unique&lt;LASLayer&gt;(\n      file_path.value_or(AssetRetriever::get_asset(\"sample.laz\")), window.add_progress_tracker()));\n\n  return QApplication::exec();\n}\n</code></pre>"},{"location":"blaze/main__3d__window_8cpp/","title":"File main_3d_window.cpp","text":"<p>FileList &gt; gui &gt; main_3d_window.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"main_3d_window.hpp\"</code></li> <li><code>#include &lt;qmessagebox.h&gt;</code></li> <li><code>#include &lt;qtreewidget.h&gt;</code></li> <li><code>#include \"ui_main_3d_window.h\"</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/main_3d_window.cpp</code></p>"},{"location":"blaze/main__3d__window_8cpp_source/","title":"File main_3d_window.cpp","text":"<p>File List &gt; gui &gt; main_3d_window.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"main_3d_window.hpp\"\n\n#include &lt;qmessagebox.h&gt;\n#include &lt;qtreewidget.h&gt;\n\n#include \"ui_main_3d_window.h\"\n#include \"utilities/progress_tracker.hpp\"\n\nMain3DWindow::Main3DWindow() : ui(std::make_unique&lt;Ui::Main3DWindow&gt;()) {\n  gl_widget = std::make_unique&lt;GLWidget&gt;(this);\n  // setCentralWidget(gl_widget.get());\n  setWindowTitle(tr(\"Blaze 3D\"));\n  try {\n    if (!QIcon::hasThemeIcon(\"list-add\")) {\n      QIcon::setThemeName(\"Humanity\");\n      QIcon::setFallbackThemeName(\"default\");\n    }\n    ui-&gt;setupUi(this);\n\n    connect(ui-&gt;actionOpen, &amp;QAction::triggered, this, &amp;Main3DWindow::open_layer_file);\n    // connect(ui-&gt;actionAbout, &amp;QAction::triggered, this, &amp;MainWindow::about);\n    ui-&gt;horizontalLayout-&gt;addWidget(gl_widget.get());\n\n  } catch (const std::exception&amp; e) {\n    QMessageBox::critical(this, \"Error\", e.what());\n    exit(1);\n  }\n}\n\nMain3DWindow::~Main3DWindow() {}\n\nAsyncProgressTracker Main3DWindow::add_progress_tracker() {\n  ProgressTrackerBar* bar = new ProgressTrackerBar(ui-&gt;statusBar);\n  ui-&gt;statusBar-&gt;addPermanentWidget(bar);\n  return bar-&gt;tracker();\n}\n\nvoid Main3DWindow::add_layer(std::unique_ptr&lt;Layer&gt; layer) {\n  QTreeWidgetItem* item = new QTreeWidgetItem(ui-&gt;treeWidget);\n  item-&gt;setText(0, QString::fromStdString(layer-&gt;name()));\n  ui-&gt;treeWidget-&gt;addTopLevelItem(item);\n  ui-&gt;treeWidget-&gt;resizeColumnToContents(0);\n  gl_widget-&gt;add_layer(std::move(layer));\n}\n\nvoid Main3DWindow::open_layer_file() {\n  std::string filename =\n      QFileDialog::getOpenFileName(this, \"Open LAS file\", \"\", \"LIDAR Point Clouds (*.las, *.laz)\")\n          .toStdString();\n  add_layer(std::make_unique&lt;LASLayer&gt;(filename, add_progress_tracker()));\n}\n</code></pre>"},{"location":"blaze/main__3d__window_8hpp/","title":"File main_3d_window.hpp","text":"<p>FileList &gt; gui &gt; main_3d_window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QMainWindow&gt;</code></li> <li><code>#include &lt;QProgressBar&gt;</code></li> <li><code>#include \"gl_widget.hpp\"</code></li> </ul>"},{"location":"blaze/main__3d__window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace Ui"},{"location":"blaze/main__3d__window_8hpp/#classes","title":"Classes","text":"Type Name class Main3DWindow class ProgressTrackerBar <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/main_3d_window.hpp</code></p>"},{"location":"blaze/main__3d__window_8hpp_source/","title":"File main_3d_window.hpp","text":"<p>File List &gt; gui &gt; main_3d_window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;QMainWindow&gt;\n#include &lt;QProgressBar&gt;\n\n#include \"gl_widget.hpp\"\n\nQT_BEGIN_NAMESPACE\nnamespace Ui {\nclass Main3DWindow;\n}\nQT_END_NAMESPACE\n\nclass ProgressTrackerBar : public QProgressBar, public ProgressObserver {\n  AsyncProgressTracker m_progress_tracker;\n  bool m_tracker_obtained = false;\n\n public:\n  explicit ProgressTrackerBar(QWidget* parent) : QProgressBar(parent), m_progress_tracker() {\n    setMinimum(0);\n    setMaximum(1000);\n  }\n\n  virtual void update_progress(double progress) override { setValue(progress * 1000); }\n\n  virtual void text_update(const std::string&amp; text, int depth = 0) override {\n    (void)text;\n    (void)depth;\n  }\n\n  AsyncProgressTracker tracker() {\n    Assert(!m_tracker_obtained);\n    m_tracker_obtained = true;\n    return m_progress_tracker;\n  }\n};\n\nclass Main3DWindow : public QMainWindow {\n  Q_OBJECT\n\n public:\n  Main3DWindow();\n  ~Main3DWindow();\n\n  void add_layer(std::unique_ptr&lt;Layer&gt; layer);\n\n  AsyncProgressTracker add_progress_tracker();\n\n private slots:\n  void open_layer_file();\n\n private:\n  std::unique_ptr&lt;Ui::Main3DWindow&gt; ui;\n  std::unique_ptr&lt;GLWidget&gt; gl_widget;\n};\n</code></pre>"},{"location":"blaze/main__window_8cpp/","title":"File main_window.cpp","text":"<p>FileList &gt; gui &gt; main_window.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"main_window.hpp\"</code></li> <li><code>#include &lt;QtConcurrent&gt;</code></li> <li><code>#include &lt;QtWidgets&gt;</code></li> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"progress_box.hpp\"</code></li> <li><code>#include \"run.hpp\"</code></li> <li><code>#include \"ui_main_window.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/main_window.cpp</code></p>"},{"location":"blaze/main__window_8cpp_source/","title":"File main_window.cpp","text":"<p>File List &gt; gui &gt; main_window.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"main_window.hpp\"\n\n#include &lt;QtConcurrent&gt;\n#include &lt;QtWidgets&gt;\n\n#include \"config_input/config_input.hpp\"\n#include \"progress_box.hpp\"\n#include \"run.hpp\"\n#include \"ui_main_window.h\"\n\nMainWindow::MainWindow() : ui(std::make_unique&lt;Ui::MainWindow&gt;()) {\n  try {\n    if (!QIcon::hasThemeIcon(\"list-add\")) {\n      QIcon::setThemeName(\"Humanity\");\n      QIcon::setFallbackThemeName(\"default\");\n    }\n    ui-&gt;setupUi(this);\n\n    connect(ui-&gt;runButton, &amp;QPushButton::clicked, this, &amp;MainWindow::run_blaze);\n    connect(ui-&gt;actionOpen, &amp;QAction::triggered, this,\n            [this] { ui-&gt;config_editor-&gt;open_config_file(); });\n    connect(ui-&gt;actionSaveAs, &amp;QAction::triggered, this,\n            [this] { ui-&gt;config_editor-&gt;save_config_file(); });\n    connect(ui-&gt;actionAbout, &amp;QAction::triggered, this, &amp;MainWindow::about);\n    connect(ui-&gt;config_editor, &amp;ConfigEditor::config_changed,\n            [this] { ui-&gt;runButton-&gt;setEnabled(ui-&gt;config_editor-&gt;is_valid()); });\n\n    ui-&gt;runButton-&gt;setEnabled(ui-&gt;config_editor-&gt;is_valid());\n\n  } catch (const std::exception&amp; e) {\n    QMessageBox::critical(this, \"Error\", e.what());\n    exit(1);\n  }\n}\n\nMainWindow::~MainWindow() {}\n\nvoid MainWindow::about() {\n  QMessageBox::about(this, \"About Blaze\",\n                     QString(\"This is the Blaze LIDAR mapping tool. It is free for non-commercial \"\n                             \"nav-sport mapping only.&lt;br&gt;&lt;br&gt;\"\n                             \"Please contact us at &lt;a \"\n                             \"href=\\\"mailto:trailblaze.software@gmail.com\\\"&gt;trailblaze.software@\"\n                             \"gmail.com&lt;/a&gt; for commercial licensing options.&lt;br&gt;&lt;br&gt;\"\n                             \"Version: \" BLAZE_VERSION \"&lt;br&gt;\"\n                             \"Commit hash: \" GIT_COMMIT_HASH \"&lt;br&gt;&lt;br&gt;\"\n                             \"&lt;a href=\\\"https://github.com/Trailblaze-Software/Blaze\\\"&gt;Source \"\n                             \"code&lt;/a&gt; available under the AGPLv3 license.&lt;br&gt;\"));\n}\n\nvoid MainWindow::run_blaze() {\n  ProgressBox* message_box = new ProgressBox(this);\n  message_box-&gt;show();\n  const Config&amp; config = ui-&gt;config_editor-&gt;get_config();\n  message_box-&gt;start_task(\n      [&amp;config, message_box] {\n        run_with_config(config, std::vector&lt;fs::path&gt;(), ProgressTracker(message_box));\n      },\n      [&amp;config] {\n        QDialog* dialog = new QDialog();\n        dialog-&gt;setWindowTitle(\"Blaze processing done!\");\n        QVBoxLayout* layout = new QVBoxLayout();\n        dialog-&gt;setLayout(layout);\n        QLabel* label = new QLabel(\"Processing complete!\");\n        layout-&gt;addWidget(label);\n        if (config.processing_steps.contains(ProcessingStep::Combine)) {\n          QLabel* label2 =\n              new QLabel(\"The combined output is located at: \" +\n                         QString::fromStdString((config.output_path() / \"combined\").string()));\n          layout-&gt;addWidget(label2);\n          QImage image((config.output_path() / \"combined\" / \"final_img.tif\").string().c_str());\n          if (image.isNull()) {\n            std::cerr &lt;&lt; \"Failed to load image from \"\n                      &lt;&lt; (config.output_path() / \"combined\" / \"final_img.tif\") &lt;&lt; std::endl;\n          } else {\n            QScrollArea* scroll_area = new QScrollArea();\n            layout-&gt;addWidget(scroll_area);\n\n            QLabel* image_label = new QLabel();\n            image_label-&gt;setPixmap(QPixmap::fromImage(image));\n            scroll_area-&gt;setWidget(image_label);\n            scroll_area-&gt;setWidgetResizable(true);\n          }\n        }\n        QPushButton* button = new QPushButton(\"OK\");\n        layout-&gt;addWidget(button);\n        connect(button, &amp;QPushButton::clicked, dialog, &amp;QDialog::accept);\n        dialog-&gt;exec();\n      });\n}\n</code></pre>"},{"location":"blaze/main__window_8hpp/","title":"File main_window.hpp","text":"<p>FileList &gt; gui &gt; main_window.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QMainWindow&gt;</code></li> </ul>"},{"location":"blaze/main__window_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace Ui"},{"location":"blaze/main__window_8hpp/#classes","title":"Classes","text":"Type Name class MainWindow <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/main_window.hpp</code></p>"},{"location":"blaze/main__window_8hpp_source/","title":"File main_window.hpp","text":"<p>File List &gt; gui &gt; main_window.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;QMainWindow&gt;\n\nQT_BEGIN_NAMESPACE\nnamespace Ui {\nclass MainWindow;\n}\nQT_END_NAMESPACE\n\nclass MainWindow : public QMainWindow {\n  Q_OBJECT\n\n public:\n  MainWindow();\n  ~MainWindow();\n\n private slots:\n  void about();\n  void run_blaze();\n\n private:\n  std::unique_ptr&lt;Ui::MainWindow&gt; ui;\n};\n</code></pre>"},{"location":"blaze/progress__box_8cpp/","title":"File progress_box.cpp","text":"<p>FileList &gt; gui &gt; progress_box.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"progress_box.hpp\"</code></li> <li><code>#include &lt;QException&gt;</code></li> <li><code>#include &lt;QFutureWatcher&gt;</code></li> <li><code>#include &lt;QMessageBox&gt;</code></li> <li><code>#include &lt;QtConcurrent&gt;</code></li> <li><code>#include \"ui_progress_box.h\"</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> </ul>"},{"location":"blaze/progress__box_8cpp/#classes","title":"Classes","text":"Type Name class TaskException <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/progress_box.cpp</code></p>"},{"location":"blaze/progress__box_8cpp_source/","title":"File progress_box.cpp","text":"<p>File List &gt; gui &gt; progress_box.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"progress_box.hpp\"\n\n#include &lt;QException&gt;\n#include &lt;QFutureWatcher&gt;\n#include &lt;QMessageBox&gt;\n#include &lt;QtConcurrent&gt;\n\n#include \"ui_progress_box.h\"\n#include \"utilities/progress_tracker.hpp\"\n\nvoid ProgressBox::abort() { done(1); }\n\nProgressBox::ProgressBox(QWidget* parent) : QDialog(parent), ui(new Ui::ProgressBox) {\n  ui-&gt;setupUi(this);\n  setWindowFlag(Qt::WindowCloseButtonHint, false);\n  connect(this, &amp;ProgressBox::send_progress_bars, this, &amp;ProgressBox::receive_progress_bars);\n  connect(this, &amp;ProgressBox::send_status_text, this, &amp;ProgressBox::receive_status_text);\n}\n\nvoid ProgressBox::receive_progress_bars(std::vector&lt;double&gt; progress) {\n  for (size_t i = 0; i &lt; progress.size(); i++) {\n    if (i &gt;= m_progress.size()) {\n      m_progress.emplace_back(\n          std::pair&lt;QProgressBar*, QLabel*&gt;{new QProgressBar(ui-&gt;scrollAreaWidgetContents_2),\n                                            new QLabel(ui-&gt;scrollAreaWidgetContents_2)});\n      ui-&gt;verticalLayout_3-&gt;addWidget(m_progress.back().first);\n      m_progress.back().first-&gt;setMaximum(1000);\n      m_progress.back().second-&gt;setWordWrap(true);\n      ui-&gt;verticalLayout_3-&gt;addWidget(m_progress.back().second);\n    }\n    m_progress[i].first-&gt;setValue(progress[i] * 1000);\n  }\n  for (size_t i = progress.size(); i &lt; m_progress.size(); i++) {\n    ui-&gt;verticalLayout_3-&gt;removeWidget(m_progress[i].first);\n    delete m_progress[i].first;\n    delete m_progress[i].second;\n  }\n  m_progress.resize(progress.size());\n}\n\nvoid ProgressBox::receive_status_text(std::string text, int depth) {\n  if ((unsigned int)(depth - 1) &lt; m_progress.size()) {\n    m_progress[depth - 1].second-&gt;setText(QString::fromStdString(text));\n  }\n}\n\nvoid ProgressBox::update_progress(double _) {\n  (void)_;\n  std::vector&lt;double&gt; progress;\n  ProgressTracker* child = this-&gt;child();\n  while (child != nullptr) {\n    progress.push_back(child-&gt;proportion());\n    child = child-&gt;child();\n  }\n  emit send_progress_bars(std::move(progress));\n}\n\nvoid ProgressBox::text_update(const std::string&amp; text, int depth) {\n  emit send_status_text(text, depth);\n}\n\nclass TaskException : public QException {\n  std::string m_what;\n\n public:\n  TaskException(const char* what) : QException(), m_what(what) {}\n  void raise() const { throw *this; }\n  QException* clone() const { return new TaskException(*this); }\n  inline virtual const char* what() const noexcept { return m_what.c_str(); }\n};\n\nvoid ProgressBox::start_task(std::function&lt;void()&gt; task, std::function&lt;void()&gt; on_finish) {\n  QFutureWatcher&lt;int&gt;* watcher = new QFutureWatcher&lt;int&gt;(this);\n  connect(watcher, &amp;QFutureWatcher&lt;int&gt;::finished, this, [this, watcher, on_finish] {\n    if (watcher-&gt;future().isCanceled()) {\n      try {\n        watcher-&gt;future().result();\n      } catch (TaskException&amp; e) {\n        QMessageBox::critical(this, \"Error running task\", e.what());\n      }\n      this-&gt;done(1);\n    } else {\n      this-&gt;done(0);\n      on_finish();\n    }\n  });\n  watcher-&gt;setFuture(QtConcurrent::run([task] {\n    try {\n      task();\n    } catch (std::exception&amp; e) {\n      throw TaskException(e.what());\n    }\n    return 0;\n  }));\n}\n</code></pre>"},{"location":"blaze/progress__box_8hpp/","title":"File progress_box.hpp","text":"<p>FileList &gt; gui &gt; progress_box.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QDialog&gt;</code></li> <li><code>#include &lt;QLayout&gt;</code></li> <li><code>#include &lt;QProgressBar&gt;</code></li> <li><code>#include \"ui_progress_box.h\"</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> </ul>"},{"location":"blaze/progress__box_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace Ui"},{"location":"blaze/progress__box_8hpp/#classes","title":"Classes","text":"Type Name class ProgressBox <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/gui/progress_box.hpp</code></p>"},{"location":"blaze/progress__box_8hpp_source/","title":"File progress_box.hpp","text":"<p>File List &gt; gui &gt; progress_box.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;QDialog&gt;\n#include &lt;QLayout&gt;\n#include &lt;QProgressBar&gt;\n\n#include \"ui_progress_box.h\"\n#include \"utilities/progress_tracker.hpp\"\n\nQT_BEGIN_NAMESPACE\nclass QLabel;\nnamespace Ui {\nclass ProgressBox;\n}\nQT_END_NAMESPACE\n\nclass ProgressBox : public QDialog, public ProgressObserver {\n  Q_OBJECT\n\n  std::unique_ptr&lt;Ui::ProgressBox&gt; ui;\n\n  std::vector&lt;std::pair&lt;QProgressBar*, QLabel*&gt;&gt; m_progress;\n\n private slots:\n  void receive_progress_bars(std::vector&lt;double&gt; progress);\n  void receive_status_text(std::string text, int depth);\n\n  void abort();\n\n signals:\n  void send_progress_bars(std::vector&lt;double&gt; progress);\n  void send_status_text(std::string text, int depth);\n\n public:\n  explicit ProgressBox(QWidget* parent = nullptr);\n\n  void update_progress(double proportion) override;\n  void text_update(const std::string&amp; text, int depth = 0) override;\n\n  void start_task(std::function&lt;void()&gt; task, std::function&lt;void()&gt; on_finish = [] {});\n\n private:\n};\n</code></pre>"},{"location":"blaze/dir_c85d3e3c5052e9ad9ce18c6863244a25/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib","text":"<p>FileList &gt; lib</p>"},{"location":"blaze/dir_c85d3e3c5052e9ad9ce18c6863244a25/#directories","title":"Directories","text":"Type Name dir assert dir cliff dir config_input dir contour dir dxf dir grid dir io dir isom dir las dir printing dir tif dir utilities dir vegetation <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/</code></p>"},{"location":"blaze/dir_d1185b0cdad395d5facacbcb4739e037/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/assert","text":"<p>FileList &gt; assert</p>"},{"location":"blaze/dir_d1185b0cdad395d5facacbcb4739e037/#files","title":"Files","text":"Type Name file assert.hpp file gdal_assert.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/assert/</code></p>"},{"location":"blaze/assert_8hpp/","title":"File assert.hpp","text":"<p>FileList &gt; assert &gt; assert.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;experimental/source_location&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"printing/to_string.hpp\"</code></li> </ul>"},{"location":"blaze/assert_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace std"},{"location":"blaze/assert_8hpp/#public-functions","title":"Public Functions","text":"Type Name void _Assert (bool condition, const std::string &amp; condition_str, const std::optional&lt; std::string &gt; &amp; message, const std::source_location &amp; loc=std::source_location::current())  void _AssertBinOp (const A &amp; a, const B &amp; b, const std::string &amp; a_str, const std::string &amp; b_str, bool result, const std::string &amp; op, const std::string &amp; nop, const std::source_location &amp; loc=std::source_location::current())  void unreachable ()"},{"location":"blaze/assert_8hpp/#macros","title":"Macros","text":"Type Name define Assert (condition, ...) <code>[**if**](classCoordinate2D.md) (!([**condition**](classCoordinate2D.md))) \\_Assert([**condition**](classCoordinate2D.md), #[**condition**](classCoordinate2D.md), std::optional&amp;lt;std::string&amp;gt;([**\\_\\_VA\\_ARGS\\_\\_**](classCoordinate2D.md)));</code> define AssertBinOp (a, b, op, nop) <code>[**if**](classCoordinate2D.md) (!(([**a**](classCoordinate2D.md))[**op**](classCoordinate2D.md)([**b**](classCoordinate2D.md)))) \\_AssertBinOp([**a**](classCoordinate2D.md), [**b**](classCoordinate2D.md), #[**a**](classCoordinate2D.md), #[**b**](classCoordinate2D.md), [**a**](classCoordinate2D.md) [**op**](classCoordinate2D.md) [**b**](classCoordinate2D.md), #[**op**](classCoordinate2D.md), #[**nop**](classCoordinate2D.md))</code> define AssertEQ (expr, val) <code>AssertBinOp([**expr**](classCoordinate2D.md), [**val**](classCoordinate2D.md), ==, !=)</code> define AssertGE (expr, val) <code>AssertBinOp([**expr**](classCoordinate2D.md), [**val**](classCoordinate2D.md), &amp;gt;=, &amp;lt;)</code> define AssertGT (expr, val) <code>AssertBinOp([**expr**](classCoordinate2D.md), [**val**](classCoordinate2D.md), &amp;gt;, &amp;lt;=)</code> define AssertLE (expr, val) <code>AssertBinOp([**expr**](classCoordinate2D.md), [**val**](classCoordinate2D.md), &amp;lt;=, &amp;gt;)</code> define AssertNE (expr, val) <code>AssertBinOp([**expr**](classCoordinate2D.md), [**val**](classCoordinate2D.md), !=, ==)</code> define Fail (...) <code>/* multi line expression */</code> define HAS_BUILTIN (x) <code>[**\\_\\_has\\_builtin**](classCoordinate2D.md)(x)</code> define Unimplemented (...) <code>Assert([**false**](classCoordinate2D.md), \"Unimplemented\");</code>"},{"location":"blaze/assert_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/assert_8hpp/#function-_assert","title":"function _Assert","text":"<pre><code>inline void _Assert (\n    bool condition,\n    const std::string &amp; condition_str,\n    const std::optional&lt; std::string &gt; &amp; message,\n    const std::source_location &amp; loc=std::source_location::current()\n) \n</code></pre>"},{"location":"blaze/assert_8hpp/#function-_assertbinop","title":"function _AssertBinOp","text":"<pre><code>template&lt;typename  A, typename  B&gt;\ninline void _AssertBinOp (\n    const  A &amp; a,\n    const  B &amp; b,\n    const std::string &amp; a_str,\n    const std::string &amp; b_str,\n    bool result,\n    const std::string &amp; op,\n    const std::string &amp; nop,\n    const std::source_location &amp; loc=std::source_location::current()\n) \n</code></pre>"},{"location":"blaze/assert_8hpp/#function-unreachable","title":"function unreachable","text":"<pre><code>inline void unreachable () \n</code></pre>"},{"location":"blaze/assert_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"blaze/assert_8hpp/#define-assert","title":"define Assert","text":"<pre><code>#define Assert (\n    condition,\n    ...\n) `if (!( condition )) _Assert( condition , # condition , std::optional&lt;std::string&gt;( __VA_ARGS__ ));`\n</code></pre>"},{"location":"blaze/assert_8hpp/#define-assertbinop","title":"define AssertBinOp","text":"<pre><code>#define AssertBinOp (\n    a,\n    b,\n    op,\n    nop\n) `if (!(( a ) op ( b ))) _AssertBinOp( a , b , # a , # b , a  op  b , # op , # nop )`\n</code></pre>"},{"location":"blaze/assert_8hpp/#define-asserteq","title":"define AssertEQ","text":"<pre><code>#define AssertEQ (\n    expr,\n    val\n) `AssertBinOp( expr , val , ==, !=)`\n</code></pre>"},{"location":"blaze/assert_8hpp/#define-assertge","title":"define AssertGE","text":"<pre><code>#define AssertGE (\n    expr,\n    val\n) `AssertBinOp( expr , val , &gt;=, &lt;)`\n</code></pre>"},{"location":"blaze/assert_8hpp/#define-assertgt","title":"define AssertGT","text":"<pre><code>#define AssertGT (\n    expr,\n    val\n) `AssertBinOp( expr , val , &gt;, &lt;=)`\n</code></pre>"},{"location":"blaze/assert_8hpp/#define-assertle","title":"define AssertLE","text":"<pre><code>#define AssertLE (\n    expr,\n    val\n) `AssertBinOp( expr , val , &lt;=, &gt;)`\n</code></pre>"},{"location":"blaze/assert_8hpp/#define-assertne","title":"define AssertNE","text":"<pre><code>#define AssertNE (\n    expr,\n    val\n) `AssertBinOp( expr , val , !=, ==)`\n</code></pre>"},{"location":"blaze/assert_8hpp/#define-fail","title":"define Fail","text":"<pre><code>#define Fail (\n    ...\n) `/* multi line expression */`\n</code></pre>"},{"location":"blaze/assert_8hpp/#define-has_builtin","title":"define HAS_BUILTIN","text":"<pre><code>#define HAS_BUILTIN (\n    x\n) `__has_builtin (x)`\n</code></pre>"},{"location":"blaze/assert_8hpp/#define-unimplemented","title":"define Unimplemented","text":"<pre><code>#define Unimplemented (\n    ...\n) `Assert( false , \"Unimplemented\");`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/assert/assert.hpp</code></p>"},{"location":"blaze/assert_8hpp_source/","title":"File assert.hpp","text":"<p>File List &gt; assert &gt; assert.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#ifndef _MSC_VER\n#define HAS_BUILTIN(x) __has_builtin(x)\n#else\n#define HAS_BUILTIN(x) 0\n#endif\n\n#include &lt;iostream&gt;\n#include &lt;optional&gt;\n#if defined(_MSC_VER) || HAS_BUILTIN(__builtin_source_location)\n#include &lt;source_location&gt;\n#else\n#include &lt;experimental/source_location&gt;\nnamespace std {\nusing source_location = std::experimental::source_location;\n}\n#endif\n\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\n#include \"printing/to_string.hpp\"\n\n[[noreturn]] inline void unreachable() {\n  // Uses compiler specific extensions if possible.\n  // Even if no extension is used, undefined behavior is still raised by\n  // an empty function body and the noreturn attribute.\n#if defined(_MSC_VER) &amp;&amp; !defined(__clang__)  // MSVC\n  __assume(false);\n#else  // GCC, Clang\n  __builtin_unreachable();\n#endif\n}\n\n#define Assert(condition, ...) \\\n  if (!(condition)) _Assert(condition, #condition, std::optional&lt;std::string&gt;(__VA_ARGS__));\n\ninline void _Assert(bool condition, const std::string&amp; condition_str,\n                    const std::optional&lt;std::string&gt;&amp; message,\n                    const std::source_location&amp; loc = std::source_location::current()) {\n  if (!condition) {\n    std::stringstream ss;\n    ss &lt;&lt; \"Blaze assertion failed: \" &lt;&lt; condition_str &lt;&lt; (message ? \": \" + *message : \"\")\n       &lt;&lt; \"\\n in \" &lt;&lt; loc.function_name() &lt;&lt; \" at \" &lt;&lt; loc.file_name() &lt;&lt; \":\" &lt;&lt; loc.line()\n       &lt;&lt; std::endl;\n    std::cerr &lt;&lt; ss.str();\n    throw std::runtime_error(ss.str());\n  }\n}\n\n#define Fail(...)             \\\n  Assert(false, __VA_ARGS__); \\\n  unreachable()\n\n#define Unimplemented(...) Assert(false, \"Unimplemented\");\n\ntemplate &lt;typename A, typename B&gt;\ninline void _AssertBinOp(const A&amp; a, const B&amp; b, const std::string&amp; a_str, const std::string&amp; b_str,\n                         bool result, const std::string&amp; op, const std::string&amp; nop,\n                         const std::source_location&amp; loc = std::source_location::current()) {\n  if (!result) {\n    std::stringstream ss;\n    ss &lt;&lt; a &lt;&lt; \" \" &lt;&lt; nop &lt;&lt; \" \" &lt;&lt; b;\n    _Assert(result, a_str + \" \" + op + \" \" + b_str, ss.str(), loc);\n  }\n}\n\n#define AssertBinOp(a, b, op, nop) \\\n  if (!((a)op(b))) _AssertBinOp(a, b, #a, #b, a op b, #op, #nop)\n#define AssertGE(expr, val) AssertBinOp(expr, val, &gt;=, &lt;)\n#define AssertLE(expr, val) AssertBinOp(expr, val, &lt;=, &gt;)\n#define AssertGT(expr, val) AssertBinOp(expr, val, &gt;, &lt;=)\n#define AssertEQ(expr, val) AssertBinOp(expr, val, ==, !=)\n#define AssertNE(expr, val) AssertBinOp(expr, val, !=, ==)\n</code></pre>"},{"location":"blaze/gdal__assert_8hpp/","title":"File gdal_assert.hpp","text":"<p>FileList &gt; assert &gt; gdal_assert.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cpl_error.h&gt;</code></li> <li><code>#include &lt;source_location&gt;</code></li> <li><code>#include \"assert/assert.hpp\"</code></li> <li><code>#include \"ogr_core.h\"</code></li> </ul>"},{"location":"blaze/gdal__assert_8hpp/#public-functions","title":"Public Functions","text":"Type Name void _GDALAssert (CPLErr expr, const std::string &amp; expr_string, const std::source_location &amp; loc=std::source_location::current())  void _GDALAssert (OGRErr expr, const std::string &amp; expr_string, const std::source_location &amp; loc=std::source_location::current())"},{"location":"blaze/gdal__assert_8hpp/#macros","title":"Macros","text":"Type Name define GDALAssert (expr) <code>\\_GDALAssert([**expr**](classCoordinate2D.md), #[**expr**](classCoordinate2D.md))</code>"},{"location":"blaze/gdal__assert_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/gdal__assert_8hpp/#function-_gdalassert","title":"function _GDALAssert","text":"<pre><code>inline void _GDALAssert (\n    CPLErr expr,\n    const std::string &amp; expr_string,\n    const std::source_location &amp; loc=std::source_location::current()\n) \n</code></pre>"},{"location":"blaze/gdal__assert_8hpp/#function-_gdalassert_1","title":"function _GDALAssert","text":"<pre><code>inline void _GDALAssert (\n    OGRErr expr,\n    const std::string &amp; expr_string,\n    const std::source_location &amp; loc=std::source_location::current()\n) \n</code></pre>"},{"location":"blaze/gdal__assert_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"blaze/gdal__assert_8hpp/#define-gdalassert","title":"define GDALAssert","text":"<pre><code>#define GDALAssert (\n    expr\n) `_GDALAssert( expr , # expr )`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/assert/gdal_assert.hpp</code></p>"},{"location":"blaze/gdal__assert_8hpp_source/","title":"File gdal_assert.hpp","text":"<p>File List &gt; assert &gt; gdal_assert.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cpl_error.h&gt;\n\n#include &lt;source_location&gt;\n\n#include \"assert/assert.hpp\"\n#include \"ogr_core.h\"\n#define GDALAssert(expr) _GDALAssert(expr, #expr)\n\ninline void _GDALAssert(CPLErr expr, const std::string&amp; expr_string,\n                        const std::source_location&amp; loc = std::source_location::current()) {\n  if (expr != CE_None)\n    _Assert(expr == CE_None, expr_string, \"GDAL result: \" + std::to_string(expr), loc);\n}\n\ninline void _GDALAssert(OGRErr expr, const std::string&amp; expr_string,\n                        const std::source_location&amp; loc = std::source_location::current()) {\n  if (expr != OGRERR_NONE)\n    _Assert(expr == CE_None, expr_string, \"OGRERR result: \" + std::to_string(expr), loc);\n}\n</code></pre>"},{"location":"blaze/dir_e3f0ccf1ba301864d78f3797f9c90139/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/cliff","text":"<p>FileList &gt; cliff</p>"},{"location":"blaze/dir_e3f0ccf1ba301864d78f3797f9c90139/#files","title":"Files","text":"Type Name file cliff.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/cliff/</code></p>"},{"location":"blaze/cliff_8hpp/","title":"File cliff.hpp","text":"<p>FileList &gt; cliff &gt; cliff.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"grid/grid.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> </ul>"},{"location":"blaze/cliff_8hpp/#classes","title":"Classes","text":"Type Name class ContourPoint <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/cliff/cliff.hpp</code></p>"},{"location":"blaze/cliff_8hpp_source/","title":"File cliff.hpp","text":"<p>File List &gt; cliff &gt; cliff.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;memory&gt;\n\n#include \"grid/grid.hpp\"\n#include \"utilities/coordinate.hpp\"\n\nclass ContourPoint : public Coordinate2D&lt;double&gt; {\n  double m_height;\n  std::shared_ptr&lt;ContourPoint&gt; m_next;\n  std::shared_ptr&lt;ContourPoint&gt; m_prev;\n  std::shared_ptr&lt;ContourPoint&gt; m_down;\n  std::shared_ptr&lt;ContourPoint&gt; m_up;\n  double m_slope;\n\n public:\n  ContourPoint(double x, double y, double height)\n      : Coordinate2D&lt;double&gt;(x, y), m_height(height), m_slope(0) {}\n\n  void set_next(std::shared_ptr&lt;ContourPoint&gt; next) { m_next = next; }\n  void set_previous(std::shared_ptr&lt;ContourPoint&gt; prev) { m_prev = prev; }\n\n  void find_up_down(const GeoGrid&lt;std::vector&lt;std::shared_ptr&lt;ContourPoint&gt;&gt;&gt;&amp; point_grid) {\n    Coordinate2D&lt;size_t&gt; pixel = point_grid.transform().projection_to_pixel(*this);\n\n    double closest_down = std::numeric_limits&lt;double&gt;::max();\n    double closest_up = std::numeric_limits&lt;double&gt;::max();\n\n    for (int dx : {-1, 0, 1}) {\n      for (int dy : {-1, 0, 1}) {\n        Coordinate2D&lt;size_t&gt; neighbor_pixel = pixel + Coordinate2D&lt;size_t&gt;(dx, dy);\n        if (point_grid.in_bounds(neighbor_pixel)) {\n          for (const std::shared_ptr&lt;ContourPoint&gt;&amp; neighbor_point : point_grid[neighbor_pixel]) {\n            if (neighbor_point-&gt;height() &lt; m_height) {\n              double dist = (*this - *neighbor_point).magnitude_sqd();\n              if (dist &lt; closest_down) {\n                closest_down = dist;\n                m_down = neighbor_point;\n              }\n            } else if (neighbor_point-&gt;height() &gt; m_height) {\n              double dist = (*this - *neighbor_point).magnitude_sqd();\n              if (dist &lt; closest_up) {\n                closest_up = dist;\n                m_up = neighbor_point;\n              }\n            }\n          }\n        }\n      }\n    }\n    if (m_down &amp;&amp; m_up) {\n      m_slope = (m_up-&gt;height() - m_down-&gt;height()) / (*m_up - *m_down).magnitude();\n    }\n  }\n\n  double height() const { return m_height; }\n  double slope() const { return m_slope; }\n};\n</code></pre>"},{"location":"blaze/dir_7e7c57be6e217d4e927a2ff8d648cb71/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/config_input","text":"<p>FileList &gt; config_input</p>"},{"location":"blaze/dir_7e7c57be6e217d4e927a2ff8d648cb71/#files","title":"Files","text":"Type Name file config_input.cpp file config_input.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/</code></p>"},{"location":"blaze/config__input_8cpp/","title":"File config_input.cpp","text":"<p>FileList &gt; config_input &gt; config_input.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"config_input.hpp\"</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"assert/assert.hpp\"</code></li> <li><code>#include &lt;nlohmann/json.hpp&gt;</code></li> </ul>"},{"location":"blaze/config__input_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace nlohmann"},{"location":"blaze/config__input_8cpp/#classes","title":"Classes","text":"Type Name struct adl_serializer&lt; BlockingThresholdColorPair &gt; &lt;&gt; struct adl_serializer&lt; BuildingsConfig &gt; &lt;&gt; struct adl_serializer&lt; CMYKColor &gt; &lt;&gt; struct adl_serializer&lt; CanopyConfig &gt; &lt;&gt; struct adl_serializer&lt; ColorVariant &gt; &lt;&gt; struct adl_serializer&lt; ContourConfig &gt; &lt;&gt; struct adl_serializer&lt; ContourConfigs &gt; &lt;&gt; struct adl_serializer&lt; GridConfig &gt; &lt;&gt; struct adl_serializer&lt; GroundConfig &gt; &lt;&gt; struct adl_serializer&lt; RGBColor &gt; &lt;&gt; struct adl_serializer&lt; RenderConfig &gt; &lt;&gt; struct adl_serializer&lt; VegeConfig &gt; &lt;&gt; struct adl_serializer&lt; VegeHeightConfig &gt; &lt;&gt; struct adl_serializer&lt; WaterConfig &gt; &lt;&gt; struct adl_serializer&lt; WaterConfigs &gt; &lt;&gt;"},{"location":"blaze/config__input_8cpp/#public-types","title":"Public Types","text":"Type Name typedef nlohmann::json json"},{"location":"blaze/config__input_8cpp/#public-functions","title":"Public Functions","text":"Type Name std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const Config &amp; config)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const ProcessingStep &amp; step)"},{"location":"blaze/config__input_8cpp/#macros","title":"Macros","text":"Type Name define JSON_DIAGNOSTICS <code>1</code> define SERIALIZE_ENUM_STRICT (ENUM_TYPE, ...) <code>/* multi line expression */</code>"},{"location":"blaze/config__input_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/config__input_8cpp/#typedef-json","title":"typedef json","text":"<pre><code>using json =  nlohmann::json;\n</code></pre>"},{"location":"blaze/config__input_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/config__input_8cpp/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const  Config &amp; config\n) \n</code></pre>"},{"location":"blaze/config__input_8cpp/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const ProcessingStep &amp; step\n) \n</code></pre>"},{"location":"blaze/config__input_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"blaze/config__input_8cpp/#define-json_diagnostics","title":"define JSON_DIAGNOSTICS","text":"<pre><code>#define JSON_DIAGNOSTICS `1`\n</code></pre>"},{"location":"blaze/config__input_8cpp/#define-serialize_enum_strict","title":"define SERIALIZE_ENUM_STRICT","text":"<pre><code>#define SERIALIZE_ENUM_STRICT (\n    ENUM_TYPE,\n    ...\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.cpp</code></p>"},{"location":"blaze/config__input_8cpp_source/","title":"File config_input.cpp","text":"<p>File List &gt; config_input &gt; config_input.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"config_input.hpp\"\n\n#include &lt;fstream&gt;\n\n#include \"assert/assert.hpp\"\n\n#define JSON_DIAGNOSTICS 1\n#ifdef _MSC_VER\n#pragma warning(push, 0)\n#endif\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Warray-bounds\"\n#include &lt;nlohmann/json.hpp&gt;\n#pragma GCC diagnostic pop\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\nusing json = nlohmann::json;\n\n#define SERIALIZE_ENUM_STRICT(ENUM_TYPE, ...)                                                    \\\n  template &lt;typename BasicJsonType&gt;                                                              \\\n  inline void to_json(BasicJsonType&amp; j, const ENUM_TYPE&amp; e) {                                    \\\n    static_assert(std::is_enum&lt;ENUM_TYPE&gt;::value, #ENUM_TYPE \" must be an enum!\");               \\\n    static const std::pair&lt;ENUM_TYPE, BasicJsonType&gt; m[] = __VA_ARGS__;                          \\\n    auto it = std::find_if(std::begin(m), std::end(m),                                           \\\n                           [e](const std::pair&lt;ENUM_TYPE, BasicJsonType&gt;&amp; ej_pair) -&gt; bool {     \\\n                             return ej_pair.first == e;                                          \\\n                           });                                                                   \\\n    if (it == std::end(m)) throw std::invalid_argument(\"unknown enum value\");                    \\\n    j = it-&gt;second;                                                                              \\\n  }                                                                                              \\\n  template &lt;typename BasicJsonType&gt;                                                              \\\n  inline void from_json(const BasicJsonType&amp; j, ENUM_TYPE&amp; e) {                                  \\\n    static_assert(std::is_enum&lt;ENUM_TYPE&gt;::value, #ENUM_TYPE \" must be an enum!\");               \\\n    static const std::pair&lt;ENUM_TYPE, BasicJsonType&gt; m[] = __VA_ARGS__;                          \\\n    auto it = std::find_if(std::begin(m), std::end(m),                                           \\\n                           [&amp;j](const std::pair&lt;ENUM_TYPE, BasicJsonType&gt;&amp; ej_pair) -&gt; bool {    \\\n                             return ej_pair.second == j;                                         \\\n                           });                                                                   \\\n    if (it == std::end(m)) throw std::invalid_argument(\"unknown json value: \" + std::string(j)); \\\n    e = it-&gt;first;                                                                               \\\n  }\n\nnamespace nlohmann {\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;GridConfig&gt; {\n  static GridConfig from_json(const json&amp; j) {\n    return GridConfig{j.value(\"bin_resolution\", 1.0), j.value(\"downsample_factor\", 3u)};\n  }\n\n  static void to_json(json&amp; j, GridConfig gc) {\n    j[\"bin_resolution\"] = gc.bin_resolution;\n    j[\"downsample_factor\"] = gc.downsample_factor;\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;GroundConfig&gt; {\n  static GroundConfig from_json(const json&amp; j) {\n    return GroundConfig{j.value(\"outlier_removal_height_diff\", 1.0),\n                        j.value(\"min_ground_intensity\", 100),\n                        j.value(\"max_ground_intensity\", 1000)};\n  }\n\n  static void to_json(json&amp; j, GroundConfig gc) {\n    j[\"outlier_removal_height_diff\"] = gc.outlier_removal_height_diff;\n    j[\"min_ground_intensity\"] = gc.min_ground_intensity;\n    j[\"max_ground_intensity\"] = gc.max_ground_intensity;\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;RGBColor&gt; {\n  static RGBColor from_json(const json&amp; j) { return RGBColor(j[0], j[1], j[2], j[3]); }\n\n  static void to_json(json&amp; j, RGBColor c) {\n    j = {c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha()};\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;CMYKColor&gt; {\n  static CMYKColor from_json(const json&amp; j) { return CMYKColor(j[0], j[1], j[2], j[3]); }\n\n  static void to_json(json&amp; j, CMYKColor c) {\n    j = {c.getCyan(), c.getMagenta(), c.getYellow(), c.getBlack()};\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;ColorVariant&gt; {\n  static ColorVariant from_json(const json&amp; j) {\n    if (j.is_string()) {\n      return COLOR_MAP.at(j.get&lt;std::string&gt;());\n    } else {\n      const auto&amp; color = j.items().begin();\n      if (color.key() == \"rgb\") {\n        return color.value().get&lt;RGBColor&gt;();\n      } else {\n        Assert(color.key() == \"cmyk\", \"Invalid color type\");\n        return color.value().get&lt;CMYKColor&gt;();\n      }\n    }\n  }\n\n  static void to_json(json&amp; j, ColorVariant cv) {\n    if (std::holds_alternative&lt;RGBColor&gt;(cv)) {\n      j = json({{\"rgb\", std::get&lt;RGBColor&gt;(cv)}});\n    } else {\n      j = json({{\"cmyk\", std::get&lt;CMYKColor&gt;(cv)}});\n    }\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;ContourConfig&gt; {\n  static ContourConfig from_json(const json&amp; j) {\n    return ContourConfig{j.value(\"interval\", 1.0), j.value(\"min_points\", 5u),\n                         j.value(\"color\", json(\"brown\")).get&lt;ColorVariant&gt;(),\n                         j.value(\"width\", 0.14)};\n  }\n\n  static void to_json(json&amp; j, ContourConfig cc) {\n    j[\"interval\"] = cc.interval;\n    j[\"min_points\"] = cc.min_points;\n    j[\"color\"] = cc.color;\n    j[\"width\"] = cc.width;\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;CanopyConfig&gt; {\n  static CanopyConfig from_json(const json&amp; j) {\n    return CanopyConfig{j.value(\"min_height\", 2.5), j.value(\"max_height\", 100.0),\n                        j.value(\"blocking_threshold\", 0.1)};\n  }\n\n  static void to_json(json&amp; j, CanopyConfig vc) {\n    j[\"min_height\"] = vc.min_height;\n    j[\"max_height\"] = vc.max_height;\n    j[\"blocking_threshold\"] = vc.blocking_threshold;\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;BlockingThresholdColorPair&gt; {\n  static BlockingThresholdColorPair from_json(const json&amp; j) {\n    return BlockingThresholdColorPair{j.value(\"blocking_threshold\", 0.1),\n                                      j.value(\"color\", json(\"white\")).get&lt;ColorVariant&gt;()};\n  }\n\n  static void to_json(json&amp; j, BlockingThresholdColorPair btc) {\n    j[\"blocking_threshold\"] = btc.blocking_threshold;\n    j[\"color\"] = btc.color;\n  }\n};\ntemplate &lt;&gt;\nstruct adl_serializer&lt;VegeHeightConfig&gt; {\n  static VegeHeightConfig from_json(const json&amp; j) {\n    return VegeHeightConfig{\n        j.value(\"name\", \"Vegetation\"), j.value(\"min_height\", 2.5), j.value(\"max_height\", 100.0),\n        j.value(\"colors\", json({})).get&lt;std::vector&lt;BlockingThresholdColorPair&gt;&gt;()};\n  }\n\n  static void to_json(json&amp; j, VegeHeightConfig vhc) {\n    j[\"name\"] = vhc.name;\n    j[\"min_height\"] = vhc.min_height;\n    j[\"max_height\"] = vhc.max_height;\n    j[\"colors\"] = vhc.colors;\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;VegeConfig&gt; {\n  static VegeConfig from_json(const json&amp; j) {\n    return VegeConfig{j.value(\"background_color\", json(\"white\")).get&lt;ColorVariant&gt;(),\n                      j.value(\"height_configs\", json({})).get&lt;std::vector&lt;VegeHeightConfig&gt;&gt;()};\n  }\n\n  static void to_json(json&amp; j, VegeConfig vc) {\n    j[\"background_color\"] = vc.background_color;\n    j[\"height_configs\"] = vc.height_configs;\n  }\n};\ntemplate &lt;&gt;\nstruct adl_serializer&lt;RenderConfig&gt; {\n  static RenderConfig from_json(const json&amp; j) {\n    return RenderConfig{j.value(\"scale\", 10000.0), j.value(\"dpi\", 600.0)};\n  }\n\n  static void to_json(json&amp; j, RenderConfig rc) {\n    j[\"scale\"] = rc.scale;\n    j[\"dpi\"] = rc.dpi;\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;WaterConfig&gt; {\n  static WaterConfig from_json(const json&amp; j) {\n    return WaterConfig{.catchment = j.value(\"catchment\", 0.05),\n                       .color = j.value(\"color\", json(\"blue\")),\n                       .width = j.value(\"width\", 0.18)};\n  }\n\n  static void to_json(json&amp; j, WaterConfig cc) {\n    j[\"catchment\"] = cc.catchment;\n    j[\"color\"] = cc.color;\n    j[\"width\"] = cc.width;\n  }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;WaterConfigs&gt; {\n  static WaterConfigs from_json(const json&amp; j) {\n    return WaterConfigs{j.get&lt;std::map&lt;std::string, WaterConfig&gt;&gt;()};\n  }\n\n  static void to_json(json&amp; j, WaterConfigs cc) { j = cc.configs; }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;ContourConfigs&gt; {\n  static ContourConfigs from_json(const json&amp; j) {\n    return ContourConfigs(j.get&lt;std::map&lt;std::string, ContourConfig&gt;&gt;());\n  }\n\n  static void to_json(json&amp; j, ContourConfigs cc) { j = cc.configs; }\n};\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;BuildingsConfig&gt; {\n  static BuildingsConfig from_json(const json&amp; j) {\n    return BuildingsConfig{j.value(\"color\", json(\"black\")).get&lt;ColorVariant&gt;()};\n  }\n\n  static void to_json(json&amp; j, BuildingsConfig bc) { j[\"color\"] = bc.color; }\n};\n\nSERIALIZE_ENUM_STRICT(ProcessingStep, {\n                                          {ProcessingStep::Tiles, \"tiles\"},\n                                          {ProcessingStep::Combine, \"combine\"},\n                                      })\n\ntemplate &lt;&gt;\nstruct adl_serializer&lt;Config&gt; {\n  static Config from_json(const json&amp; j) {\n    Config config;\n    config.grid = j.value(\"grid\", json({})).get&lt;GridConfig&gt;();\n    config.ground = j.value(\"ground\", json({})).get&lt;GroundConfig&gt;();\n    config.contours = j.value(\"contours\", json({})).get&lt;ContourConfigs&gt;();\n    config.water = j.value(\"water\", json({})).get&lt;WaterConfigs&gt;();\n    config.vege = j.value(\"vege\", json({})).get&lt;VegeConfig&gt;();\n    config.render = j.value(\"render\", json({})).get&lt;RenderConfig&gt;();\n    config.buildings = j.value(\"buildings\", json({})).get&lt;BuildingsConfig&gt;();\n    config.las_files =\n        j.value(\"las_files\", json(std::vector&lt;std::string&gt;())).get&lt;std::vector&lt;fs::path&gt;&gt;();\n    config.processing_steps = j.value(\"steps\", json({\"tiles\"})).get&lt;std::set&lt;ProcessingStep&gt;&gt;();\n    config.output_directory = j.value(\"output_directory\", \"out\");\n    config.border_width = j.value(\"border_width\", 100.0);\n    config.relative_path_to_config = \"\";\n    return config;\n  }\n\n  static void to_json(json&amp; j, const Config&amp; gc) {\n    j[\"grid\"] = gc.grid;\n    j[\"ground\"] = gc.ground;\n    j[\"contours\"] = gc.contours;\n    j[\"water\"] = gc.water;\n    j[\"vege\"] = gc.vege;\n    j[\"render\"] = gc.render;\n    j[\"colors\"] = json({{\"primitive\", COLOR_MAP}});\n    j[\"buildings\"] = gc.buildings;\n    j[\"las_files\"] = gc.las_files;\n    j[\"steps\"] = gc.processing_steps;\n    j[\"output_directory\"] = gc.output_directory;\n    j[\"border_width\"] = gc.border_width;\n  }\n};\n\n}  // namespace nlohmann\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Config&amp; config) {\n  os &lt;&lt; \"Config:\\n\";\n  os &lt;&lt; json(config).dump(4);\n  return os;\n}\n\nvoid Config::write_to_file(const fs::path&amp; filename) const {\n  std::ofstream file(filename);\n  if (!file.is_open()) {\n    std::cerr &lt;&lt; \"Failed to open config file \" &lt;&lt; filename &lt;&lt; std::endl;\n    throw std::filesystem::filesystem_error(\"Failed to open config file \" + filename.string(),\n                                            std::make_error_code(std::errc::io_error));\n  }\n  json j = *this;\n  j.erase(\"relative_path_to_config\");\n  file &lt;&lt; j.dump(4);\n  file.close();\n}\n\nConfig Config::FromFile(const fs::path&amp; filename) {\n  std::ifstream file(filename);\n  if (!file.is_open()) {\n    std::cerr &lt;&lt; \"Failed to open config file \" &lt;&lt; filename &lt;&lt; std::endl;\n    throw std::filesystem::filesystem_error(\"Failed to open config file \" + filename.string(),\n                                            std::make_error_code(std::errc::io_error));\n  }\n  json j;\n  try {\n    j = json::parse(file, nullptr, true, true);\n  } catch (const json::exception&amp; e) {\n    std::cerr &lt;&lt; \"JSON parsing error: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\n    throw e;\n  }\n  file.close();\n  for (const auto&amp; color : j[\"colors\"][\"primitive\"].items()) {\n    COLOR_MAP[color.key()] = color.value().get&lt;ColorVariant&gt;();\n  }\n  for (const auto&amp; color : j[\"colors\"][\"composite\"].items()) {\n    CMYKColor composite;\n    for (const auto&amp; component : color.value().items()) {\n      composite =\n          composite + to_cmyk(COLOR_MAP.at(component.key())) * component.value().get&lt;double&gt;();\n    }\n    COLOR_MAP[color.key()] = composite;\n  }\n  Config c = j.get&lt;Config&gt;();\n  c.relative_path_to_config = filename.parent_path();\n  return c;\n}\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ProcessingStep&amp; step) { return os &lt;&lt; json(step); }\n</code></pre>"},{"location":"blaze/config__input_8hpp/","title":"File config_input.hpp","text":"<p>FileList &gt; config_input &gt; config_input.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"isom/colors.hpp\"</code></li> <li><code>#include \"utilities/filesystem.hpp\"</code></li> <li><code>#include \"utilities/resources.hpp\"</code></li> </ul>"},{"location":"blaze/config__input_8hpp/#classes","title":"Classes","text":"Type Name struct BlockingThresholdColorPair struct BuildingsConfig struct CanopyConfig struct Config struct ContourConfig struct ContourConfigs struct GridConfig struct GroundConfig struct RenderConfig struct VegeConfig struct VegeHeightConfig struct WaterConfig struct WaterConfigs"},{"location":"blaze/config__input_8hpp/#public-types","title":"Public Types","text":"Type Name enum ProcessingStep"},{"location":"blaze/config__input_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const ProcessingStep &amp; step)"},{"location":"blaze/config__input_8hpp/#macros","title":"Macros","text":"Type Name define SERIALIZE_ENUM_STRICT (ENUM_TYPE, ...) <code>/* multi line expression */</code>"},{"location":"blaze/config__input_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/config__input_8hpp/#enum-processingstep","title":"enum ProcessingStep","text":"<pre><code>enum ProcessingStep {\n    Tiles,\n    Combine\n};\n</code></pre>"},{"location":"blaze/config__input_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/config__input_8hpp/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const ProcessingStep &amp; step\n) \n</code></pre>"},{"location":"blaze/config__input_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"blaze/config__input_8hpp/#define-serialize_enum_strict","title":"define SERIALIZE_ENUM_STRICT","text":"<pre><code>#define SERIALIZE_ENUM_STRICT (\n    ENUM_TYPE,\n    ...\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/config_input/config_input.hpp</code></p>"},{"location":"blaze/config__input_8hpp_source/","title":"File config_input.hpp","text":"<p>File List &gt; config_input &gt; config_input.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\n#include \"isom/colors.hpp\"\n#include \"utilities/filesystem.hpp\"\n#include \"utilities/resources.hpp\"\n\nstruct GridConfig {\n  double bin_resolution;\n  unsigned int downsample_factor;\n};\n\n#define SERIALIZE_ENUM_STRICT(ENUM_TYPE, ...)                                                    \\\n  template &lt;typename BasicJsonType&gt;                                                              \\\n  inline void to_json(BasicJsonType&amp; j, const ENUM_TYPE&amp; e) {                                    \\\n    static_assert(std::is_enum&lt;ENUM_TYPE&gt;::value, #ENUM_TYPE \" must be an enum!\");               \\\n    static const std::pair&lt;ENUM_TYPE, BasicJsonType&gt; m[] = __VA_ARGS__;                          \\\n    auto it = std::find_if(std::begin(m), std::end(m),                                           \\\n                           [e](const std::pair&lt;ENUM_TYPE, BasicJsonType&gt;&amp; ej_pair) -&gt; bool {     \\\n                             return ej_pair.first == e;                                          \\\n                           });                                                                   \\\n    if (it == std::end(m)) throw std::invalid_argument(\"unknown enum value\");                    \\\n    j = it-&gt;second;                                                                              \\\n  }                                                                                              \\\n  template &lt;typename BasicJsonType&gt;                                                              \\\n  inline void from_json(const BasicJsonType&amp; j, ENUM_TYPE&amp; e) {                                  \\\n    static_assert(std::is_enum&lt;ENUM_TYPE&gt;::value, #ENUM_TYPE \" must be an enum!\");               \\\n    static const std::pair&lt;ENUM_TYPE, BasicJsonType&gt; m[] = __VA_ARGS__;                          \\\n    auto it = std::find_if(std::begin(m), std::end(m),                                           \\\n                           [&amp;j](const std::pair&lt;ENUM_TYPE, BasicJsonType&gt;&amp; ej_pair) -&gt; bool {    \\\n                             return ej_pair.second == j;                                         \\\n                           });                                                                   \\\n    if (it == std::end(m)) throw std::invalid_argument(\"unknown json value: \" + std::string(j)); \\\n    e = it-&gt;first;                                                                               \\\n  }\n\nstruct GroundConfig {\n  double outlier_removal_height_diff;\n  int min_ground_intensity;\n  int max_ground_intensity;\n};\n\nstruct ContourConfig {\n  double interval;\n  unsigned int min_points;\n  ColorVariant color;\n  double width;\n};\n\nstruct CanopyConfig {\n  double min_height;\n  double max_height;\n  double blocking_threshold;\n};\n\nstruct BlockingThresholdColorPair {\n  double blocking_threshold;\n  ColorVariant color;\n};\n\nstruct VegeHeightConfig {\n  std::string name;\n  double min_height;\n  double max_height;\n  std::vector&lt;BlockingThresholdColorPair&gt; colors;\n\n  std::optional&lt;ColorVariant&gt; pick_from_blocked_proportion(double bp) const {\n    std::optional&lt;ColorVariant&gt; color;\n    for (const BlockingThresholdColorPair&amp; btc : colors) {\n      if (bp &gt;= btc.blocking_threshold) {\n        color = btc.color;\n      }\n    }\n    return color;\n  }\n};\n\nstruct VegeConfig {\n  ColorVariant background_color;\n  std::vector&lt;VegeHeightConfig&gt; height_configs;\n};\n\nstruct RenderConfig {\n  double scale;\n  double dpi;\n};\n\nstruct WaterConfig {\n  double catchment;\n  ColorVariant color;\n  double width;\n};\n\nstruct WaterConfigs {\n  std::map&lt;std::string, WaterConfig&gt; configs;\n\n  const WaterConfig&amp; config_from_catchment(double catchment) const {\n    const WaterConfig* max_valid_config = nullptr;\n    for (const auto&amp; [_, config] : configs) {\n      if (config.catchment &lt;= catchment &amp;&amp;\n          (max_valid_config == nullptr || config.catchment &gt; max_valid_config-&gt;catchment))\n        max_valid_config = &amp;config;\n    }\n    return *max_valid_config;\n  }\n\n  double minimum_catchment() const {\n    double min_catchment = std::numeric_limits&lt;double&gt;::max();\n    for (const auto&amp; [_, config] : configs) {\n      min_catchment = std::min(config.catchment, min_catchment);\n    }\n    return min_catchment;\n  }\n};\n\nstruct ContourConfigs {\n  std::map&lt;std::string, ContourConfig&gt; configs;\n  double min_interval;\n\n  static double minimum_interval(const std::map&lt;std::string, ContourConfig&gt;&amp; configs) {\n    double min_interval = std::numeric_limits&lt;double&gt;::max();\n    for (const auto&amp; [_, config] : configs) {\n      min_interval = std::min(min_interval, config.interval);\n    }\n    return min_interval;\n  }\n\n  ContourConfigs() : min_interval(std::numeric_limits&lt;double&gt;::max()) {}\n\n  explicit ContourConfigs(std::map&lt;std::string, ContourConfig&gt; in_configs)\n      : configs(std::move(in_configs)), min_interval(minimum_interval(configs)) {}\n\n  const ContourConfig&amp; operator[](const std::string&amp; key) const { return configs.at(key); }\n\n  const ContourConfig&amp; pick_from_height(double height) const {\n    auto max_valid_interval = std::numeric_limits&lt;double&gt;::min();\n    const ContourConfig* config_to_return = nullptr;\n    for (const auto&amp; [_, config] : configs) {\n      if (config.interval &gt; max_valid_interval &amp;&amp;\n          std::fmod(std::abs(height), config.interval) &lt; 1e-8) {\n        max_valid_interval = config.interval;\n        config_to_return = &amp;config;\n      }\n    }\n    return *config_to_return;\n  }\n\n  std::string layer_name_from_height(double height) const {\n    auto max_valid_interval = std::numeric_limits&lt;double&gt;::min();\n    std::string layer_name = \"Contour\";\n    for (const auto&amp; [name, config] : configs) {\n      if (config.interval &gt; max_valid_interval &amp;&amp;\n          std::fmod(std::abs(height), config.interval) &lt; 1e-8) {\n        if (name == \"form_line\") {\n          layer_name = \"103_Form_Line\";\n        } else if (name == \"index\") {\n          layer_name = \"102_Index_Contour\";\n        } else if (name == \"normal\") {\n          layer_name = \"101_Contour\";\n        }\n        max_valid_interval = config.interval;\n      }\n    }\n    return layer_name;\n  }\n};\n\nstruct BuildingsConfig {\n  ColorVariant color;\n};\n\nenum class ProcessingStep {\n  Tiles,\n  Combine,\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ProcessingStep&amp; step);\n\nstruct Config {\n  GridConfig grid;\n  GroundConfig ground;\n  ContourConfigs contours;\n  WaterConfigs water;\n  VegeConfig vege;\n  RenderConfig render;\n  BuildingsConfig buildings;\n  std::vector&lt;fs::path&gt; las_files;\n  std::set&lt;ProcessingStep&gt; processing_steps;\n  fs::path output_directory;\n  double border_width;\n  fs::path relative_path_to_config;\n\n  void set_output_directory(const fs::path&amp; output_dir) { output_directory = output_dir; }\n\n  fs::path output_path() const {\n    if (output_directory.is_absolute()) {\n      return output_directory;\n    }\n    return relative_path_to_config / output_directory;\n  }\n\n  std::vector&lt;fs::path&gt; las_filepaths() const {\n    std::vector&lt;fs::path&gt; las_filepaths;\n    for (const fs::path&amp; las_file : las_files) {\n      if (las_file.is_absolute()) {\n        las_filepaths.push_back(las_file);\n      } else {\n        las_filepaths.push_back(relative_path_to_config / las_file);\n      }\n    }\n    return las_filepaths;\n  }\n\n  std::vector&lt;fs::path&gt; get_las_files(const fs::path&amp; las_path) const {\n    std::vector&lt;fs::path&gt; file_list;\n    fs::path actual_path = las_path.is_absolute() ? las_path : relative_path_to_config / las_path;\n    if (fs::exists(actual_path)) {\n      if (fs::is_directory(actual_path)) {\n        for (const fs::directory_entry&amp; entry : fs::directory_iterator(actual_path)) {\n          if (entry.path().extension() == \".las\" || entry.path().extension() == \".laz\") {\n            file_list.push_back(entry.path());\n          }\n        }\n      } else if (actual_path.extension() == \".las\" || actual_path.extension() == \".laz\") {\n        file_list.push_back(actual_path);\n      }\n    }\n    return file_list;\n  }\n\n  static Config FromFile(const fs::path&amp; filename);\n\n  void write_to_file(const fs::path&amp; filename) const;\n\n  static Config Default() { return FromFile(AssetRetriever::get_asset(\"default_config.json\")); }\n\n  Config&amp; operator=(const Config&amp; config) = default;\n  Config(const Config&amp; config) = delete;\n  Config(Config&amp;&amp; config) = default;\n  Config() = default;\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Config&amp; config);\n};\n</code></pre>"},{"location":"blaze/dir_168d7404e8aa1148a0abea8bd7ba0546/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/contour","text":"<p>FileList &gt; contour</p>"},{"location":"blaze/dir_168d7404e8aa1148a0abea8bd7ba0546/#files","title":"Files","text":"Type Name file contour.cpp file contour.hpp file contour_gen.hpp"},{"location":"blaze/dir_168d7404e8aa1148a0abea8bd7ba0546/#directories","title":"Directories","text":"Type Name dir tests <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/contour/</code></p>"},{"location":"blaze/dir_af1ec3f63b3290d3c0b6a16b438b915c/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/contour/tests","text":"<p>FileList &gt; contour &gt; tests</p>"},{"location":"blaze/dir_af1ec3f63b3290d3c0b6a16b438b915c/#files","title":"Files","text":"Type Name file test_contour_gen.cpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/contour/tests/</code></p>"},{"location":"blaze/test__contour__gen_8cpp/","title":"File test_contour_gen.cpp","text":"<p>FileList &gt; contour &gt; tests &gt; test_contour_gen.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;gtest/gtest.h&gt;</code></li> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"contour/contour.hpp\"</code></li> <li><code>#include \"contour/contour_gen.hpp\"</code></li> <li><code>#include \"isom/colors.hpp\"</code></li> <li><code>#include \"lib/grid/grid.hpp\"</code></li> </ul>"},{"location":"blaze/test__contour__gen_8cpp/#classes","title":"Classes","text":"Type Name class TestGrid"},{"location":"blaze/test__contour__gen_8cpp/#public-functions","title":"Public Functions","text":"Type Name TEST (ContourGen, ContourGen)  TEST (ContourGen, ContourGen2)"},{"location":"blaze/test__contour__gen_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/test__contour__gen_8cpp/#function-test","title":"function TEST","text":"<pre><code>TEST (\n    ContourGen,\n    ContourGen\n) \n</code></pre>"},{"location":"blaze/test__contour__gen_8cpp/#function-test_1","title":"function TEST","text":"<pre><code>TEST (\n    ContourGen,\n    ContourGen2\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/contour/tests/test_contour_gen.cpp</code></p>"},{"location":"blaze/test__contour__gen_8cpp_source/","title":"File test_contour_gen.cpp","text":"<p>File List &gt; contour &gt; tests &gt; test_contour_gen.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;gtest/gtest.h&gt;\n\n#include \"config_input/config_input.hpp\"\n#include \"contour/contour.hpp\"\n#include \"contour/contour_gen.hpp\"\n#include \"isom/colors.hpp\"\n#include \"lib/grid/grid.hpp\"\n\nclass TestGrid : public GeoGrid&lt;double&gt; {\n public:\n  explicit TestGrid(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; data)\n      : GeoGrid&lt;double&gt;(data[0].size(), data.size(), GeoTransform(), GeoProjection()) {\n    for (size_t i = 0; i &lt; data.size(); i++) {\n      for (size_t j = 0; j &lt; data[0].size(); j++) {\n        (*this)[{j, i}] = data[i][j];\n      }\n    }\n  }\n};\n\nTEST(ContourGen, ContourGen) {\n  std::vector&lt;std::vector&lt;double&gt;&gt; data = {{0.5, 0.5, 0.5}, {0.5, 1.5, 0.5}, {0.5, 0.5, 0.5}};\n  TestGrid grid(data);\n\n  ContourConfigs configs({{\"normal\", ContourConfig{1.0, 1, RGBColor(0, 0, 0, 0), 0.14}}});\n  std::vector&lt;Contour&gt; contours = generate_contours(\n      grid, ContourConfigs({{\"normal\", ContourConfig{1.0, 1, RGBColor(0, 0, 0, 0), 0.14}}}),\n      ProgressTracker());\n  EXPECT_EQ(contours.size(), 1);\n  EXPECT_EQ(contours[0].points().size(), 5);\n  EXPECT_DOUBLE_EQ(contours[0].height(), 1.0);\n  EXPECT_TRUE(contours[0].is_loop());\n}\n\nTEST(ContourGen, ContourGen2) {\n  std::vector&lt;std::vector&lt;double&gt;&gt; data = {{0.5, 0.5, 0.5, 0.5, 0.5}, {0.5, 1.5, 1.5, 1.5, 0.5},\n                                           {0.5, 1.5, 2.1, 1.5, 0.5}, {0.5, 1.5, 2.1, 1.5, 0.5},\n                                           {0.5, 1.5, 1.5, 1.5, 1.5}, {0.5, 0.5, 0.5, 1.5, 1.5}};\n  TestGrid grid(data);\n\n  std::vector&lt;Contour&gt; contours = generate_contours(\n      grid, ContourConfigs{{{\"normal\", ContourConfig{1.0, 1, RGBColor(0, 0, 0, 0), 0.14}}}},\n      ProgressTracker());\n  EXPECT_EQ(contours.size(), 2);\n\n  EXPECT_EQ(contours[0].points().size(), 14);\n  EXPECT_DOUBLE_EQ(contours[0].height(), 1.0);\n  EXPECT_FALSE(contours[0].is_loop());\n\n  EXPECT_EQ(contours[1].points().size(), 7);\n  EXPECT_DOUBLE_EQ(contours[1].height(), 2.0);\n  EXPECT_TRUE(contours[1].is_loop());\n}\n</code></pre>"},{"location":"blaze/contour_8cpp/","title":"File contour.cpp","text":"<p>FileList &gt; contour &gt; contour.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"contour.hpp\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"dxf/dxf.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/contour/contour.cpp</code></p>"},{"location":"blaze/contour_8cpp_source/","title":"File contour.cpp","text":"<p>File List &gt; contour &gt; contour.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"contour.hpp\"\n\n#include &lt;string&gt;\n\n#include \"dxf/dxf.hpp\"\n#include \"utilities/coordinate.hpp\"\n\nPolyline Contour::to_polyline(const ContourConfigs&amp; configs) const {\n  Polyline polyline;\n  polyline.layer = configs.layer_name_from_height(m_height);\n  polyline.name = std::to_string(m_height);\n  polyline.vertices = m_points;\n  return polyline;\n}\n\nContour Contour::from_polyline(const Polyline&amp; polyline) {\n  try {\n    return Contour(std::stod(polyline.name), std::vector&lt;Coordinate2D&lt;double&gt;&gt;(polyline.vertices));\n  } catch (std::invalid_argument&amp;) {\n    std::cerr &lt;&lt; \"Invalid contour name: \\\"\" &lt;&lt; polyline.name &lt;&lt; \"\\\", should be height.\"\n              &lt;&lt; std::endl;\n    return Contour(0, std::vector&lt;Coordinate2D&lt;double&gt;&gt;());\n  }\n}\n</code></pre>"},{"location":"blaze/contour_8hpp/","title":"File contour.hpp","text":"<p>FileList &gt; contour &gt; contour.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"grid/grid.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> </ul>"},{"location":"blaze/contour_8hpp/#classes","title":"Classes","text":"Type Name class Contour"},{"location":"blaze/contour_8hpp/#public-functions","title":"Public Functions","text":"Type Name bool crosses_contour (T h1, T h2, T contour_interval)  std::set&lt; T &gt; get_contour_heights (T h1, T h2, T contour_interval)  Coordinate2D&lt; T &gt; interpolate_coordinates (const Coordinate2D&lt; T &gt; &amp; a, const Coordinate2D&lt; T &gt; &amp; b, const U &amp; a_val, const U &amp; b_val, const U &amp; target)  T round_down (T val, T interval)"},{"location":"blaze/contour_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/contour_8hpp/#function-crosses_contour","title":"function crosses_contour","text":"<pre><code>template&lt;typename T&gt;\ninline bool crosses_contour (\n    T h1,\n    T h2,\n    T contour_interval\n) \n</code></pre>"},{"location":"blaze/contour_8hpp/#function-get_contour_heights","title":"function get_contour_heights","text":"<pre><code>template&lt;typename T&gt;\ninline std::set&lt; T &gt; get_contour_heights (\n    T h1,\n    T h2,\n    T contour_interval\n) \n</code></pre>"},{"location":"blaze/contour_8hpp/#function-interpolate_coordinates","title":"function interpolate_coordinates","text":"<pre><code>template&lt;typename T, typename  U&gt;\nCoordinate2D &lt; T &gt; interpolate_coordinates (\n    const  Coordinate2D &lt; T &gt; &amp; a,\n    const  Coordinate2D &lt; T &gt; &amp; b,\n    const  U &amp; a_val,\n    const  U &amp; b_val,\n    const  U &amp; target\n) \n</code></pre>"},{"location":"blaze/contour_8hpp/#function-round_down","title":"function round_down","text":"<pre><code>template&lt;typename T&gt;\nT round_down (\n    T val,\n    T interval\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/contour/contour.hpp</code></p>"},{"location":"blaze/contour_8hpp_source/","title":"File contour.hpp","text":"<p>File List &gt; contour &gt; contour.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cmath&gt;\n\n#include \"config_input/config_input.hpp\"\n#include \"grid/grid.hpp\"\n#include \"utilities/coordinate.hpp\"\n\ntemplate &lt;typename T&gt;\nT round_down(T val, T interval) {\n  if (val &lt; 0) {\n    return val - fmod(val, interval) - interval;\n  } else {\n    return val - fmod(val, interval);\n  }\n}\n\ntemplate &lt;typename T&gt;\ninline bool crosses_contour(T h1, T h2, T contour_interval) {\n  T max = std::max(h1, h2);\n  T min = std::min(h1, h2);\n  return round_down(max, contour_interval) &gt; min;\n}\n\ntemplate &lt;typename T&gt;\ninline std::set&lt;T&gt; get_contour_heights(T h1, T h2, T contour_interval) {\n  std::set&lt;T&gt; heights;\n  T max = std::max(h1, h2);\n  T min = std::min(h1, h2);\n  for (T h = round_down(max, contour_interval); h &gt; min; h -= contour_interval) {\n    heights.insert(h);\n  }\n  return heights;\n}\n\ntemplate &lt;typename T, typename U&gt;\nCoordinate2D&lt;T&gt; interpolate_coordinates(const Coordinate2D&lt;T&gt;&amp; a, const Coordinate2D&lt;T&gt;&amp; b,\n                                        const U&amp; a_val, const U&amp; b_val, const U&amp; target) {\n  double a_weight;\n  if (a_val == b_val) {\n    a_weight = 0.5;\n  } else {\n    a_weight = (double)(b_val - target) / (b_val - a_val);\n  }\n  double b_weight = 1 - a_weight;\n  return Coordinate2D&lt;T&gt;(a.x() * a_weight + b.x() * b_weight, a.y() * a_weight + b.y() * b_weight);\n}\n\nclass Polyline;\n\nclass Contour {\n  double m_height;\n  std::vector&lt;Coordinate2D&lt;double&gt;&gt; m_points;\n  bool m_is_loop = false;\n\n public:\n  Contour(double height, std::vector&lt;Coordinate2D&lt;double&gt;&gt;&amp;&amp; points)\n      : m_height(height), m_points(std::move(points)) {\n    if (m_points.size() &gt; 1) {\n      const auto&amp; front = m_points.front();\n      const auto&amp; back = m_points.back();\n      m_is_loop = (front - back).magnitude_sqd() &lt; 1e-10;\n    }\n  }\n\n  static Contour from_polyline(const Polyline&amp; polyline);\n  Polyline to_polyline(const ContourConfigs&amp; configs) const;\n\n  double height() const { return m_height; }\n  const std::vector&lt;Coordinate2D&lt;double&gt;&gt;&amp; points() const { return m_points; }\n  std::vector&lt;Coordinate2D&lt;double&gt;&gt;&amp; points() { return m_points; }\n\n  static Contour FromGridGraph(const LineCoord2D&lt;size_t&gt;&amp; starting_point, double height,\n                               const GeoGrid&lt;double&gt;&amp; grid,\n                               GridGraph&lt;std::set&lt;double&gt;&gt;&amp; contour_heights) {\n    std::vector&lt;Coordinate2D&lt;double&gt;&gt; contour_points;\n    int pass = 0;\n    for (Direction2D dir : starting_point.dir().orthogonal_dirs()) {\n      std::vector&lt;Coordinate2D&lt;double&gt;&gt; this_contour_points;\n      LineCoord2DCrossing&lt;size_t&gt; current_point(starting_point, dir);\n      bool end = false;\n      bool first_iter = true;\n      while (!end) {\n        if (!first_iter || pass &gt; 0) {\n          auto it = contour_heights[current_point].find(height);\n          if (it == contour_heights[current_point].end()) {\n            AssertEQ(first_iter, true);\n            AssertEQ(pass, 1);\n            break;\n          }\n          contour_heights[current_point].erase(it);\n        }\n        first_iter = false;\n        this_contour_points.emplace_back(interpolate_coordinates(\n            grid.transform().pixel_to_projection(current_point.start().offset_to_center()),\n            grid.transform().pixel_to_projection(current_point.end().offset_to_center()),\n            grid[current_point.start()], grid[current_point.end()], height));\n        end = true;\n        for (LineCoord2DCrossing&lt;size_t&gt; next_point : current_point.next_points()) {\n          if (contour_heights.in_bounds(next_point) &amp;&amp;\n              contour_heights[next_point].contains(height)) {\n            current_point = next_point;\n            end = false;\n            break;\n          }\n        }\n      }\n      if (pass == 0) {\n        std::reverse_copy(this_contour_points.begin(), this_contour_points.end(),\n                          std::back_inserter(contour_points));\n        pass += 1;\n      } else {\n        if (this_contour_points.size() &gt; 0) contour_points.pop_back();\n        std::copy(this_contour_points.begin(), this_contour_points.end(),\n                  std::back_inserter(contour_points));\n      }\n    }\n    return Contour(height, std::move(contour_points));\n  }\n\n  void push_back(const Coordinate2D&lt;double&gt;&amp; point) {\n    m_points.push_back(point);\n    if (m_points.size() &gt; 1) {\n      m_is_loop = (m_points.front() - m_points.back()).magnitude_sqd() &lt; 1e-10;\n    }\n  }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Contour&amp; contour) {\n    os &lt;&lt; \"Contour at height \" &lt;&lt; contour.height() &lt;&lt; \" with \" &lt;&lt; contour.points().size()\n       &lt;&lt; \" points\";\n    return os;\n  }\n\n  bool is_loop() const { return m_is_loop; }\n};\n</code></pre>"},{"location":"blaze/contour__gen_8hpp/","title":"File contour_gen.hpp","text":"<p>FileList &gt; contour &gt; contour_gen.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"contour.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/contour__gen_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; Contour &gt; generate_contours (const GeoGrid&lt; T &gt; &amp; grid, const ContourConfigs &amp; contour_config, ProgressTracker progress_tracker)  GeoGrid&lt; std::optional&lt; std::byte &gt; &gt; generate_naive_contours (const GeoGrid&lt; double &gt; &amp; ground)  GridGraph&lt; std::set&lt; double &gt; &gt; identify_contours (const GeoGrid&lt; T &gt; &amp; grid, T contour_interval)  std::vector&lt; Contour &gt; join_contours (std::vector&lt; Contour &gt; contours, double max_dist=15.0)  std::vector&lt; Contour &gt; trim_contours (const std::vector&lt; Contour &gt; &amp; contours, const Extent2D &amp; bounds)"},{"location":"blaze/contour__gen_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/contour__gen_8hpp/#function-generate_contours","title":"function generate_contours","text":"<pre><code>template&lt;typename T&gt;\nstd::vector&lt; Contour &gt; generate_contours (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    const  ContourConfigs &amp; contour_config,\n    ProgressTracker progress_tracker\n) \n</code></pre>"},{"location":"blaze/contour__gen_8hpp/#function-generate_naive_contours","title":"function generate_naive_contours","text":"<pre><code>inline GeoGrid &lt; std::optional&lt; std::byte &gt; &gt; generate_naive_contours (\n    const  GeoGrid &lt; double &gt; &amp; ground\n) \n</code></pre>"},{"location":"blaze/contour__gen_8hpp/#function-identify_contours","title":"function identify_contours","text":"<pre><code>template&lt;typename T&gt;\nGridGraph &lt; std::set&lt; double &gt; &gt; identify_contours (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    T contour_interval\n) \n</code></pre>"},{"location":"blaze/contour__gen_8hpp/#function-join_contours","title":"function join_contours","text":"<pre><code>inline std::vector&lt; Contour &gt; join_contours (\n    std::vector&lt; Contour &gt; contours,\n    double max_dist=15.0\n) \n</code></pre>"},{"location":"blaze/contour__gen_8hpp/#function-trim_contours","title":"function trim_contours","text":"<pre><code>inline std::vector&lt; Contour &gt; trim_contours (\n    const std::vector&lt; Contour &gt; &amp; contours,\n    const  Extent2D &amp; bounds\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/contour/contour_gen.hpp</code></p>"},{"location":"blaze/contour__gen_8hpp_source/","title":"File contour_gen.hpp","text":"<p>File List &gt; contour &gt; contour_gen.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"config_input/config_input.hpp\"\n#include \"contour.hpp\"\n#include \"utilities/timer.hpp\"\n\ntemplate &lt;typename T&gt;\nGridGraph&lt;std::set&lt;double&gt;&gt; identify_contours(const GeoGrid&lt;T&gt;&amp; grid, T contour_interval) {\n  TimeFunction timer(\"identifying contours\");\n  GridGraph contour_heights = GridGraph&lt;std::set&lt;double&gt;&gt;(grid);\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      Coordinate2D&lt;size_t&gt; coord = {j, i};\n      for (Direction2D dir : {Direction2D::DOWN, Direction2D::RIGHT}) {\n        LineCoord2D&lt;size_t&gt; line_coord = {coord, dir};\n        if (contour_heights.in_bounds(line_coord)) {\n          contour_heights[line_coord] = get_contour_heights(\n              grid[line_coord.start()], grid[line_coord.end()], contour_interval);\n        }\n      }\n    }\n  }\n  return contour_heights;\n}\n\ninline std::vector&lt;Contour&gt; join_contours(std::vector&lt;Contour&gt; contours, double max_dist = 15.0) {\n  const double max_dist2 = max_dist * max_dist;\n\n  // Describes one of the four ways to combine contours\n  struct JoiningOption {\n    bool use_front_a;\n    bool use_front_b;\n  };\n  static constexpr JoiningOption cases[] = {\n      {true, true},   // a.front  \u2194 b.front\n      {false, true},  // a.back   \u2194 b.front\n      {true, false},  // a.front  \u2194 b.back\n      {false, false}  // a.back   \u2194 b.back\n  };\n\n  bool did_any_join = true;\n  std::vector&lt;Contour&gt; next_round;\n\n  while (did_any_join) {\n    did_any_join = false;\n    next_round.clear();\n\n    for (auto&amp; src : contours) {\n      const auto&amp; b = src.points();\n\n      double best_d2 = max_dist2;\n      int best_idx = -1;\n      JoiningOption best_case{};\n      for (int i = 0; i &lt; (int)next_round.size(); ++i) {\n        const auto&amp; a = next_round[i].points();\n        for (JoiningOption c : cases) {\n          const auto&amp; pa = (c.use_front_a ? a.front() : a.back());\n          const auto&amp; pb = (c.use_front_b ? b.front() : b.back());\n          double d2 = (pa - pb).magnitude_sqd();\n          if (d2 &lt; best_d2) {\n            best_d2 = d2;\n            best_idx = i;\n            best_case = c;\n          }\n        }\n      }\n      if (best_idx &gt;= 0) {\n        auto&amp; acc = next_round[best_idx].points();\n        // If we matched its FRONT, reverse so the join point is at back()\n        if (best_case.use_front_a) {\n          std::reverse(acc.begin(), acc.end());\n        }\n        // Then append src either forward or reversed\n        if (best_case.use_front_b) {\n          acc.insert(acc.end(), b.begin(), b.end());\n        } else {\n          acc.insert(acc.end(), b.rbegin(), b.rend());\n        }\n        did_any_join = true;\n      } else {\n        next_round.emplace_back(std::move(src));\n      }\n    }\n    contours = std::move(next_round);\n  }\n\n  return contours;\n}\n\ninline std::vector&lt;Contour&gt; trim_contours(const std::vector&lt;Contour&gt;&amp; contours,\n                                          const Extent2D&amp; bounds) {\n  std::vector&lt;Contour&gt; trimmed_contours;\n  for (const Contour&amp; c : contours) {\n    Contour trimmed_contour(c.height(), std::vector&lt;Coordinate2D&lt;double&gt;&gt;{});\n    for (const Coordinate2D&lt;double&gt;&amp; point : c.points()) {\n      if (bounds.contains(point.x(), point.y())) {\n        trimmed_contour.push_back(point);\n      } else if (trimmed_contour.points().size() &gt; 0) {\n        trimmed_contours.emplace_back(std::move(trimmed_contour));\n        trimmed_contour = Contour(c.height(), std::vector&lt;Coordinate2D&lt;double&gt;&gt;{});\n      }\n    }\n    if (trimmed_contour.points().size() &gt; 0) {\n      trimmed_contours.emplace_back(std::move(trimmed_contour));\n    }\n  }\n  return trimmed_contours;\n}\n\ntemplate &lt;typename T&gt;\nstd::vector&lt;Contour&gt; generate_contours(const GeoGrid&lt;T&gt;&amp; grid, const ContourConfigs&amp; contour_config,\n                                       ProgressTracker progress_tracker) {\n  TimeFunction timer(\"generating contours\", &amp;progress_tracker);\n  GridGraph is_contour = identify_contours(grid, contour_config.min_interval);\n  std::vector&lt;Contour&gt; contours;\n  for (size_t i = 0; i &lt; is_contour.height(); i++) {\n    for (size_t j = 0; j &lt; is_contour.width(); j++) {\n      Coordinate2D&lt;size_t&gt; coord = {j, i};\n      for (Direction2D dir : {Direction2D::DOWN, Direction2D::RIGHT}) {\n        LineCoord2D&lt;size_t&gt; line_coord = {coord, dir};\n        if (is_contour.in_bounds(line_coord)) {\n          for (double height : std::set&lt;double&gt;(is_contour[line_coord])) {\n            Contour c = Contour::FromGridGraph(line_coord, height, grid, is_contour);\n            // TODO use length instead of number of points\n            if (c.points().size() &gt; contour_config.pick_from_height(c.height()).min_points) {\n              contours.emplace_back(std::move(c));\n            }\n          }\n        }\n      }\n    }\n  }\n  progress_tracker.text_update(\"Generated \" + std::to_string(contours.size()) + \" contours\");\n  return contours;\n}\n\ninline GeoGrid&lt;std::optional&lt;std::byte&gt;&gt; generate_naive_contours(const GeoGrid&lt;double&gt;&amp; ground) {\n  GeoGrid&lt;std::optional&lt;std::byte&gt;&gt; naive_countours = GeoGrid&lt;std::optional&lt;std::byte&gt;&gt;(\n      ground.width(), ground.height(), GeoTransform(ground.transform()),\n      GeoProjection(ground.projection()));\n\n  double contour_interval = 2.5;\n  for (size_t i = 1; i &lt; ground.height() - 1; i++) {\n    for (size_t j = 1; j &lt; ground.width() - 1; j++) {\n      double z = ground[{i, j}];\n      double z_north = ground[{i - 1, j}];\n      double z_south = ground[{i + 1, j}];\n      double z_west = ground[{i, j - 1}];\n      double z_east = ground[{i, j + 1}];\n      bool is_countour = crosses_contour(z, z_north, contour_interval) ||\n                         crosses_contour(z, z_south, contour_interval) ||\n                         crosses_contour(z, z_west, contour_interval) ||\n                         crosses_contour(z, z_east, contour_interval);\n      naive_countours[{i, j}] = is_countour ? std::optional&lt;std::byte&gt;{std::byte{0}} : std::nullopt;\n    }\n  }\n  return naive_countours;\n}\n</code></pre>"},{"location":"blaze/dir_f79adc6b9298312518c9c9a103ddabe7/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/dxf","text":"<p>FileList &gt; dxf</p>"},{"location":"blaze/dir_f79adc6b9298312518c9c9a103ddabe7/#files","title":"Files","text":"Type Name file dxf.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/dxf/</code></p>"},{"location":"blaze/dxf_8hpp/","title":"File dxf.hpp","text":"<p>FileList &gt; dxf &gt; dxf.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;methods/water/water.hpp&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"contour/contour.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> <li><code>#include \"utilities/filesystem.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/dxf_8hpp/#classes","title":"Classes","text":"Type Name class Polyline"},{"location":"blaze/dxf_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::string dxf_entities ()  std::string dxf_footer ()  std::string dxf_header ()  std::vector&lt; Contour &gt; read_dxf (const fs::path &amp; filename)  Coordinate2D&lt; double &gt; vertex_from_dxf (std::ifstream &amp; dxfFile)  void write_to_crt (const fs::path &amp; filename)  void write_to_dxf (const std::vector&lt; Polyline &gt; &amp; polylines, const fs::path &amp; filename)  void write_to_dxf (std::vector&lt; Contour &gt; contours, const fs::path &amp; filename, const ContourConfigs &amp; contour_configs)  void write_to_dxf (const std::vector&lt; Stream &gt; &amp; streams, const fs::path &amp; filename, const std::string &amp; layer_name)"},{"location":"blaze/dxf_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/dxf_8hpp/#function-dxf_entities","title":"function dxf_entities","text":"<pre><code>inline std::string dxf_entities () \n</code></pre>"},{"location":"blaze/dxf_8hpp/#function-dxf_footer","title":"function dxf_footer","text":"<pre><code>inline std::string dxf_footer () \n</code></pre>"},{"location":"blaze/dxf_8hpp/#function-dxf_header","title":"function dxf_header","text":"<pre><code>inline std::string dxf_header () \n</code></pre>"},{"location":"blaze/dxf_8hpp/#function-read_dxf","title":"function read_dxf","text":"<pre><code>inline std::vector&lt; Contour &gt; read_dxf (\n    const fs::path &amp; filename\n) \n</code></pre>"},{"location":"blaze/dxf_8hpp/#function-vertex_from_dxf","title":"function vertex_from_dxf","text":"<pre><code>inline Coordinate2D &lt; double &gt; vertex_from_dxf (\n    std::ifstream &amp; dxfFile\n) \n</code></pre>"},{"location":"blaze/dxf_8hpp/#function-write_to_crt","title":"function write_to_crt","text":"<pre><code>inline void write_to_crt (\n    const fs::path &amp; filename\n) \n</code></pre>"},{"location":"blaze/dxf_8hpp/#function-write_to_dxf","title":"function write_to_dxf","text":"<pre><code>inline void write_to_dxf (\n    const std::vector&lt; Polyline &gt; &amp; polylines,\n    const fs::path &amp; filename\n) \n</code></pre>"},{"location":"blaze/dxf_8hpp/#function-write_to_dxf_1","title":"function write_to_dxf","text":"<pre><code>inline void write_to_dxf (\n    std::vector&lt; Contour &gt; contours,\n    const fs::path &amp; filename,\n    const  ContourConfigs &amp; contour_configs\n) \n</code></pre>"},{"location":"blaze/dxf_8hpp/#function-write_to_dxf_2","title":"function write_to_dxf","text":"<pre><code>inline void write_to_dxf (\n    const std::vector&lt; Stream &gt; &amp; streams,\n    const fs::path &amp; filename,\n    const std::string &amp; layer_name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/dxf/dxf.hpp</code></p>"},{"location":"blaze/dxf_8hpp_source/","title":"File dxf.hpp","text":"<p>File List &gt; dxf &gt; dxf.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;methods/water/water.hpp&gt;\n#include &lt;string&gt;\n\n#include \"contour/contour.hpp\"\n#include \"utilities/coordinate.hpp\"\n#include \"utilities/filesystem.hpp\"\n#include \"utilities/timer.hpp\"\n\ninline Coordinate2D&lt;double&gt; vertex_from_dxf(std::ifstream&amp; dxfFile) {\n  std::string line;\n  double x = std::numeric_limits&lt;double&gt;::quiet_NaN(), y = std::numeric_limits&lt;double&gt;::quiet_NaN();\n  while (std::getline(dxfFile, line)) {\n    if (line == \"10\") {\n      dxfFile &gt;&gt; x;\n    } else if (line == \"20\") {\n      dxfFile &gt;&gt; y;\n    } else if (line == \"0\") {\n      return {x, y};\n    } else if (line == \"\") {\n      continue;\n    } else if (line == \"8\") {\n      std::getline(dxfFile, line);\n    } else {\n      std::cout &lt;&lt; \"Unknown entity: \" &lt;&lt; line &lt;&lt; std::endl;\n    }\n  }\n  return {0, 0};\n}\n\nclass Polyline {\n public:\n  std::string layer;\n  std::string name;\n  std::vector&lt;Coordinate2D&lt;double&gt;&gt; vertices;\n\n  void write_to_dxf(std::ofstream&amp; dxfFile) const {\n    bool is_loop = (vertices.front() - vertices.back()).magnitude_sqd() &lt; 1e-10;\n\n    dxfFile &lt;&lt; \"0\\nPOLYLINE\\n\";\n    dxfFile &lt;&lt; \"8\\n\" &lt;&lt; layer &lt;&lt; \"\\n\";\n    dxfFile &lt;&lt; \"2\\n\" &lt;&lt; name &lt;&lt; \"\\n\";\n    dxfFile &lt;&lt; \"70\\n\" &lt;&lt; (is_loop ? 1 : 0) &lt;&lt; \"\\n\";\n    dxfFile &lt;&lt; std::setprecision(10);\n    for (size_t i = 0; i &lt; vertices.size(); i++) {\n      dxfFile &lt;&lt; \"0\\nVERTEX\\n\";\n      dxfFile &lt;&lt; \"8\\n\" &lt;&lt; layer &lt;&lt; \"\\n\";\n      dxfFile &lt;&lt; \"10\\n\" &lt;&lt; vertices[i].x() &lt;&lt; \"\\n\";\n      dxfFile &lt;&lt; \"20\\n\" &lt;&lt; vertices[i].y() &lt;&lt; \"\\n\";\n    }\n    dxfFile &lt;&lt; \"0\\nSEQEND\\n\";\n  }\n\n  static Polyline read_from_dxf(std::ifstream&amp; dxfFile) {\n    std::string line;\n    std::string name;\n    std::string layer;\n    std::vector&lt;Coordinate2D&lt;double&gt;&gt; vertices;\n    while (std::getline(dxfFile, line)) {\n      if (line == \"8\") {\n        std::getline(dxfFile, layer);\n      } else if (line == \"2\") {\n        std::getline(dxfFile, name);\n      } else if (line == \"70\") {\n        std::getline(dxfFile, line);\n        bool is_loop = std::stoi(line);\n        (void)is_loop;\n      } else if (line == \"0\") {\n        continue;\n      } else if (line == \"VERTEX\") {\n        vertices.push_back(vertex_from_dxf(dxfFile));\n      } else {\n        AssertEQ(line, \"SEQEND\");\n        break;\n      }\n    }\n    return Polyline{.layer = layer, .name = name, .vertices = vertices};\n  }\n};\n\ninline std::string dxf_header() {\n  return \"0\\nSECTION\\n\"\n         \"2\\nHEADER\\n\"\n         \"0\\nENDSEC\\n\";\n}\n\ninline std::string dxf_entities() {\n  return \"0\\nSECTION\\n\"\n         \"2\\nENTITIES\\n\";\n}\n\ninline std::string dxf_footer() {\n  return \"0\\nENDSEC\\n\"\n         \"0\\nSECTION\\n\"\n         \"2\\nEOF\\n\"\n         \"0\\nENDSEC\\n\";\n}\n\ninline void write_to_dxf(const std::vector&lt;Polyline&gt;&amp; polylines, const fs::path&amp; filename) {\n  TimeFunction timer(\"writing to DXF\");\n  std::ofstream dxfFile(filename);\n  if (!dxfFile.is_open()) {\n    std::cerr &lt;&lt; \"Failed to open DXF file for writing\\n\";\n    return;\n  }\n\n  dxfFile &lt;&lt; dxf_header();\n  dxfFile &lt;&lt; dxf_entities();\n\n  for (const auto&amp; polyline : polylines) {\n    polyline.write_to_dxf(dxfFile);\n  }\n\n  dxfFile &lt;&lt; dxf_footer();\n  dxfFile.close();\n}\n\ninline void write_to_dxf(std::vector&lt;Contour&gt; contours, const fs::path&amp; filename,\n                         [[maybe_unused]] const ContourConfigs&amp; contour_configs) {\n  TimeFunction timer(\"writing to DXF \" + filename.string());\n  std::vector&lt;Polyline&gt; polylines;\n  for (const auto&amp; contour : contours) {\n    if (contour.points().size() &gt; 1) {\n      polylines.push_back(contour.to_polyline(contour_configs));\n    }\n  }\n  write_to_dxf(polylines, filename);\n}\n\ninline void write_to_dxf(const std::vector&lt;Stream&gt;&amp; streams, const fs::path&amp; filename,\n                         const std::string&amp; layer_name) {\n  TimeFunction timer(\"writing to DXF \" + filename.string());\n  std::vector&lt;Polyline&gt; polylines;\n  for (const auto&amp; stream : streams) {\n    polylines.push_back(\n        {.layer = layer_name, .name = std::to_string(stream.catchment), .vertices = stream.coords});\n  }\n  write_to_dxf(polylines, filename);\n}\n\ninline std::vector&lt;Contour&gt; read_dxf(const fs::path&amp; filename) {\n  TimeFunction timer(\"reading DXF \" + filename.string());\n  std::vector&lt;Contour&gt; contours;\n\n  std::ifstream dxfFile(filename);\n  if (!dxfFile.is_open()) {\n    std::cerr &lt;&lt; \"Failed to open DXF file for reading\\n\";\n    return contours;\n  }\n\n  std::string line;\n  while (std::getline(dxfFile, line)) {\n    if (line == \"0\") {\n      std::getline(dxfFile, line);\n      if (line == \"POLYLINE\") {\n        contours.emplace_back(Contour::from_polyline(Polyline::read_from_dxf(dxfFile)));\n      }\n    }\n  }\n\n  dxfFile.close();\n  return contours;\n}\n\ninline void write_to_crt(const fs::path&amp; filename) {\n  TimeFunction timer(\"writing to CRT\");\n\n  std::ofstream crtFile(filename);\n  if (!crtFile.is_open()) {\n    std::cerr &lt;&lt; \"Failed to open CRT file for writing\\n\";\n    return;\n  }\n  // ISOM 2017-2 and ISSprOM 2019-2 compliant :)\n  // First column represents OOM symbol to create, second column is dxf layer name\n  crtFile &lt;&lt; \"101 101_Contour\\n\";\n  crtFile &lt;&lt; \"102 102_Index_Contour\\n\";\n  crtFile &lt;&lt; \"103 103_Form_Line\\n\";\n  crtFile &lt;&lt; \"109 109_Small_Knoll\\n\";\n  crtFile &lt;&lt; \"111 111_Small_Depression\\n\";\n  crtFile &lt;&lt; \"115 115_Prominent_Landform_Feature\\n\";\n  crtFile &lt;&lt; \"201 201_Impassable_Cliff\\n\";\n  crtFile &lt;&lt; \"202 202_Cliff\\n\";\n  crtFile &lt;&lt; \"204 204_Boulder\\n\";\n  crtFile &lt;&lt; \"205 205_Large_Boulder\\n\";\n  crtFile &lt;&lt; \"206 206_Gigantic_Boulder_Or_Rock_Pillar\\n\";\n  crtFile &lt;&lt; \"301 301_Uncrossable_Body_Of_Water\\n\";\n  crtFile &lt;&lt; \"302 302_Shallow_Body_Of_Water\\n\";\n  crtFile &lt;&lt; \"304 304_Crossable_Watercourse\\n\";\n  crtFile &lt;&lt; \"313 313_Prominent_Water_Feature\\n\";\n  crtFile &lt;&lt; \"401 401_Open_Land\\n\";\n  crtFile &lt;&lt; \"403 403_Rough_Open_Land\\n\";\n  crtFile &lt;&lt; \"405 405_Forest\\n\";\n  crtFile &lt;&lt; \"406 406_Vegetation:_Slow_Running\\n\";\n  crtFile &lt;&lt; \"407 407_Vegetation:_Slow_Running,_Good_Visibility\\n\";\n  crtFile &lt;&lt; \"408 408_Vegetation:_Walk\\n\";\n  crtFile &lt;&lt; \"409 409_Vegetation:_Walk,_Good_Visibility\\n\";\n  crtFile &lt;&lt; \"410 410_Vegetation:_Fight\\n\";\n  crtFile &lt;&lt; \"419 419_Prominent_Vegetation_Feature\\n\";\n  crtFile &lt;&lt; \"531 531_Prominent_Man-made_Feature-X\\n\";\n\n  crtFile.close();\n}\n</code></pre>"},{"location":"blaze/dir_b440d1ddeab29faa8ab1c63476ee276f/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/grid","text":"<p>FileList &gt; grid</p>"},{"location":"blaze/dir_b440d1ddeab29faa8ab1c63476ee276f/#files","title":"Files","text":"Type Name file forward_grid.hpp file grid.cpp file grid.hpp file grid_ops.hpp file img_grid.cpp file img_grid.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/</code></p>"},{"location":"blaze/forward__grid_8hpp/","title":"File forward_grid.hpp","text":"<p>FileList &gt; grid &gt; forward_grid.hpp</p> <p>Go to the source code of this file</p>"},{"location":"blaze/forward__grid_8hpp/#public-types","title":"Public Types","text":"Type Name typedef Geo&lt; Grid&lt; T &gt; &gt; GeoGrid"},{"location":"blaze/forward__grid_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/forward__grid_8hpp/#typedef-geogrid","title":"typedef GeoGrid","text":"<pre><code>using GeoGrid =  Geo&lt;Grid&lt;T&gt; &gt;;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/forward_grid.hpp</code></p>"},{"location":"blaze/forward__grid_8hpp_source/","title":"File forward_grid.hpp","text":"<p>File List &gt; grid &gt; forward_grid.hpp</p> <p>Go to the documentation of this file</p> <pre><code>template &lt;typename T&gt;\nclass Geo;\n\ntemplate &lt;typename T&gt;\nclass Grid;\n\ntemplate &lt;typename T&gt;\nusing GeoGrid = Geo&lt;Grid&lt;T&gt;&gt;;\n</code></pre>"},{"location":"blaze/grid_8cpp/","title":"File grid.cpp","text":"<p>FileList &gt; grid &gt; grid.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"grid.hpp\"</code></li> <li><code>#include \"gdal_priv.h\"</code></li> <li><code>#include \"img_grid.hpp\"</code></li> <li><code>#include \"isom/colors.hpp\"</code></li> <li><code>#include \"las/las_point.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/grid_8cpp/#public-functions","title":"Public Functions","text":"Type Name T interpolate_value (const GeoGrid&lt; T &gt; &amp; grid, const Coordinate2D&lt; double &gt; &amp; projection_coord)  template double interpolate_value (const GeoGrid&lt; double &gt; &amp; grid, const Coordinate2D&lt; double &gt; &amp; projection_coord)  Geo&lt; GridT &gt; same_type_different_size (const Geo&lt; GridT &gt; &amp; grid, size_t new_width, size_t new_height, const Coordinate2D&lt; double &gt; &amp; new_top_left)"},{"location":"blaze/grid_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/grid_8cpp/#function-interpolate_value","title":"function interpolate_value","text":"<pre><code>template&lt;typename T&gt;\nT interpolate_value (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    const  Coordinate2D &lt; double &gt; &amp; projection_coord\n) \n</code></pre>"},{"location":"blaze/grid_8cpp/#function-interpolate_value_1","title":"function interpolate_value","text":"<pre><code>template  double interpolate_value (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    const  Coordinate2D &lt; double &gt; &amp; projection_coord\n) \n</code></pre>"},{"location":"blaze/grid_8cpp/#function-same_type_different_size","title":"function same_type_different_size","text":"<pre><code>template&lt;typename GridT&gt;\nGeo &lt; GridT &gt; same_type_different_size (\n    const  Geo &lt; GridT &gt; &amp; grid,\n    size_t new_width,\n    size_t new_height,\n    const  Coordinate2D &lt; double &gt; &amp; new_top_left\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.cpp</code></p>"},{"location":"blaze/grid_8cpp_source/","title":"File grid.cpp","text":"<p>File List &gt; grid &gt; grid.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"grid.hpp\"\n\n#include \"gdal_priv.h\"\n#include \"img_grid.hpp\"\n#include \"isom/colors.hpp\"\n#include \"las/las_point.hpp\"\n#include \"utilities/timer.hpp\"\n\nGeoTransform::GeoTransform(GDALDataset&amp; dataset) { dataset.GetGeoTransform(geoTransform); }\n\ntemplate &lt;typename GridT&gt;\nGeoGrid&lt;RGBColor&gt; Geo&lt;GridT&gt;::FromGeoImg(const GeoImgGrid&amp; grid) {\n  TimeFunction timer(\"FromGeoImg\");\n  GeoGrid&lt;RGBColor&gt; new_grid(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                             GeoProjection(grid.projection()));\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      new_grid[{j, i}] = grid.get_rgb_color(i, j);\n    }\n  }\n  return new_grid;\n}\n\ntemplate &lt;typename T&gt;\nvoid Grid&lt;T&gt;::fill_from(const FlexGrid&amp; other, const Coordinate2D&lt;long long&gt;&amp; top_left) {\n  AssertEQ(other.n_bytes(), sizeof(T));\n  for (size_t i = 0; i &lt; height(); i++) {\n    for (size_t j = 0; j &lt; width(); j++) {\n      (*this)[{j, i}] = other.get&lt;T&gt;(top_left + Coordinate2D&lt;long long&gt;(j, i));\n    }\n  }\n}\n\ntemplate class Grid&lt;double&gt;;\ntemplate class Grid&lt;float&gt;;\n\ntemplate &lt;typename GridT&gt;\nGeo&lt;GridT&gt; same_type_different_size(const Geo&lt;GridT&gt;&amp; grid, size_t new_width, size_t new_height,\n                                    const Coordinate2D&lt;double&gt;&amp; new_top_left) {\n  if constexpr (is_specialization_v&lt;GridT, Grid&gt;) {\n    return Geo&lt;GridT&gt;(GeoTransform(new_top_left.x(), new_top_left.y(), grid.transform().dx(),\n                                   grid.transform().dy()),\n                      GeoProjection(grid.projection()), new_width, new_height);\n  } else if constexpr (is_specialization_v&lt;GridT, MultiBand&gt;) {\n    return Geo&lt;GridT&gt;(GeoTransform(new_top_left.x(), new_top_left.y(), grid.transform().dx(),\n                                   grid.transform().dy()),\n                      GeoProjection(grid.projection()), grid.size(), new_width, new_height,\n                      grid[0].n_bytes(), grid[0].data_type());\n  } else {\n    static_assert(is_specialization_v&lt;GridT, Grid&gt;);\n  }\n}\n\ntemplate &lt;typename GridT&gt;\nGeo&lt;GridT&gt; Geo&lt;GridT&gt;::slice(const Extent2D&amp; extent) {\n  Coordinate2D&lt;size_t&gt; top_left = transform().projection_to_pixel({extent.minx, extent.maxy});\n  Coordinate2D&lt;size_t&gt; bottom_right = transform().projection_to_pixel({extent.maxx, extent.miny});\n  size_t new_width = bottom_right.x() - top_left.x();\n  size_t new_height = bottom_right.y() - top_left.y();\n\n  Coordinate2D&lt;double&gt; new_top_left = transform().pixel_to_projection(top_left);\n  Geo result = same_type_different_size(*this, new_width, new_height, new_top_left);\n  if constexpr (is_specialization_v&lt;GridT, Grid&gt;) {\n#pragma omp parallel for\n    for (size_t i = 0; i &lt; new_height; i++) {\n      for (size_t j = 0; j &lt; new_width; j++) {\n        result[{j, i}] = (*this)[{j + top_left.x(), i + top_left.y()}];\n      }\n    }\n  } else if constexpr (std::is_same_v&lt;GridT, FlexGrid&gt;) {\n#pragma omp parallel for\n    for (size_t i = 0; i &lt; new_height; i++) {\n      for (size_t j = 0; j &lt; new_width; j++) {\n        for (int k = 0; k &lt; FlexGrid::m_data_size; k++) {\n          result[{j, i}][k] = (*this)[{j + top_left.x(), i + top_left.y()}][k];\n        }\n      }\n    }\n  } else if constexpr (std::is_same_v&lt;GridT, MultiBand&lt;FlexGrid&gt;&gt;) {\n    for (size_t band = 0; band &lt; result.size(); band++) {\n#pragma omp parallel for\n      for (size_t i = 0; i &lt; new_height; i++) {\n        for (size_t j = 0; j &lt; new_width; j++) {\n          for (unsigned int k = 0; k &lt; (*this)[band].n_bytes(); k++) {\n            result[band][{j, i}][k] = (*this)[band][{j + top_left.x(), i + top_left.y()}][k];\n          }\n        }\n      }\n    }\n  } else {\n    static_assert(is_specialization_v&lt;GridT, Grid&gt;);\n  }\n  return result;\n}\n\ntemplate &lt;typename GridT&gt;\nstd::unique_ptr&lt;Extent2D&gt; Geo&lt;GridT&gt;::extent() const {\n  Coordinate2D&lt;double&gt; top_left = transform().pixel_to_projection({0, 0});\n  Coordinate2D&lt;double&gt; bottom_right =\n      transform().pixel_to_projection({(double)GridT::width(), (double)GridT::height()});\n  double min_x = std::min(top_left.x(), bottom_right.x());\n  double max_x = std::max(top_left.x(), bottom_right.x());\n  double min_y = std::min(top_left.y(), bottom_right.y());\n  double max_y = std::max(top_left.y(), bottom_right.y());\n  return std::make_unique&lt;Extent2D&gt;(min_x, max_x, min_y, max_y);\n}\n\ntemplate class Geo&lt;Grid&lt;double&gt;&gt;;\ntemplate class Geo&lt;Grid&lt;float&gt;&gt;;\ntemplate class Geo&lt;Grid&lt;RGBColor&gt;&gt;;\ntemplate class Geo&lt;Grid&lt;CMYKColor&gt;&gt;;\ntemplate class Geo&lt;Grid&lt;std::optional&lt;double&gt;&gt;&gt;;\ntemplate class Geo&lt;Grid&lt;std::optional&lt;float&gt;&gt;&gt;;\ntemplate class Geo&lt;Grid&lt;std::optional&lt;std::byte&gt;&gt;&gt;;\ntemplate class Geo&lt;Grid&lt;std::byte&gt;&gt;;\ntemplate class Geo&lt;Grid&lt;std::optional&lt;LASPoint&gt;&gt;&gt;;\ntemplate class Geo&lt;Grid&lt;std::vector&lt;LASPoint&gt;&gt;&gt;;\n\ntemplate class Geo&lt;MultiBand&lt;FlexGrid&gt;&gt;;\n\ntemplate &lt;typename T&gt;\nT interpolate_value(const GeoGrid&lt;T&gt;&amp; grid, const Coordinate2D&lt;double&gt;&amp; projection_coord) {\n  Coordinate2D&lt;double&gt; pixel_coord = grid.transform().projection_to_pixel(projection_coord);\n  if (pixel_coord.x() &lt; 0 || pixel_coord.y() &lt; 0 || pixel_coord.x() &gt;= grid.width() ||\n      pixel_coord.y() &gt;= grid.height()) {\n    std::cout &lt;&lt; \"Interpolation out of bounds\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Projection coord: \" &lt;&lt; projection_coord &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Pixel coord: \" &lt;&lt; pixel_coord &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Grid size: \" &lt;&lt; grid.width() &lt;&lt; \", \" &lt;&lt; grid.height() &lt;&lt; std::endl;\n    Fail(\"Interpolation out of bounds\");\n  }\n  if (pixel_coord.x() &lt;= 0.5 || pixel_coord.y() &lt;= 0.5 || pixel_coord.x() &gt;= grid.width() - 0.5 ||\n      pixel_coord.y() &gt;= grid.height() - 0.5) {\n    return grid[{static_cast&lt;size_t&gt;(pixel_coord.x()), static_cast&lt;size_t&gt;(pixel_coord.y())}];\n  }\n  size_t x = static_cast&lt;size_t&gt;(pixel_coord.x() - 0.5);\n  size_t y = static_cast&lt;size_t&gt;(pixel_coord.y() - 0.5);\n  if (x &gt;= grid.width() || y &gt;= grid.height()) {\n    Fail(\"Interpolation out of bounds\");\n  }\n  double x_frac = pixel_coord.x() - 0.5 - x;\n  double y_frac = pixel_coord.y() - 0.5 - y;\n  auto top_left = grid[{x, y}];\n  auto top_right = grid[{x + 1, y}];\n  auto bottom_left = grid[{x, y + 1}];\n  auto bottom_right = grid[{x + 1, y + 1}];\n  AssertGE(x_frac, 0);\n  AssertLE(x_frac, 1);\n  AssertGE(y_frac, 0);\n  AssertLE(y_frac, 1);\n  return top_left * (1 - x_frac) * (1 - y_frac) + top_right * x_frac * (1 - y_frac) +\n         bottom_left * (1 - x_frac) * y_frac + bottom_right * x_frac * y_frac;\n}\n\ntemplate double interpolate_value(const GeoGrid&lt;double&gt;&amp; grid,\n                                  const Coordinate2D&lt;double&gt;&amp; projection_coord);\nFlexGrid::FlexGrid(size_t width, size_t height, int n_bytes, int data_type)\n    : GridData(width, height),\n      m_data_size(n_bytes),\n      m_data_type(std::move(data_type)),\n      m_data(width * height * n_bytes) {\n  std::fill(m_data.begin(), m_data.end(), std::byte(0));\n}\nint FlexGrid::data_type() const { return m_data_type; }\n</code></pre>"},{"location":"blaze/grid_8hpp/","title":"File grid.hpp","text":"<p>FileList &gt; grid &gt; grid.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"assert/assert.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> </ul>"},{"location":"blaze/grid_8hpp/#classes","title":"Classes","text":"Type Name struct BlazeBool class FlexGrid class Geo &lt;typename GridT&gt; class GeoGridData class GeoProjection class GeoTransform class Grid &lt;typename U&gt; class GridData class GridGraph &lt;typename T&gt; class MultiBand &lt;typename GridT&gt; struct is_specialization &lt;typename Test, Ref&gt; struct is_specialization&lt; Ref&lt; Args... &gt;, Ref &gt; &lt;Ref, Args&gt;"},{"location":"blaze/grid_8hpp/#public-types","title":"Public Types","text":"Type Name typedef Geo&lt; FlexGrid &gt; GeoFlexGrid typedef Geo&lt; Grid&lt; T &gt; &gt; GeoGrid"},{"location":"blaze/grid_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr bool is_specialization_v   = <code>[**is\\_specialization**](structis__specialization.md)&amp;lt;[**Type**](classCoordinate2D.md), [**Template**](classCoordinate2D.md)&amp;gt;::value</code>"},{"location":"blaze/grid_8hpp/#public-functions","title":"Public Functions","text":"Type Name T interpolate_value (const GeoGrid&lt; T &gt; &amp; grid, const Coordinate2D&lt; double &gt; &amp; projection_coord)"},{"location":"blaze/grid_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/grid_8hpp/#typedef-geoflexgrid","title":"typedef GeoFlexGrid","text":"<pre><code>typedef Geo&lt;FlexGrid&gt; GeoFlexGrid;\n</code></pre>"},{"location":"blaze/grid_8hpp/#typedef-geogrid","title":"typedef GeoGrid","text":"<pre><code>using GeoGrid =  Geo&lt;Grid&lt;T&gt; &gt;;\n</code></pre>"},{"location":"blaze/grid_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/grid_8hpp/#variable-is_specialization_v","title":"variable is_specialization_v","text":"<pre><code>constexpr bool is_specialization_v;\n</code></pre>"},{"location":"blaze/grid_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/grid_8hpp/#function-interpolate_value","title":"function interpolate_value","text":"<pre><code>template&lt;typename T&gt;\nT interpolate_value (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    const  Coordinate2D &lt; double &gt; &amp; projection_coord\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid.hpp</code></p>"},{"location":"blaze/grid_8hpp_source/","title":"File grid.hpp","text":"<p>File List &gt; grid &gt; grid.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstring&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#include \"assert/assert.hpp\"\n#include \"utilities/coordinate.hpp\"\n\nclass GDALDataset;\nclass RGBColor;\n\nclass GeoTransform {\n  double geoTransform[6];\n\n public:\n  GeoTransform(double upper_left_x, double upper_left_y, double dx = 1.0, double dy = -1.0) {\n    geoTransform[0] = upper_left_x;  // center of top left pixel is 0.5, 0.5\n    geoTransform[1] = dx;            // w-&gt;e pixel resolution\n    geoTransform[2] = 0;             // Row rotation\n    geoTransform[3] = upper_left_y;\n    geoTransform[4] = 0;   // Column rotation\n    geoTransform[5] = dy;  // n-&gt;s pixel resolution (so negative is up)\n  }\n\n  explicit GeoTransform(const Coordinate2D&lt;double&gt;&amp; upper_left, double resolution)\n      : GeoTransform(upper_left.x(), upper_left.y(), resolution, -resolution) {}\n\n  GeoTransform() : GeoTransform(0, 0, 1, -1) {};\n\n  explicit GeoTransform(GDALDataset&amp; dataset);\n\n  const double* get_raw() const { return geoTransform; }\n\n  GeoTransform with_new_resolution(double new_resolution) const {\n    return GeoTransform(x(), y(), new_resolution, -new_resolution);\n  }\n\n  Coordinate2D&lt;double&gt; pixel_to_projection(const Coordinate2D&lt;double&gt;&amp; coord) const {\n    double new_x = x() + coord.x() * dx() + coord.y() * rot_x();\n    double new_y = y() + coord.y() * dy() + coord.x() * rot_y();\n    return {new_x, new_y};\n  }\n\n  Coordinate2D&lt;double&gt; projection_to_pixel(const Coordinate2D&lt;double&gt;&amp; coord) const {\n    double new_x = (rot_x() * coord.y() - coord.x() * dy() - y() * rot_x() + x() * dy()) /\n                   (rot_x() * rot_y() - dy() * dx());\n    double new_y = (rot_y() * coord.x() - coord.y() * dx() - x() * rot_y() + y() * dx()) /\n                   (rot_x() * rot_y() - dy() * dx());\n    return {new_x, new_y};\n  }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const GeoTransform&amp; transform) {\n    os &lt;&lt; \"GeoTransform(x: \" &lt;&lt; transform.x() &lt;&lt; \", y: \" &lt;&lt; transform.y()\n       &lt;&lt; \", dx: \" &lt;&lt; transform.dx() &lt;&lt; \", dy: \" &lt;&lt; transform.dy()\n       &lt;&lt; \", rot_x: \" &lt;&lt; transform.rot_x() &lt;&lt; \", rot_y: \" &lt;&lt; transform.rot_y() &lt;&lt; \")\";\n    return os;\n  }\n\n  double x() const { return geoTransform[0]; }\n  double dx() const { return geoTransform[1]; }\n  double rot_x() const { return geoTransform[2]; }\n  double y() const { return geoTransform[3]; }\n  double rot_y() const { return geoTransform[4]; }\n  double dy() const { return geoTransform[5]; }\n\n  void set_dx(double dx) { geoTransform[1] = dx; }\n  void set_dy(double dy) { geoTransform[5] = dy; }\n};\n\nclass GeoProjection {\n  std::string m_projection;\n\n public:\n  explicit GeoProjection(const std::string&amp; projection) : m_projection(projection) {}\n\n  GeoProjection() = default;\n\n  const std::string&amp; to_string() const { return m_projection; }\n};\n\nclass GridData {\n protected:\n  size_t m_width;\n  size_t m_height;\n\n public:\n  GridData(size_t width, size_t height) : m_width(width), m_height(height) {}\n\n  size_t width() const { return m_width; }\n  size_t height() const { return m_height; }\n\n  bool in_bounds(const Coordinate2D&lt;size_t&gt;&amp; coord) const {\n    return coord.x() &lt; m_width &amp;&amp; coord.y() &lt; m_height;\n  }\n};\n\nstruct BlazeBool {\n  bool value;\n  BlazeBool(bool value) : value(value) {}\n  BlazeBool() : value(false) {}\n  BlazeBool&amp; operator=(bool new_value) {\n    this-&gt;value = new_value;\n    return *this;\n  }\n  operator bool() const { return value; }\n};\n\nclass FlexGrid;\n\ntemplate &lt;typename U&gt;\nclass Grid : public GridData {\n protected:\n  using T = std::conditional_t&lt;std::is_same_v&lt;U, bool&gt;, BlazeBool, U&gt;;\n\n  std::vector&lt;T&gt; m_data;\n  int m_repeats;\n\n public:\n  Grid(size_t width, size_t height, int repeats = 1)\n      : GridData(width, height), m_data(width * height * repeats), m_repeats(repeats) {}\n\n  T&amp; operator[](Coordinate2D&lt;size_t&gt; coord) {\n    return m_data.at(coord.y() * width() * m_repeats + coord.x() * m_repeats);\n  }\n  const T&amp; operator[](Coordinate2D&lt;size_t&gt; coord) const {\n    return m_data.at(coord.y() * width() * m_repeats + coord.x() * m_repeats);\n  }\n\n  std::pair&lt;T, T&gt; get_values(const LineCoord2D&lt;size_t&gt;&amp; coord) const {\n    return {(*this)[coord.start()], (*this)[coord.end()]};\n  }\n\n  void fill(const T&amp; value) { std::fill(m_data.begin(), m_data.end(), value); }\n\n  void copy_from(const Grid&amp; other) {\n    AssertEQ(width(), other.width());\n    AssertEQ(height(), other.height());\n    AssertEQ(m_data.size(), other.m_data.size());\n    m_data = other.m_data;\n  }\n\n  T max_value() const { return *std::max_element(m_data.begin(), m_data.end()); }\n  T min_value() const { return *std::min_element(m_data.begin(), m_data.end()); }\n\n  typedef T value_type;\n\n  void fill_from(const Grid&amp; other, const Coordinate2D&lt;size_t&gt;&amp; top_left = {0, 0}) {\n#pragma omp parallel for\n    for (size_t i = 0; i &lt; other.height(); i++) {\n      for (size_t j = 0; j &lt; other.width(); j++) {\n        if (this-&gt;in_bounds(top_left + Coordinate2D&lt;size_t&gt;{j, i}))\n          (*this)[top_left + Coordinate2D&lt;size_t&gt;{j, i}] = other[{j, i}];\n      }\n    }\n  }\n\n  void fill_from(const FlexGrid&amp; other, const Coordinate2D&lt;long long&gt;&amp; top_left = {0, 0});\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Grid&amp; grid) {\n    os &lt;&lt; \"Grid&lt;\" &lt;&lt; typeid(T).name() &lt;&lt; \"&gt;(\" &lt;&lt; grid.width() &lt;&lt; \", \" &lt;&lt; grid.height() &lt;&lt; \")\"\n       &lt;&lt; std::endl;\n    for (size_t i = 0; i &lt; grid.height(); i++) {\n      for (size_t j = 0; j &lt; grid.width(); j++) {\n        if constexpr (std::is_same_v&lt;T, char&gt;) {\n          os &lt;&lt; (grid[{j, i}] ? \"X\" : \"_\");\n        } else {\n          os &lt;&lt; grid[{j, i}];\n        }\n      }\n      os &lt;&lt; std::endl;\n    }\n    return os;\n  }\n};\n\nclass FlexGrid : public GridData {\n protected:\n  unsigned int m_data_size;\n  int m_data_type;\n  std::vector&lt;std::byte&gt; m_data;\n\n public:\n  FlexGrid(size_t width, size_t height, int n_bytes, int data_type = {});\n\n  std::byte* operator[](Coordinate2D&lt;size_t&gt; coord) {\n    return m_data.data() + coord.y() * width() * m_data_size + coord.x() * m_data_size;\n  }\n  const std::byte* operator[](Coordinate2D&lt;size_t&gt; coord) const {\n    return m_data.data() + coord.y() * width() * m_data_size + coord.x() * m_data_size;\n  }\n\n  template &lt;typename T&gt;\n  T get(const Coordinate2D&lt;long long&gt;&amp; coord) const {\n    return *reinterpret_cast&lt;const T*&gt;(m_data.data() + coord.y() * width() * m_data_size +\n                                       coord.x() * m_data_size);\n  }\n\n  void fill_from(const FlexGrid&amp; other, const Coordinate2D&lt;long long&gt;&amp; top_left = {0, 0}) {\n#pragma omp parallel for\n    for (size_t i = 0; i &lt; other.height(); i++) {\n      Coordinate2D&lt;long long&gt; start(std::max(top_left.x(), 0ll), (top_left.y() + i));\n      size_t diff = start.x() - top_left.x();\n      long long num_elements = std::min((long long)other.width(), (long long)width() - start.x());\n      if (this-&gt;in_bounds(start) &amp;&amp; num_elements &gt; 0) {\n        std::memcpy((*this)[start], other[{diff, i}], num_elements * m_data_size);\n      }\n    }\n  }\n\n  std::byte* data() { return m_data.data(); }\n  const std::byte* data() const { return m_data.data(); }\n  unsigned int n_bytes() const { return m_data_size; }\n  int data_type() const;\n};\n\ntemplate &lt;typename GridT&gt;\nclass MultiBand {\n  std::vector&lt;GridT&gt; m_grids;\n\n public:\n  template &lt;typename... Args&gt;\n  MultiBand(int n_bands, Args... args) {\n    m_grids.reserve(n_bands);\n    for (int i = 0; i &lt; n_bands; i++) {\n      m_grids.emplace_back(std::forward&lt;Args&gt;(args)...);\n    }\n  }\n\n  MultiBand(size_t width, size_t height) {\n    (void)width;\n    (void)height;\n    Unimplemented();\n  }\n\n  size_t size() const { return m_grids.size(); }\n  size_t width() const { return m_grids[0].width(); }\n  size_t height() const { return m_grids[0].height(); }\n  bool in_bounds(const Coordinate2D&lt;size_t&gt;&amp; coord) const { return m_grids[0].in_bounds(coord); }\n\n  void fill_from(const MultiBand&amp; other, const Coordinate2D&lt;size_t&gt;&amp; top_left = {0, 0}) {\n    AssertEQ(size(), other.size());\n    for (size_t i = 0; i &lt; size(); i++) {\n      m_grids[i].fill_from(other[i], top_left);\n    }\n  }\n\n  GridT&amp; operator[](size_t i) { return m_grids[i]; }\n  const GridT&amp; operator[](size_t i) const { return m_grids[i]; }\n};\n\nclass GeoGridData {\n protected:\n  GeoTransform m_transform;\n  GeoProjection m_projection;\n\n public:\n  GeoGridData(GeoTransform&amp;&amp; transform, GeoProjection&amp;&amp; projection)\n      : m_transform(transform), m_projection(projection) {}\n\n  const GeoTransform&amp; transform() const { return m_transform; }\n  const GeoProjection&amp; projection() const { return m_projection; }\n\n  double dx() const { return m_transform.dx(); }\n  double dy() const { return m_transform.dy(); }\n};\n\ntemplate &lt;typename Test, template &lt;typename...&gt; class Ref&gt;\nstruct is_specialization : std::false_type {};\n\ntemplate &lt;template &lt;typename...&gt; class Ref, typename... Args&gt;\nstruct is_specialization&lt;Ref&lt;Args...&gt;, Ref&gt; : std::true_type {};\n\ntemplate &lt;class Type, template &lt;typename...&gt; class Template&gt;\ninline constexpr bool is_specialization_v = is_specialization&lt;Type, Template&gt;::value;\n\nclass GeoImgGrid;\n\ntemplate &lt;typename GridT&gt;\nclass Geo : public GridT, public GeoGridData {\n public:\n  Geo(size_t width, size_t height, GeoTransform&amp;&amp; transform, GeoProjection&amp;&amp; projection)\n      : GridT(width, height), GeoGridData(std::move(transform), std::move(projection)) {}\n\n  template &lt;typename... Args&gt;\n  Geo(GeoTransform&amp;&amp; transform, GeoProjection&amp;&amp; projection, Args... args)\n      : GridT(args...), GeoGridData(std::move(transform), std::move(projection)) {}\n\n  double width_m() const { return GridT::width() * dx(); }\n  double height_m() const { return GridT::height() * dx(); }\n\n  template &lt;typename U&gt;\n  static Geo FromPoints(const Geo&amp; grid) {\n    return Geo(grid.width() - 1, grid.height() - 1,\n               GeoTransform(grid.transform().x() + grid.transform().dx() / 2,\n                            grid.transform().y() + grid.transform().dy() / 2, grid.transform().dx(),\n                            grid.transform().dy()),\n               grid.projection());\n  }\n\n  static Geo&lt;Grid&lt;RGBColor&gt;&gt; FromGeoImg(const GeoImgGrid&amp; grid);\n\n  Geo slice(const Extent2D&amp; extent);\n  std::unique_ptr&lt;Extent2D&gt; extent() const;\n\n  template &lt;typename U&gt;\n  void fill_from(const Geo&lt;U&gt;&amp; other) {\n    Coordinate2D&lt;size_t&gt; top_left =\n        transform().projection_to_pixel(other.transform().pixel_to_projection({0, 0})).round();\n    GridT::fill_from(other, top_left);\n  }\n\n  template &lt;typename U&gt;\n  void fill_from(const U&amp; other) {\n    GridT::fill_from(other);\n  }\n};\n\ntemplate &lt;typename T&gt;\nusing GeoGrid = Geo&lt;Grid&lt;T&gt;&gt;;\n\ntypedef Geo&lt;FlexGrid&gt; GeoFlexGrid;\n\ntemplate &lt;typename T&gt;\nclass GridGraph {\n  Grid&lt;T&gt; m_horizontal;\n  Grid&lt;T&gt; m_vertical;\n\n public:\n  template &lt;typename U&gt;\n  explicit GridGraph(const Grid&lt;U&gt;&amp; grid)\n      : m_horizontal(grid.width() - 1, grid.height()),\n        m_vertical(grid.width(), grid.height() - 1) {}\n\n  Grid&lt;T&gt;&amp; horizontal() { return m_horizontal; }\n  Grid&lt;T&gt;&amp; vertical() { return m_vertical; }\n  const Grid&lt;T&gt;&amp; horizontal() const { return m_horizontal; }\n  const Grid&lt;T&gt;&amp; vertical() const { return m_vertical; }\n\n  size_t width() const { return m_vertical.width(); }\n  size_t height() const { return m_horizontal.height(); }\n\n  const T&amp; operator[](const LineCoord2D&lt;size_t&gt;&amp; coord) const {\n    if (coord.dir() == Direction2D::DOWN) {\n      return m_vertical[Coordinate2D&lt;size_t&gt;(coord.x(), coord.y())];\n    } else if (coord.dir() == Direction2D::RIGHT) {\n      return m_horizontal[Coordinate2D&lt;size_t&gt;(coord.x(), coord.y())];\n    }\n    Fail(\"Invalid direction\");\n  }\n  T&amp; operator[](const LineCoord2D&lt;size_t&gt;&amp; coord) {\n    return const_cast&lt;T&amp;&gt;(static_cast&lt;const GridGraph*&gt;(this)-&gt;operator[](coord));\n  }\n\n  template &lt;typename U&gt;\n  bool in_bounds(const LineCoord2D&lt;U&gt;&amp; coord) const {\n    if (coord.x() &lt; 0 || coord.y() &lt; 0) {\n      return false;\n    }\n    if (coord.dir() == Direction2D::DOWN) {\n      return coord.x() &lt; width() &amp;&amp; coord.y() &lt; std::numeric_limits&lt;U&gt;::max() &amp;&amp;\n             coord.y() + 1 &lt; height();\n    } else if (coord.dir() == Direction2D::RIGHT) {\n      return coord.x() &lt; std::numeric_limits&lt;U&gt;::max() &amp;&amp; coord.x() + 1 &lt; width() &amp;&amp;\n             coord.y() &lt; height();\n    }\n    Fail(\"Invalid direction\");\n  }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const GridGraph&amp; graph) {\n    os &lt;&lt; \"GridGraph(\" &lt;&lt; graph.width() &lt;&lt; \", \" &lt;&lt; graph.height() &lt;&lt; \")\" &lt;&lt; std::endl;\n    os &lt;&lt; \"Horizontal:\" &lt;&lt; std::endl;\n    os &lt;&lt; graph.horizontal() &lt;&lt; std::endl;\n    os &lt;&lt; \"Vertical:\" &lt;&lt; std::endl;\n    os &lt;&lt; graph.vertical() &lt;&lt; std::endl;\n    return os;\n  }\n};\n\ntemplate &lt;typename T&gt;\nT interpolate_value(const GeoGrid&lt;T&gt;&amp; grid, const Coordinate2D&lt;double&gt;&amp; projection_coord);\n</code></pre>"},{"location":"blaze/grid__ops_8hpp/","title":"File grid_ops.hpp","text":"<p>FileList &gt; grid &gt; grid_ops.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include \"grid.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/grid__ops_8hpp/#public-types","title":"Public Types","text":"Type Name enum DownsampleMethod"},{"location":"blaze/grid__ops_8hpp/#public-functions","title":"Public Functions","text":"Type Name GeoGrid&lt; std::optional&lt; std::byte &gt; &gt; bool_grid (const GeoGrid&lt; T &gt; &amp; grid, T threshold)  GeoGrid&lt; T &gt; downsample (const GeoGrid&lt; T &gt; &amp; grid, size_t factor, ProgressTracker &amp;&amp; progress_tracker, DownsampleMethod method=DownsampleMethod::MEDIAN)  bool has_value (double value)  GeoGrid&lt; T &gt; interpolate_holes (const GeoGrid&lt; T &gt; &amp; grid, ProgressTracker progress_tracker)  GeoGrid&lt; T &gt; remove_outliers (const GeoGrid&lt; T &gt; &amp; grid, ProgressTracker progress_tracker, double z_threshold=1, bool z_only=false)"},{"location":"blaze/grid__ops_8hpp/#macros","title":"Macros","text":"Type Name define SQ (x) <code>((x) \\* (x))</code>"},{"location":"blaze/grid__ops_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/grid__ops_8hpp/#enum-downsamplemethod","title":"enum DownsampleMethod","text":"<pre><code>enum DownsampleMethod {\n    MEAN,\n    MEDIAN\n};\n</code></pre>"},{"location":"blaze/grid__ops_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/grid__ops_8hpp/#function-bool_grid","title":"function bool_grid","text":"<pre><code>template&lt;typename T&gt;\nGeoGrid &lt; std::optional&lt; std::byte &gt; &gt; bool_grid (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    T threshold\n) \n</code></pre>"},{"location":"blaze/grid__ops_8hpp/#function-downsample","title":"function downsample","text":"<pre><code>template&lt;typename T&gt;\nGeoGrid &lt; T &gt; downsample (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    size_t factor,\n    ProgressTracker &amp;&amp; progress_tracker,\n    DownsampleMethod method=DownsampleMethod::MEDIAN\n) \n</code></pre>"},{"location":"blaze/grid__ops_8hpp/#function-has_value","title":"function has_value","text":"<pre><code>bool has_value (\n    double value\n) \n</code></pre>"},{"location":"blaze/grid__ops_8hpp/#function-interpolate_holes","title":"function interpolate_holes","text":"<pre><code>template&lt;typename T&gt;\nGeoGrid &lt; T &gt; interpolate_holes (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    ProgressTracker progress_tracker\n) \n</code></pre>"},{"location":"blaze/grid__ops_8hpp/#function-remove_outliers","title":"function remove_outliers","text":"<pre><code>template&lt;typename T&gt;\nGeoGrid &lt; T &gt; remove_outliers (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    ProgressTracker progress_tracker,\n    double z_threshold=1,\n    bool z_only=false\n) \n</code></pre>"},{"location":"blaze/grid__ops_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"blaze/grid__ops_8hpp/#define-sq","title":"define SQ","text":"<pre><code>#define SQ (\n    x\n) `((x) * (x))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/grid_ops.hpp</code></p>"},{"location":"blaze/grid__ops_8hpp_source/","title":"File grid_ops.hpp","text":"<p>File List &gt; grid &gt; grid_ops.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;limits&gt;\n#include &lt;map&gt;\n#include &lt;numeric&gt;\n#include &lt;optional&gt;\n\n#include \"grid.hpp\"\n#include \"utilities/coordinate.hpp\"\n#include \"utilities/timer.hpp\"\n\nenum class DownsampleMethod { MEAN, MEDIAN };\n\n#define SQ(x) ((x) * (x))\n\ntemplate &lt;typename T&gt;\nGeoGrid&lt;T&gt; downsample(const GeoGrid&lt;T&gt;&amp; grid, size_t factor, ProgressTracker&amp;&amp; progress_tracker,\n                      DownsampleMethod method = DownsampleMethod::MEDIAN) {\n  TimeFunction timer(\"downsampling\", &amp;progress_tracker);\n  AssertEQ(grid.transform().dx(), -grid.transform().dy());\n  GeoGrid&lt;T&gt; result(std::ceil((double)grid.width() / factor),\n                    std::ceil((double)grid.height() / factor),\n                    grid.transform().with_new_resolution(grid.transform().dx() * factor),\n                    GeoProjection(grid.projection()));\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; result.height(); i++) {\n    for (size_t j = 0; j &lt; result.width(); j++) {\n      std::vector&lt;T&gt; values;\n      for (size_t k = 0; k &lt; factor &amp;&amp; i * factor + k &lt; grid.height(); k++) {\n        for (size_t l = 0; l &lt; factor &amp;&amp; j * factor + l &lt; grid.width(); l++) {\n          if (std::isfinite(grid[{j * factor + l, i * factor + k}]))\n            values.push_back(grid[{j * factor + l, i * factor + k}]);\n        }\n      }\n      if (method == DownsampleMethod::MEAN) {\n        result[{j, i}] = std::accumulate(values.begin(), values.end(), 0.0) / values.size();\n      } else if (method == DownsampleMethod::MEDIAN) {\n        std::sort(values.begin(), values.end());\n        if (values.size() &gt; 0)\n          result[{j, i}] = values[values.size() / 2];\n        else\n          result[{j, i}] = std::numeric_limits&lt;double&gt;::quiet_NaN();\n      }\n    }\n  }\n  return result;\n}\n\ntemplate &lt;typename T&gt;\nGeoGrid&lt;T&gt; remove_outliers(const GeoGrid&lt;T&gt;&amp; grid, ProgressTracker progress_tracker,\n                           double z_threshold = 1, bool z_only = false) {\n  TimeFunction timer(\"remove outliers\", &amp;progress_tracker);\n  GeoGrid&lt;T&gt; result(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                    GeoProjection(grid.projection()));\n  result.copy_from(grid);\n  bool no_outliers = false;\n  int iter_count = 0;\n  while (!no_outliers) {\n    iter_count++;\n    no_outliers = true;\n    int num_outliers = 0;\n#pragma omp parallel for reduction(+ : num_outliers)\n    for (size_t i = 0; i &lt; grid.height(); i++) {\n      for (size_t j = 0; j &lt; grid.width(); j++) {\n        if (i == 0 || j == 0 || i == grid.height() - 1 || j == grid.width() - 1) {\n          result[{j, i}] = grid[{j, i}];\n          continue;\n        }\n        T z = result[{j, i}];\n        double max_neighbour = std::max({0.5 * (result[{j - 1, i}] + result[{j + 1, i}]),\n                                         0.5 * (result[{j, i - 1}] + result[{j, i + 1}])});\n        double min_neighbour = std::min({0.5 * (result[{j - 1, i}] + result[{j + 1, i}]),\n                                         0.5 * (result[{j, i - 1}] + result[{j, i + 1}])});\n        if (std::isnan(max_neighbour) || std::isnan(min_neighbour) ||\n            !std::isfinite(max_neighbour) || !std::isfinite(min_neighbour) ||\n            std::abs(max_neighbour) &gt; 1e8 || std::abs(min_neighbour) &gt; 1e8) {\n          continue;\n        }\n        if (min_neighbour - z &gt; z_threshold || z - max_neighbour &gt; z_threshold) {\n          if (!z_only) {\n            double dist_x =\n                (2 * grid.dx() * (result[{j, i}] - result[{j + 1, i}]) -\n                 (result[{j + 1, i}] - result[{j - 1, i}]) * grid.dx()) /\n                std::sqrt(SQ(2 * grid.dx()) + SQ((result[{j + 1, i}] - result[{j - 1, i}])));\n            double dist_y =\n                (2 * grid.dy() * (result[{j, i}] - result[{j, i + 1}]) -\n                 (result[{j, i + 1}] - result[{j, i - 1}]) * grid.dy()) /\n                std::sqrt(SQ(2 * grid.dy()) + SQ((result[{j, i + 1}] - result[{j, i - 1}])));\n            if (std::abs(dist_x) &lt; z_threshold || std::abs(dist_y) &lt; z_threshold) {\n              continue;\n            }\n          }\n          result[{j, i}] = (max_neighbour + min_neighbour) / 2;\n          no_outliers = false;\n          num_outliers++;\n        }\n      }\n    }\n    if (iter_count &gt; 10)\n      std::cerr &lt;&lt; \"Removed \" &lt;&lt; num_outliers &lt;&lt; \" outliers with threshold \" &lt;&lt; z_threshold\n                &lt;&lt; \" on iteration \" &lt;&lt; iter_count &lt;&lt; std::endl;\n  }\n  return result;\n}\n\nbool has_value(double value) { return std::isfinite(value) &amp;&amp; value &lt; 1e6; }\n\ntemplate &lt;typename T&gt;\nGeoGrid&lt;T&gt; interpolate_holes(const GeoGrid&lt;T&gt;&amp; grid, ProgressTracker progress_tracker) {\n  TimeFunction timer(\"interpolate holes\", &amp;progress_tracker);\n  GeoGrid&lt;T&gt; result(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                    GeoProjection(grid.projection()));\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      if (has_value(grid[{j, i}])) {\n        result[{j, i}] = grid[{j, i}];\n      } else {\n        std::map&lt;Direction2D, std::optional&lt;std::pair&lt;size_t, T&gt;&gt;&gt; neighbours;\n        for (Direction2D dir :\n             {Direction2D::UP, Direction2D::DOWN, Direction2D::LEFT, Direction2D::RIGHT}) {\n          neighbours[dir] = std::nullopt;\n          for (size_t k = 1; grid.in_bounds({j + dir.dy() * k, i + dir.dx() * k}); k++) {\n            if (has_value(grid[{j + dir.dy() * k, i + dir.dx() * k}])) {\n              neighbours[dir] = std::pair&lt;size_t, T&gt;(k, grid[{j + dir.dy() * k, i + dir.dx() * k}]);\n              break;\n            }\n          }\n        }\n        T weighted_average = 0;\n        double total_weight = 0;\n        for (auto [dir, neighbour] : neighbours) {\n          if (neighbour.has_value()) {\n            weighted_average += neighbour.value().second / neighbour.value().first;\n            total_weight += 1.0 / neighbour.value().first;\n          }\n        }\n        result[{j, i}] = weighted_average / total_weight;\n        if (total_weight == 0) {\n          result[{j, i}] = 0;\n        }\n      }\n    }\n  }\n  return result;\n}\n\ntemplate &lt;typename T&gt;\nGeoGrid&lt;std::optional&lt;std::byte&gt;&gt; bool_grid(const GeoGrid&lt;T&gt;&amp; grid, T threshold) {\n  TimeFunction timer(\"bool grid\");\n  GeoGrid&lt;std::optional&lt;std::byte&gt;&gt; result(grid.width(), grid.height(),\n                                           GeoTransform(grid.transform()),\n                                           GeoProjection(grid.projection()));\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      result[{j, i}] =\n          grid[{j, i}] &gt; threshold ? std::optional&lt;std::byte&gt;{std::byte{0}} : std::nullopt;\n    }\n  }\n  return result;\n}\n</code></pre>"},{"location":"blaze/img__grid_8cpp/","title":"File img_grid.cpp","text":"<p>FileList &gt; grid &gt; img_grid.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"img_grid.hpp\"</code></li> <li><code>#include &lt;opencv2/imgcodecs.hpp&gt;</code></li> <li><code>#include &lt;opencv2/imgproc.hpp&gt;</code></li> <li><code>#include \"tif/tif.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/img_grid.cpp</code></p>"},{"location":"blaze/img__grid_8cpp_source/","title":"File img_grid.cpp","text":"<p>File List &gt; grid &gt; img_grid.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"img_grid.hpp\"\n\n#include &lt;opencv2/imgcodecs.hpp&gt;\n#include &lt;opencv2/imgproc.hpp&gt;\n\n#include \"tif/tif.hpp\"\n\nImgGrid::~ImgGrid() = default;\n\nvoid GeoImgGrid::save_to(const fs::path&amp; path, const Extent2D&amp; extent) {\n  if (path.extension() == \".tif\" || path.extension() == \".tiff\") {\n    GeoGrid&lt;RGBColor&gt; grid(GeoGrid&lt;RGBColor&gt;::FromGeoImg(*this));\n    write_to_tif(grid.slice(extent), path);\n  } else {\n    ImgGrid::save_to(path);\n  }\n}\nImgGrid::ImgGrid(size_t height, size_t width, std::optional&lt;int&gt; type)\n    : GridData(height, width),\n      m_img(std::make_unique&lt;cv::Mat&gt;(width, height, type.value_or(CV_8UC4))) {}\nvoid ImgGrid::save_to(const fs::path&amp; path) { cv::imwrite(path.string(), *m_img); }\nRGBColor ImgGrid::get_rgb_color(size_t row, size_t col) const {\n  cv::Vec4b v = m_img-&gt;at&lt;cv::Vec4b&gt;(row, col);\n  return RGBColor(v[2], v[1], v[0], v[3]);\n}\n\ntemplate &lt;typename ColorT, typename&gt;\nGeoImgGrid::GeoImgGrid(const GeoGrid&lt;ColorT&gt;&amp; grid)\n    : ImgGrid(grid.width(), grid.height()), GeoGridData(grid) {\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      const RGBColor color = grid[{j, i}].toRGB();\n      m_img-&gt;at&lt;cv::Vec4b&gt;(i, j) =\n          cv::Vec4b(color.getBlue(), color.getGreen(), color.getRed(), color.getAlpha());\n    }\n  }\n}\n\ntemplate GeoImgGrid::GeoImgGrid(const GeoGrid&lt;RGBColor&gt;&amp; grid);\ntemplate GeoImgGrid::GeoImgGrid(const GeoGrid&lt;CMYKColor&gt;&amp; grid);\nvoid GeoImgGrid::draw(const GeoImgGrid&amp; other, std::optional&lt;int&gt; interpolation) {\n  Coordinate2D&lt;double&gt; top_left =\n      transform().projection_to_pixel(other.transform().pixel_to_projection({0, 0}));\n  double dx_ratio = other.transform().dx() / transform().dx();\n  double dy_ratio = other.transform().dy() / transform().dy();\n  cv::Rect roi(top_left.x(), top_left.y(), other.width() * dx_ratio, other.height() * dy_ratio);\n  cv::Mat resized_img;\n  cv::resize(*other.m_img, resized_img,\n             cv::Size(other.width() * dx_ratio, other.height() * dy_ratio), 0, 0,\n             interpolation.value_or(cv::INTER_NEAREST));\n  if (resized_img.channels() == 4 &amp;&amp; m_img-&gt;channels() == 4) {\n    cv::Mat alpha_other, alpha_m_img;\n    std::vector&lt;cv::Mat&gt; channels_other, channels_m_img;\n    cv::split(resized_img, channels_other);\n    cv::split((*m_img)(roi), channels_m_img);\n    alpha_other = channels_other[3];\n    alpha_m_img = channels_m_img[3];\n\n    alpha_other.convertTo(alpha_other, CV_32F, 1.0 / 255.0);\n    alpha_m_img.convertTo(alpha_m_img, CV_32F, 1.0 / 255.0);\n\n    cv::Mat blended_img = cv::Mat::zeros((*m_img)(roi).size(), CV_8UC4);\n#pragma omp parallel for\n    for (int y = 0; y &lt; (*m_img)(roi).rows; ++y) {\n      for (int x = 0; x &lt; (*m_img)(roi).cols; ++x) {\n        float alpha = alpha_other.at&lt;float&gt;(y, x);\n        float beta = alpha_m_img.at&lt;float&gt;(y, x);\n\n        cv::Vec4b color_resized = resized_img.at&lt;cv::Vec4b&gt;(y, x);\n        cv::Vec4b color_m_img = (*m_img)(roi).at&lt;cv::Vec4b&gt;(y, x);\n\n        for (int c = 0; c &lt; 3; ++c) {\n          blended_img.at&lt;cv::Vec4b&gt;(y, x)[c] =\n              (alpha * color_resized[c] + beta * color_m_img[c] * (1 - alpha)) /\n              (alpha + beta * (1 - alpha));\n        }\n        blended_img.at&lt;cv::Vec4b&gt;(y, x)[3] = 255;  // Set alpha channel to 255\n      }\n    }\n\n    blended_img.copyTo((*m_img)(roi));\n  } else {\n    resized_img.copyTo((*m_img)(roi));\n  }\n}\nvoid GeoImgGrid::draw_point(const Coordinate2D&lt;double&gt;&amp; point, const ColorVariant&amp; color,\n                            double size) {\n  Coordinate2D&lt;double&gt; pixel_coord = transform().projection_to_pixel(point);\n  cv::circle(*m_img, cv::Point(pixel_coord.x(), pixel_coord.y()), size / transform().dx(),\n             to_rgb(color).toScalar(), -1);\n}\nvoid GeoImgGrid::draw(const Contour&amp; contour, const ColorVariant&amp; color, double width) {\n  std::vector&lt;std::vector&lt;cv::Point&gt;&gt; points;\n  points.push_back({});\n  for (const auto&amp; point : contour.points()) {\n    Coordinate2D&lt;double&gt; pixel_coord = transform().projection_to_pixel(point);\n    points[0].push_back({cv::Point(pixel_coord.x(), pixel_coord.y())});\n  }\n  int line_width_pixels = width / transform().dx();\n  cv::polylines(*m_img, points, false, to_rgb(color).toScalar(), line_width_pixels, cv::LINE_8);\n}\nvoid GeoImgGrid::draw(const std::vector&lt;Coordinate2D&lt;double&gt;&gt;&amp; in_points, const ColorVariant&amp; color,\n                      double width) {\n  std::vector&lt;std::vector&lt;cv::Point&gt;&gt; points;\n  points.push_back({});\n  for (const auto&amp; point : in_points) {\n    Coordinate2D&lt;double&gt; pixel_coord = transform().projection_to_pixel(point);\n    points[0].push_back({cv::Point(pixel_coord.x(), pixel_coord.y())});\n  }\n  int line_width_pixels = width / transform().dx();\n  cv::polylines(*m_img, points, false, to_rgb(color).toScalar(), line_width_pixels, cv::LINE_8);\n}\n</code></pre>"},{"location":"blaze/img__grid_8hpp/","title":"File img_grid.hpp","text":"<p>FileList &gt; grid &gt; img_grid.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"contour/contour.hpp\"</code></li> <li><code>#include \"isom/colors.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> </ul>"},{"location":"blaze/img__grid_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cv"},{"location":"blaze/img__grid_8hpp/#classes","title":"Classes","text":"Type Name class GeoImgGrid class ImgGrid <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/grid/img_grid.hpp</code></p>"},{"location":"blaze/img__grid_8hpp_source/","title":"File img_grid.hpp","text":"<p>File List &gt; grid &gt; img_grid.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"contour/contour.hpp\"\n#include \"isom/colors.hpp\"\n#include \"utilities/coordinate.hpp\"\n\nnamespace cv {\nclass Mat;\n}\n\nclass ImgGrid : public GridData {\n protected:\n  std::unique_ptr&lt;cv::Mat&gt; m_img;\n\n public:\n  ImgGrid(size_t height, size_t width, std::optional&lt;int&gt; type = {});\n  ~ImgGrid();\n\n  void save_to(const fs::path&amp; path);\n\n  RGBColor get_rgb_color(size_t row, size_t col) const;\n};\n\nclass GeoImgGrid : public ImgGrid, public GeoGridData {\n public:\n  GeoImgGrid(size_t width, size_t height, GeoTransform&amp;&amp; transform, GeoProjection&amp;&amp; projection)\n      : ImgGrid(width, height), GeoGridData(std::move(transform), std::move(projection)) {}\n\n  template &lt;typename ColorT, typename = std::enable_if_t&lt;std::is_base_of_v&lt;Color, ColorT&gt;&gt;&gt;\n  explicit GeoImgGrid(const GeoGrid&lt;ColorT&gt;&amp; grid);\n\n  void draw(const GeoImgGrid&amp; other, std::optional&lt;int&gt; interpolation = {});\n\n  void draw_point(const Coordinate2D&lt;double&gt;&amp; point, const ColorVariant&amp; color, double size);\n\n  void draw(const Contour&amp; contour, const ColorVariant&amp; color, double width);\n\n  void draw(const std::vector&lt;Coordinate2D&lt;double&gt;&gt;&amp; in_points, const ColorVariant&amp; color,\n            double width);\n\n  void save_to(const fs::path&amp; path, const Extent2D&amp; extent);\n};\n</code></pre>"},{"location":"blaze/dir_65bc51589f8002bfcb72faf47ab41180/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/io","text":"<p>FileList &gt; io</p>"},{"location":"blaze/dir_65bc51589f8002bfcb72faf47ab41180/#files","title":"Files","text":"Type Name file gpkg.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/io/</code></p>"},{"location":"blaze/gpkg_8hpp/","title":"File gpkg.hpp","text":"<p>FileList &gt; io &gt; gpkg.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;ogrsf_frmts.h&gt;</code></li> <li><code>#include \"assert/gdal_assert.hpp\"</code></li> <li><code>#include \"dxf/dxf.hpp\"</code></li> <li><code>#include \"gdal_priv.h\"</code></li> </ul>"},{"location":"blaze/gpkg_8hpp/#classes","title":"Classes","text":"Type Name class GDALDataset_w class GPKGWriter <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/io/gpkg.hpp</code></p>"},{"location":"blaze/gpkg_8hpp_source/","title":"File gpkg.hpp","text":"<p>File List &gt; io &gt; gpkg.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;ogrsf_frmts.h&gt;\n\n#include \"assert/gdal_assert.hpp\"\n#include \"dxf/dxf.hpp\"\n#include \"gdal_priv.h\"\n\nclass GDALDataset_w {\n  GDALDataset* dataset;\n\n public:\n  GDALDataset_w(const std::string&amp; filename, const std::string&amp; projection) {\n    GDALAllRegister();\n    GDALDriver* driver = GetGDALDriverManager()-&gt;GetDriverByName(\"GPKG\");\n    Assert(driver, \"GeoPackage driver not available.\");\n\n    dataset = driver-&gt;Create(filename.c_str(), 0, 0, 0, GDT_Unknown, nullptr);\n    Assert(dataset, \"Failed to create GeoPackage file \" + filename);\n\n    // OGRSpatialReference srs;\n    // GDALAssert(srs.importFromWkt(projection.c_str()));\n    dataset-&gt;SetProjection(projection.c_str());\n  }\n\n  GDALDataset* operator-&gt;() { return dataset; }\n\n  ~GDALDataset_w() { GDALClose(dataset); }\n};\n\nclass GPKGWriter {\n  GDALDataset_w dataset;\n  const std::string projection;\n\n  std::vector&lt;std::string&gt; layer_names;\n\n public:\n  GPKGWriter(const std::string&amp; filename, const std::string&amp; projection)\n      : dataset(filename, projection), projection(projection) {}\n\n  void add_layer(const std::string&amp; layer_name) {\n    OGRSpatialReference srs;\n    // Import projection from WKT string (supports both geographic and projected CRS)\n    GDALAssert(srs.importFromWkt(projection.c_str()));\n    OGRLayer* layer = dataset-&gt;CreateLayer(layer_name.c_str(), &amp;srs, wkbLineString, nullptr);\n    Assert(layer, \"Failed to create layer \" + layer_name);\n    layer_names.push_back(layer_name);\n  }\n\n  void write_polyline(\n      const Polyline&amp; polyline,\n      const std::map&lt;std::string, std::variant&lt;int, double, std::string&gt;&gt;&amp; data_fields = {}) {\n    std::string layer_name = polyline.layer;\n    if (std::find(layer_names.begin(), layer_names.end(), layer_name) == layer_names.end()) {\n      add_layer(layer_name);\n    }\n    OGRLayer* layer = dataset-&gt;GetLayerByName(layer_name.c_str());\n    Assert(layer, \"Layer \" + layer_name + \" not found.\");\n\n    OGRLineString line;\n    for (const auto&amp; vertex : polyline.vertices) {\n      line.addPoint(vertex.x(), vertex.y());\n    }\n\n    if (layer-&gt;GetLayerDefn()-&gt;GetFieldIndex(\"name\") == -1)\n      layer-&gt;CreateField(new OGRFieldDefn(\"name\", OFTString));\n    if (layer-&gt;GetLayerDefn()-&gt;GetFieldIndex(\"layer\") == -1)\n      layer-&gt;CreateField(new OGRFieldDefn(\"layer\", OFTString));\n    for (const auto&amp; [field_name, field_value] : data_fields) {\n      if (layer-&gt;GetLayerDefn()-&gt;GetFieldIndex(field_name.c_str()) == -1) {\n        if (std::holds_alternative&lt;int&gt;(field_value)) {\n          layer-&gt;CreateField(new OGRFieldDefn(field_name.c_str(), OFTInteger));\n        } else if (std::holds_alternative&lt;double&gt;(field_value)) {\n          layer-&gt;CreateField(new OGRFieldDefn(field_name.c_str(), OFTReal));\n        } else if (std::holds_alternative&lt;std::string&gt;(field_value)) {\n          layer-&gt;CreateField(new OGRFieldDefn(field_name.c_str(), OFTString));\n        } else {\n          Assert(false, \"Unknown field type.\");\n        }\n      }\n    }\n    OGRFeature* feature = OGRFeature::CreateFeature(layer-&gt;GetLayerDefn());\n    Assert(feature, \"Failed to create feature.\");\n\n    feature-&gt;SetGeometry(&amp;line);\n\n    feature-&gt;SetField(\"name\", polyline.name.c_str());\n    feature-&gt;SetField(\"layer\", polyline.layer.c_str());\n\n    for (const auto&amp; [field_name, field_value] : data_fields) {\n      if (std::holds_alternative&lt;int&gt;(field_value)) {\n        feature-&gt;SetField(field_name.c_str(), std::get&lt;int&gt;(field_value));\n      } else if (std::holds_alternative&lt;double&gt;(field_value)) {\n        feature-&gt;SetField(field_name.c_str(), std::get&lt;double&gt;(field_value));\n      } else if (std::holds_alternative&lt;std::string&gt;(field_value)) {\n        feature-&gt;SetField(field_name.c_str(), std::get&lt;std::string&gt;(field_value).c_str());\n      }\n    }\n\n    Assert(layer-&gt;CreateFeature(feature) == OGRERR_NONE, \"Failed to add feature to layer.\");\n\n    OGRFeature::DestroyFeature(feature);\n  }\n};\n</code></pre>"},{"location":"blaze/dir_95e71238802b7f0c2279a9a971eb5146/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/isom","text":"<p>FileList &gt; isom</p>"},{"location":"blaze/dir_95e71238802b7f0c2279a9a971eb5146/#files","title":"Files","text":"Type Name file colors.cpp file colors.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/isom/</code></p>"},{"location":"blaze/colors_8cpp/","title":"File colors.cpp","text":"<p>FileList &gt; isom &gt; colors.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"colors.hpp\"</code></li> <li><code>#include &lt;opencv2/opencv.hpp&gt;</code></li> <li><code>#include \"lib/assert/assert.hpp\"</code></li> </ul>"},{"location":"blaze/colors_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; std::string, ColorVariant &gt; COLOR_MAP"},{"location":"blaze/colors_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/colors_8cpp/#variable-color_map","title":"variable COLOR_MAP","text":"<pre><code>std::map&lt;std::string, ColorVariant&gt; COLOR_MAP;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/isom/colors.cpp</code></p>"},{"location":"blaze/colors_8cpp_source/","title":"File colors.cpp","text":"<p>File List &gt; isom &gt; colors.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"colors.hpp\"\n\n#include &lt;opencv2/opencv.hpp&gt;\n\n#include \"lib/assert/assert.hpp\"\n\nRGBColor RGBColor::FromCMYK(const CMYKColor&amp; cmyk) {\n  double c = cmyk.getCyan() / 100.0;\n  double m = cmyk.getMagenta() / 100.0;\n  double y = cmyk.getYellow() / 100.0;\n  double k = cmyk.getBlack() / 100.0;\n  double r = 255 * (1 - c) * (1 - k);\n  double g = 255 * (1 - m) * (1 - k);\n  double b = 255 * (1 - y) * (1 - k);\n  return RGBColor(r, g, b);\n}\n\nRGBColor::RGBColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n    : m_data{{r, g, b, a}} {\n  for (auto i : m_data) {\n    Assert(i &gt;= 0 &amp;&amp; i &lt;= 255, \"Invalid color value\");\n  }\n}\n\nCMYKColor::CMYKColor(unsigned char c, unsigned char m, unsigned char y, unsigned char k)\n    : m_data{{c, m, y, k}} {\n  for (auto i : m_data) {\n    Assert(i &gt;= 0 &amp;&amp; i &lt;= 100, \"Invalid color value\");\n  }\n}\nCMYKColor CMYKColor::FromRGB(const RGBColor&amp; rgb) {\n  double c = 1 - rgb.getRed() / 255.0;\n  double m = 1 - rgb.getGreen() / 255.0;\n  double y = 1 - rgb.getBlue() / 255.0;\n  double k = std::min({c, m, y});\n  if (k &gt;= 1.0) {\n    return CMYKColor(0, 0, 0, 100);\n  }\n  c = (c - k) / (1 - k);\n  m = (m - k) / (1 - k);\n  y = (y - k) / (1 - k);\n  return CMYKColor(\n      std::clamp&lt;int&gt;(std::round(c * 100), 0, 100), std::clamp&lt;int&gt;(std::round(m * 100), 0, 100),\n      std::clamp&lt;int&gt;(std::round(y * 100), 0, 100), std::clamp&lt;int&gt;(std::round(k * 100), 0, 100));\n}\nCMYKColor RGBColor::toCMYK() const { return CMYKColor::FromRGB(*this); }\n\nstd::map&lt;std::string, ColorVariant&gt; COLOR_MAP;\n\ncv::Scalar RGBColor::toScalar() const {\n  return cv::Scalar(getBlue(), getGreen(), getRed(), getAlpha());\n}\n</code></pre>"},{"location":"blaze/colors_8hpp/","title":"File colors.hpp","text":"<p>FileList &gt; isom &gt; colors.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> </ul>"},{"location":"blaze/colors_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cv"},{"location":"blaze/colors_8hpp/#classes","title":"Classes","text":"Type Name class CMYKColor class Color class RGBColor"},{"location":"blaze/colors_8hpp/#public-types","title":"Public Types","text":"Type Name typedef std::variant&lt; RGBColor, CMYKColor &gt; ColorVariant"},{"location":"blaze/colors_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name std::map&lt; std::string, ColorVariant &gt; COLOR_MAP"},{"location":"blaze/colors_8hpp/#public-functions","title":"Public Functions","text":"Type Name CMYKColor to_cmyk (const ColorVariant &amp; cv)  RGBColor to_rgb (const ColorVariant &amp; cv)"},{"location":"blaze/colors_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/colors_8hpp/#typedef-colorvariant","title":"typedef ColorVariant","text":"<pre><code>typedef std::variant&lt;RGBColor, CMYKColor&gt; ColorVariant;\n</code></pre>"},{"location":"blaze/colors_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/colors_8hpp/#variable-color_map","title":"variable COLOR_MAP","text":"<pre><code>std::map&lt;std::string, ColorVariant&gt; COLOR_MAP;\n</code></pre>"},{"location":"blaze/colors_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/colors_8hpp/#function-to_cmyk","title":"function to_cmyk","text":"<pre><code>inline CMYKColor to_cmyk (\n    const ColorVariant &amp; cv\n) \n</code></pre>"},{"location":"blaze/colors_8hpp/#function-to_rgb","title":"function to_rgb","text":"<pre><code>inline RGBColor to_rgb (\n    const ColorVariant &amp; cv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/isom/colors.hpp</code></p>"},{"location":"blaze/colors_8hpp_source/","title":"File colors.hpp","text":"<p>File List &gt; isom &gt; colors.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;map&gt;\n#include &lt;ostream&gt;\n#include &lt;variant&gt;\n\nclass RGBColor;\nclass CMYKColor;\n\nnamespace cv {\ntemplate &lt;typename T&gt;\nclass Scalar_;\ntypedef Scalar_&lt;double&gt; Scalar;\n}  // namespace cv\n\nclass Color {\n public:\n  virtual RGBColor toRGB() const = 0;\n  virtual CMYKColor toCMYK() const = 0;\n  virtual ~Color() = default;\n  Color&amp; operator=(const Color&amp;) = default;\n  Color(const Color&amp;) = default;\n  Color() = default;\n};\n\nnamespace cv {\ntemplate &lt;typename T&gt;\nclass Scalar_;\ntypedef Scalar_&lt;double&gt; Scalar;\n}  // namespace cv\n\nclass RGBColor : public Color {\n  std::array&lt;unsigned char, 4&gt; m_data;\n\n public:\n  RGBColor(unsigned char r, unsigned char g, unsigned char b, unsigned char a = 255);\n  RGBColor() { m_data.fill(0); };\n\n  virtual RGBColor toRGB() const override { return *this; }\n  virtual CMYKColor toCMYK() const override;\n\n  static RGBColor FromCMYK(const CMYKColor&amp; cmyk);\n\n  unsigned char getRed() const { return m_data[0]; }\n  unsigned char getGreen() const { return m_data[1]; }\n  unsigned char getBlue() const { return m_data[2]; }\n  unsigned char getAlpha() const { return m_data[3]; }\n\n  const unsigned char&amp; operator[](size_t index) const { return m_data[index]; }\n  unsigned char&amp; operator[](size_t index) { return m_data[index]; }\n  cv::Scalar toScalar() const;\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const RGBColor&amp; c) {\n    return os &lt;&lt; \"(\" &lt;&lt; c.getRed() &lt;&lt; \", \" &lt;&lt; c.getGreen() &lt;&lt; \", \" &lt;&lt; c.getBlue() &lt;&lt; \")\";\n  }\n};\n\nclass CMYKColor : public Color {\n  std::array&lt;unsigned char, 4&gt; m_data;\n\n public:\n  CMYKColor(unsigned char c, unsigned char m, unsigned char y, unsigned char k);\n  CMYKColor() : CMYKColor(0, 0, 0, 0) {};\n\n  virtual RGBColor toRGB() const override { return RGBColor::FromCMYK(*this); }\n  virtual CMYKColor toCMYK() const override { return *this; }\n\n  static CMYKColor FromRGB(const RGBColor&amp; rgb);\n\n  unsigned char getCyan() const { return m_data[0]; }\n  unsigned char getMagenta() const { return m_data[1]; }\n  unsigned char getYellow() const { return m_data[2]; }\n  unsigned char getBlack() const { return m_data[3]; }\n\n  unsigned char operator[](int index) const { return m_data[index]; }\n\n  CMYKColor operator+(const CMYKColor&amp; other) const {\n    return CMYKColor(std::min(getCyan() + other.getCyan(), 100),\n                     std::min(getMagenta() + other.getMagenta(), 100),\n                     std::min(getYellow() + other.getYellow(), 100),\n                     std::min(getBlack() + other.getBlack(), 100));\n  }\n\n  CMYKColor operator*(double factor) const {\n    return CMYKColor(getCyan() * factor, getMagenta() * factor, getYellow() * factor,\n                     getBlack() * factor);\n  }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const CMYKColor&amp; c) {\n    return os &lt;&lt; \"(\" &lt;&lt; c.getCyan() &lt;&lt; \", \" &lt;&lt; c.getMagenta() &lt;&lt; \", \" &lt;&lt; c.getYellow() &lt;&lt; \", \"\n              &lt;&lt; c.getBlack() &lt;&lt; \")\";\n  }\n};\n\ntypedef std::variant&lt;RGBColor, CMYKColor&gt; ColorVariant;\n\ninline RGBColor to_rgb(const ColorVariant&amp; cv) {\n  return std::visit([](auto&amp;&amp; arg) -&gt; RGBColor { return arg.toRGB(); }, cv);\n}\ninline CMYKColor to_cmyk(const ColorVariant&amp; cv) {\n  return std::visit([](auto&amp;&amp; arg) -&gt; CMYKColor { return arg.toCMYK(); }, cv);\n}\n\nextern std::map&lt;std::string, ColorVariant&gt; COLOR_MAP;\n</code></pre>"},{"location":"blaze/dir_50e4ddd575fc604ec1609997d931fab5/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/las","text":"<p>FileList &gt; las</p>"},{"location":"blaze/dir_50e4ddd575fc604ec1609997d931fab5/#files","title":"Files","text":"Type Name file las_file.hpp file las_point.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/las/</code></p>"},{"location":"blaze/las__file_8hpp/","title":"File las_file.hpp","text":"<p>FileList &gt; las &gt; las_file.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;future&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include \"ogr_spatialref.h\"</code></li> <li><code>#include \"spatial_index.hpp\"</code></li> <li><code>#include \"las_reader.hpp\"</code></li> <li><code>#include \"las_writer.hpp\"</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"grid/grid.hpp\"</code></li> <li><code>#include \"las_point.hpp\"</code></li> <li><code>#include \"utilities/filesystem.hpp\"</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> <li><code>#include \"utilities/resources.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/las__file_8hpp/#classes","title":"Classes","text":"Type Name class AsyncLASData class LASData class LASFile"},{"location":"blaze/las__file_8hpp/#public-types","title":"Public Types","text":"Type Name enum BorderType"},{"location":"blaze/las__file_8hpp/#public-functions","title":"Public Functions","text":"Type Name T average (T a, T b)  Extent2D border_ranges (const Extent2D &amp; box, BorderType border_type, double border_width)  std::string convert_geo_keys_to_wkt (const laspp::LASGeoKeys &amp; geo_keys)  void copy_from (LASPoint &amp; point, const laspp::LASPointFormat0 &amp; data)  void copy_from (LASPoint &amp; point, const laspp::LASPointFormat6 &amp; data)  void copy_from (laspp::LASPointFormat0 &amp; data, const LASPoint &amp; point)  Extent2D external_border_ranges (const Extent2D &amp; box, BorderType border_type, double border_width)  void extract_borders (const fs::path &amp; las_filename, double border_width, ProgressTracker progress_tracker)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, BorderType border_type)  long int round (double x, double resolution=1.0)  std::string unique_coord_name (const Extent2D &amp; box)"},{"location":"blaze/las__file_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/las__file_8hpp/#enum-bordertype","title":"enum BorderType","text":"<pre><code>enum BorderType {\n    N,\n    NE,\n    E,\n    SE,\n    S,\n    SW,\n    W,\n    NW\n};\n</code></pre>"},{"location":"blaze/las__file_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/las__file_8hpp/#function-average","title":"function average","text":"<pre><code>template&lt;typename T&gt;\ninline T average (\n    T a,\n    T b\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-border_ranges","title":"function border_ranges","text":"<pre><code>inline Extent2D border_ranges (\n    const  Extent2D &amp; box,\n    BorderType border_type,\n    double border_width\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-convert_geo_keys_to_wkt","title":"function convert_geo_keys_to_wkt","text":"<pre><code>inline std::string convert_geo_keys_to_wkt (\n    const laspp::LASGeoKeys &amp; geo_keys\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-copy_from","title":"function copy_from","text":"<pre><code>inline void copy_from (\n    LASPoint &amp; point,\n    const laspp::LASPointFormat0 &amp; data\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-copy_from_1","title":"function copy_from","text":"<pre><code>inline void copy_from (\n    LASPoint &amp; point,\n    const laspp::LASPointFormat6 &amp; data\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-copy_from_2","title":"function copy_from","text":"<pre><code>inline void copy_from (\n    laspp::LASPointFormat0 &amp; data,\n    const  LASPoint &amp; point\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-external_border_ranges","title":"function external_border_ranges","text":"<pre><code>inline Extent2D external_border_ranges (\n    const  Extent2D &amp; box,\n    BorderType border_type,\n    double border_width\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-extract_borders","title":"function extract_borders","text":"<pre><code>inline void extract_borders (\n    const fs::path &amp; las_filename,\n    double border_width,\n    ProgressTracker progress_tracker\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    BorderType border_type\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-round","title":"function round","text":"<pre><code>inline long  int round (\n    double x,\n    double resolution=1.0\n) \n</code></pre>"},{"location":"blaze/las__file_8hpp/#function-unique_coord_name","title":"function unique_coord_name","text":"<pre><code>inline std::string unique_coord_name (\n    const  Extent2D &amp; box\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/las/las_file.hpp</code></p>"},{"location":"blaze/las__file_8hpp_source/","title":"File las_file.hpp","text":"<p>File List &gt; las &gt; las_file.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;fstream&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;mutex&gt;\n\n#include \"ogr_spatialref.h\"\n#include \"spatial_index.hpp\"\n#ifdef USE_PDAL\n#include &lt;pdal/Dimension.hpp&gt;\n#include &lt;pdal/SpatialReference.hpp&gt;\n#include &lt;pdal/io/BufferReader.hpp&gt;\n#include &lt;pdal/io/LasHeader.hpp&gt;\n#include &lt;pdal/io/LasReader.hpp&gt;\n#include &lt;pdal/pdal.hpp&gt;\n#include &lt;pdal/util/Bounds.hpp&gt;\n#else\n#include \"las_reader.hpp\"\n#include \"las_writer.hpp\"\n#endif\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"grid/grid.hpp\"\n#include \"las_point.hpp\"\n#include \"utilities/filesystem.hpp\"\n#include \"utilities/progress_tracker.hpp\"\n#include \"utilities/resources.hpp\"\n#include \"utilities/timer.hpp\"\n\nenum class BorderType { N, NE, E, SE, S, SW, W, NW };\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, BorderType border_type) {\n  switch (border_type) {\n    case BorderType::N:\n      return os &lt;&lt; \"N\";\n    case BorderType::NE:\n      return os &lt;&lt; \"NE\";\n    case BorderType::E:\n      return os &lt;&lt; \"E\";\n    case BorderType::SE:\n      return os &lt;&lt; \"SE\";\n    case BorderType::S:\n      return os &lt;&lt; \"S\";\n    case BorderType::SW:\n      return os &lt;&lt; \"SW\";\n    case BorderType::W:\n      return os &lt;&lt; \"W\";\n    case BorderType::NW:\n      return os &lt;&lt; \"NW\";\n  }\n  unreachable();\n}\n\ninline Extent2D border_ranges(const Extent2D&amp; box, BorderType border_type, double border_width) {\n  switch (border_type) {\n    case BorderType::N:\n      return {box.minx, box.maxx, box.maxy - border_width, box.maxy};\n    case BorderType::NE:\n      return {box.maxx - border_width, box.maxx, box.maxy - border_width, box.maxy};\n    case BorderType::E:\n      return {box.maxx - border_width, box.maxx, box.miny, box.maxy};\n    case BorderType::SE:\n      return {box.maxx - border_width, box.maxx, box.miny, box.miny + border_width};\n    case BorderType::S:\n      return {box.minx, box.maxx, box.miny, box.miny + border_width};\n    case BorderType::SW:\n      return {box.minx, box.minx + border_width, box.miny, box.miny + border_width};\n    case BorderType::W:\n      return {box.minx, box.minx + border_width, box.miny, box.maxy};\n    case BorderType::NW:\n      return {box.minx, box.minx + border_width, box.maxy - border_width, box.maxy};\n  }\n  unreachable();\n}\n\ninline Extent2D external_border_ranges(const Extent2D&amp; box, BorderType border_type,\n                                       double border_width) {\n  switch (border_type) {\n    case BorderType::N:\n      return {box.minx, box.maxx, box.maxy, box.maxy + border_width};\n    case BorderType::NE:\n      return {box.maxx, box.maxx + border_width, box.maxy, box.maxy + border_width};\n    case BorderType::E:\n      return {box.maxx, box.maxx + border_width, box.miny, box.maxy};\n    case BorderType::SE:\n      return {box.maxx, box.maxx + border_width, box.miny - border_width, box.miny};\n    case BorderType::S:\n      return {box.minx, box.maxx, box.miny - border_width, box.miny};\n    case BorderType::SW:\n      return {box.minx - border_width, box.minx, box.miny - border_width, box.miny};\n    case BorderType::W:\n      return {box.minx - border_width, box.minx, box.miny, box.maxy};\n    case BorderType::NW:\n      return {box.minx - border_width, box.minx, box.maxy, box.maxy + border_width};\n  }\n  unreachable();\n}\n\ninline long int round(double x, double resolution = 1.0) {\n  return std::round(x / resolution) * resolution;\n}\n\ntemplate &lt;typename T&gt;\ninline T average(T a, T b) {\n  return (a + b) / 2;\n}\n\ninline std::string unique_coord_name(const Extent2D&amp; box) {\n  return std::to_string(round(box.minx, 10)) + \"_\" + std::to_string(round(box.miny, 10)) + \"_\" +\n         std::to_string(round(box.maxx, 10)) + \"_\" + std::to_string(round(box.maxy, 10));\n}\n\n#ifdef USE_PDAL\ninline void print_metadata(const pdal::MetadataNode&amp; node, const std::string&amp; prefix = \"\") {\n  std::cout &lt;&lt; prefix &lt;&lt; node.name() &lt;&lt; \": \" &lt;&lt; node.value() &lt;&lt; std::endl;\n  for (const std::string&amp; name : node.childNames()) {\n    print_metadata(node.findChild(name), prefix + \"  \");\n  }\n}\n#endif\n\n#undef min\n#undef max\n\n#ifndef USE_PDAL\ninline void copy_from(LASPoint&amp; point, const laspp::LASPointFormat0&amp; data) {\n  point.x() = data.x;\n  point.y() = data.y;\n  point.z() = data.z;\n  point.intensity() = data.intensity;\n  point.classification() = static_cast&lt;LASClassification&gt;(data.classification());\n}\n\ninline void copy_from(LASPoint&amp; point, const laspp::LASPointFormat6&amp; data) {\n  point.x() = data.x;\n  point.y() = data.y;\n  point.z() = data.z;\n  point.intensity() = data.intensity;\n  point.classification() = static_cast&lt;LASClassification&gt;(data.classification);\n}\n\ninline void copy_from(laspp::LASPointFormat0&amp; data, const LASPoint&amp; point) {\n  data.x = point.x();\n  data.y = point.y();\n  data.z = point.z();\n  data.intensity = point.intensity();\n  data.classification_byte.classification =\n      static_cast&lt;laspp::LASClassification&gt;(static_cast&lt;uint8_t&gt;(point.classification()));\n}\n\ninline std::string convert_geo_keys_to_wkt(const laspp::LASGeoKeys&amp; geo_keys) {\n  OGRSpatialReference srs;\n  bool projectionSet = false;\n\n  auto keys = geo_keys.get_keys();\n\n  if (keys.find(3072) != keys.end()) {  // Projected CRS\n    uint16_t epsg_code = std::get&lt;uint16_t&gt;(keys.at(3072));\n    if (srs.importFromEPSG(epsg_code) == OGRERR_NONE) {\n      projectionSet = true;\n    }\n  } else if (keys.find(2048) != keys.end()) {  // Geographic CRS\n    uint16_t epsg_code = std::get&lt;uint16_t&gt;(keys.at(2048));\n    if (srs.importFromEPSG(epsg_code) == OGRERR_NONE) {\n      projectionSet = true;\n    }\n  }\n\n  if (!projectionSet) {\n    std::cerr &lt;&lt; geo_keys &lt;&lt; std::endl;\n    Fail(\"ERROR: No valid EPSG code found in LASGeoKeys.\");\n  }\n\n  // Convert to WKT\n  char* wkt = nullptr;\n  srs.exportToWkt(&amp;wkt);\n  std::string wktString = wkt;\n  CPLFree(wkt);\n\n  return wktString;\n}\n\n#endif\n\nclass LASFile {\n protected:\n  std::optional&lt;fs::path&gt; m_filename;\n  Extent3D m_bounds;\n  Extent3D m_original_bounds;\n  GeoProjection m_projection;\n\n public:\n  explicit LASFile(const Extent2D&amp; bounds, GeoProjection&amp;&amp; projection)\n      : m_bounds(bounds, std::numeric_limits&lt;double&gt;::max(), std::numeric_limits&lt;double&gt;::min()),\n        m_original_bounds(m_bounds),\n        m_projection(projection) {};\n\n protected:\n#ifndef USE_PDAL\n  laspp::QuadtreeSpatialIndex m_spatial_index;\n\n  void from_las_reader(const laspp::LASReader&amp; reader) {\n    laspp::Bound3D bounds = reader.header().bounds();\n    m_bounds = Extent3D(Extent2D(bounds.min_x(), bounds.max_x(), bounds.min_y(), bounds.max_y()),\n                        bounds.min_z(), bounds.max_z());\n    m_original_bounds = m_bounds;\n    if (reader.wkt().has_value())\n      m_projection = GeoProjection(reader.wkt().value());\n    else {\n      Assert(reader.geo_keys().has_value(), \"No projection found in LAS file\");\n      laspp::LASGeoKeys geo_keys = reader.geo_keys().value();\n      m_projection = GeoProjection(convert_geo_keys_to_wkt(geo_keys));\n    }\n\n    if (reader.has_lastools_spatial_index()) {\n      m_spatial_index = reader.lastools_spatial_index();\n    }\n  }\n#endif\n\n public:\n  explicit LASFile(const fs::path&amp; filename, ProgressTracker progress_tracker)\n      : m_filename(filename) {\n    Timer timer;\n    progress_tracker.text_update(to_string(\"Reading \", filename, \" metadata ...\"));\n#ifdef USE_PDAL\n\n#else\n    std::ifstream file(filename, std::ios::binary);\n    laspp::LASReader reader(file);\n    from_las_reader(reader);\n    progress_tracker.text_update(\"Reading metadata took \" + to_string(timer));\n#endif\n  }\n\n  Coordinate2D&lt;double&gt; top_left() const { return {m_bounds.minx, m_bounds.maxy}; }\n  double width() const { return m_bounds.maxx - m_bounds.minx; }\n  double height() const { return m_bounds.maxy - m_bounds.miny; }\n  const GeoProjection&amp; projection() const { return m_projection; }\n\n  Extent2D export_bounds() const {\n    return Extent2D(average(m_bounds.minx, m_original_bounds.minx),\n                    average(m_bounds.maxx, m_original_bounds.maxx),\n                    average(m_bounds.miny, m_original_bounds.miny),\n                    average(m_bounds.maxy, m_original_bounds.maxy));\n  }\n\n  const Extent3D&amp; bounds() const { return m_bounds; }\n  Extent2D original_bounds() const { return m_original_bounds; }\n\n  std::pair&lt;double, double&gt; height_range() const { return {m_bounds.minz, m_bounds.maxz}; }\n};\n\nclass LASData : public LASFile {\n  std::pair&lt;uint16_t, uint16_t&gt; m_intensity_range;\n  std::vector&lt;LASPoint&gt; m_points;\n\n public:\n  LASData(const Extent2D&amp; bounds, const GeoProjection&amp; projection)\n      : LASFile(bounds, GeoProjection(projection)),\n        m_intensity_range(\n            {std::numeric_limits&lt;uint16_t&gt;::max(), std::numeric_limits&lt;uint16_t&gt;::min()}) {}\n\n  template &lt;typename T&gt;\n  explicit LASData(const GeoGrid&lt;T&gt;&amp; grid)\n      : LASData(*grid.extent(), GeoProjection(grid.projection())) {\n    for (size_t i = 0; i &lt; grid.height(); i++) {\n      for (size_t j = 0; j &lt; grid.width(); j++) {\n        Coordinate2D&lt;double&gt; coord =\n            grid.transform().pixel_to_projection({(double)j + 0.5, (double)i + 0.5});\n        insert(LASPoint(coord.x(), coord.y(), grid[{j, i}], 1000, LASClassification::Ground));\n      }\n    }\n  }\n\n  void insert(const LASPoint&amp; point) {\n    m_points.emplace_back(point);\n    m_intensity_range.first = std::min(m_intensity_range.first, point.intensity());\n    m_intensity_range.second = std::max(m_intensity_range.second, point.intensity());\n    m_bounds.grow(point.x(), point.y(), point.z());\n  }\n\n#ifndef USE_PDAL\n protected:\n  void read_points(laspp::LASReader&amp; reader, ProgressTracker progress_tracker,\n                   std::optional&lt;Extent2D&gt; bounds = std::nullopt) {\n    Timer point_timer;\n\n    if (bounds.has_value() &amp;&amp; reader.has_lastools_spatial_index()) {\n      // Create query bounds (note: Bound2D constructor is min_x, min_y, max_x, max_y)\n      laspp::Bound2D query_bounds(bounds-&gt;minx, bounds-&gt;miny, bounds-&gt;maxx, bounds-&gt;maxy);\n\n      // Get spatial index and find ONLY cells that overlap the query bounds\n      const auto&amp; spatial_index = reader.lastools_spatial_index();\n      const auto&amp; cells = spatial_index.cells();\n\n      // Collect point intervals ONLY from cells that overlap the query extent\n      std::vector&lt;laspp::PointInterval&gt; intervals;\n      for (const auto&amp; [cell_index, cell] : cells) {\n        // Check if this cell overlaps the query bounds\n        laspp::Bound2D cell_bounds = spatial_index.get_cell_bounds(cell_index);\n\n        // Two bounds overlap if: max_x &gt; min_x &amp;&amp; max_y &gt; min_y (edge-touching doesn't count)\n        bool overlaps = (cell_bounds.max_x() &gt; query_bounds.min_x() &amp;&amp;\n                         cell_bounds.min_x() &lt; query_bounds.max_x() &amp;&amp;\n                         cell_bounds.max_y() &gt; query_bounds.min_y() &amp;&amp;\n                         cell_bounds.min_y() &lt; query_bounds.max_y());\n\n        if (overlaps) {\n          // Only add intervals from overlapping cells\n          intervals.insert(intervals.end(), cell.intervals.begin(), cell.intervals.end());\n        }\n      }\n\n      // Get chunk indices for intervals from overlapping cells only\n      std::vector&lt;size_t&gt; chunk_indices = reader.get_chunk_indices_from_intervals(intervals);\n\n      progress_tracker.text_update(\n          to_string(\"Reading \", chunk_indices.size(), \"/\", reader.num_chunks(), \" chunks\"));\n\n      if (!chunk_indices.empty()) {\n        // Calculate total points needed\n        size_t total_points = 0;\n        if (reader.header().is_laz_compressed()) {\n          const auto&amp; points_per_chunk = reader.points_per_chunk();\n          for (size_t chunk_idx : chunk_indices) {\n            total_points += points_per_chunk[chunk_idx];\n          }\n        } else {\n          total_points = reader.num_points();\n        }\n\n        // Read only the chunks that contain points from overlapping cells\n        m_points.resize(total_points);\n        reader.read_chunks_list(std::span&lt;LASPoint&gt;(m_points), chunk_indices);\n\n        // Filter points that are actually within the bounds\n        const auto&amp; transform = reader.header().transform();\n        std::vector&lt;LASPoint&gt; filtered_points;\n        filtered_points.reserve(m_points.size());\n\n        for (const auto&amp; point : m_points) {\n          auto coords = transform.transform_point(point.x(), point.y(), point.z());\n          if (query_bounds.contains(coords.x(), coords.y())) {\n            filtered_points.push_back(point);\n            // Transform coordinates\n            filtered_points.back().x() = coords.x();\n            filtered_points.back().y() = coords.y();\n            filtered_points.back().z() = coords.z();\n          }\n        }\n\n        m_points = std::move(filtered_points);\n      } else {\n        // No overlapping cells found, set empty\n        m_points.clear();\n      }\n    } else {\n      // No bounds or no spatial index - read all points\n      m_points.resize(reader.num_points());\n      reader.read_chunks(std::span&lt;LASPoint&gt;(m_points), {0, reader.num_chunks()});\n\n      // Transform coordinates\n      const auto&amp; transform = reader.header().transform();\n      for (LASPoint&amp; point : m_points) {\n        auto coords = transform.transform_point(point.x(), point.y(), point.z());\n        point.x() = coords.x();\n        point.y() = coords.y();\n        point.z() = coords.z();\n      }\n    }\n\n    progress_tracker.text_update(\n        to_string(\"Reading \", m_points.size(), \" points took \", point_timer));\n\n    // Calculate intensity range\n    for (const LASPoint&amp; point : m_points) {\n      m_intensity_range.first = std::min(m_intensity_range.first, point.intensity());\n      m_intensity_range.second = std::max(m_intensity_range.second, point.intensity());\n    }\n\n    progress_tracker.text_update(to_string(\"Calculating extent took \", point_timer));\n  }\n\n public:\n#endif\n\n  explicit LASData(const fs::path&amp; filename, ProgressTracker progress_tracker,\n                   [[maybe_unused]] bool skip_reading_points = false,\n                   std::optional&lt;Extent2D&gt; bounds = std::nullopt)\n      : LASFile(filename, progress_tracker.subtracker(0, 0.1)) {\n    Timer timer;\n    progress_tracker.text_update(to_string(\"Reading \", filename, \" ...\"));\n    Assert(fs::exists(filename), \"File does not exist: \" + filename.string());\n\n#ifdef USE_PDAL\n    pdal::Option las_opt(\"filename\", filename.string());\n    pdal::Options las_opts;\n    las_opts.add(las_opt);\n    pdal::PointTable table;\n    pdal::LasReader las_reader;\n    las_reader.setOptions(las_opts);\n    las_reader.prepare(table);\n    pdal::PointViewSet point_view_set = las_reader.execute(table);\n    pdal::PointViewPtr point_view = *point_view_set.begin();\n    pdal::Dimension::IdList dims = point_view-&gt;dims();\n    pdal::LasHeader las_header = las_reader.header();\n    const auto&amp; bounds = las_header.getBounds();\n    m_bounds = Extent3D(Extent2D(bounds.minx, bounds.maxx, bounds.miny, bounds.maxy), bounds.minz,\n                        bounds.maxz);\n    m_original_bounds = m_bounds;\n    m_projection = GeoProjection(las_header.srs().getWKT());\n\n    progress_tracker.text_update(to_string(\"Read \", point_view-&gt;size(), \" points\"));\n    // std::cout &lt;&lt; \"Spatial reference: \" &lt;&lt; pdal::SpatialReference(las_header.srs().getWKT())\n    //&lt;&lt; std::endl;\n    //\n    // std::cout &lt;&lt; \"Fields: \" &lt;&lt; std::endl;\n    // for (pdal::Dimension::Id dim : dims) {\n    // std::cout &lt;&lt; \"- \" &lt;&lt; pdal::Dimension::name(dim) &lt;&lt; \": \" &lt;&lt; pdal::Dimension::description(dim)\n    //&lt;&lt; \" (\" &lt;&lt; point_view-&gt;dimType(dim) &lt;&lt; \")\" &lt;&lt; std::endl;\n    //}\n\n    progress_tracker.text_update(\"Reading metadata took \" + to_string(timer));\n\n    Timer point_timer;\n    for (pdal::PointId idx = 0; idx &lt; point_view-&gt;size(); idx++) {\n      insert(LASPoint(point_view-&gt;point(idx)));\n    }\n\n    progress_tracker.text_update(\n        to_string(\"Reading \", point_view-&gt;size(), \" points took \", point_timer));\n#else\n    std::ifstream file(filename, std::ios::binary);\n    laspp::LASReader reader(file);\n    from_las_reader(reader);\n    progress_tracker.text_update(\"Reading metadata took \" + to_string(timer));\n    if (skip_reading_points) {\n      return;\n    }\n    read_points(reader, progress_tracker.subtracker(0.1, 1.0), bounds);\n#endif\n  }\n\n  auto begin() { return m_points.begin(); }\n  auto end() { return m_points.end(); }\n\n  std::pair&lt;uint16_t, uint16_t&gt; intensity_range() const { return m_intensity_range; }\n\n  static LASData with_border(const fs::path&amp; filename, double border_width,\n                             const std::vector&lt;std::pair&lt;Extent3D, fs::path&gt;&gt;&amp; all_las_file_extents,\n                             ProgressTracker progress_tracker) {\n    LASData las_file(filename, progress_tracker.subtracker(0.0, 0.6));\n    Extent3D original_bounds = las_file.bounds();\n    Extent3D extended_bounds = original_bounds;\n    extended_bounds.grow(border_width);\n\n    std::vector&lt;fs::path&gt; overlapping_filenames;\n    for (const auto&amp; [extent, border_filename] : all_las_file_extents) {\n      if (extended_bounds.intersects(extent) &amp;&amp; extent != original_bounds) {\n        overlapping_filenames.push_back(border_filename);\n      }\n    }\n    for (size_t i = 0; i &lt; overlapping_filenames.size(); i++) {\n      const fs::path&amp; border_filename = overlapping_filenames[i];\n      LASData border_file(\n          border_filename.string(),\n          progress_tracker.subtracker(0.6 + (double)i / overlapping_filenames.size() * 0.4,\n                                      0.6 + (double)(i + 1) / overlapping_filenames.size() * 0.4),\n          false, extended_bounds);\n      for (const LASPoint&amp; point : border_file) {\n        if (!extended_bounds.contains(point.x(), point.y())) {\n          continue;\n        }\n        las_file.insert(point);\n      }\n      Extent3D intersection = extended_bounds.intersection(border_file.bounds());\n      las_file.m_bounds.grow(intersection);\n    }\n    progress_tracker.text_update(\n        to_string(\"Combined \", filename.string(), \" with borders \", las_file.bounds()));\n    return las_file;\n  }\n\n  static LASData with_border(const fs::path&amp; filename, double border_width,\n                             ProgressTracker progress_tracker) {\n    LASData las_file(filename, progress_tracker.subtracker(0.0, 0.6));\n    Extent3D original_bounds = las_file.bounds();\n    std::vector&lt;fs::path&gt; border_filenames;\n    for (const BorderType border_type :\n         {BorderType::N, BorderType::NE, BorderType::E, BorderType::SE, BorderType::S,\n          BorderType::SW, BorderType::W, BorderType::NW}) {\n      Extent2D box = external_border_ranges(original_bounds, border_type, border_width);\n      fs::path border_filename = LocalDataRetriever::get_local_data(\"extracted_borders\") /\n                                 (unique_coord_name(box) + \".laz\");\n      if (fs::exists(border_filename)) {\n        border_filenames.push_back(border_filename);\n      } else {\n        std::cerr &lt;&lt; border_type &lt;&lt; \" border file \" &lt;&lt; border_filename &lt;&lt; \" does not exist\"\n                  &lt;&lt; std::endl;\n      }\n    }\n    ProgressTracker subtracker = progress_tracker.subtracker(0.6, 1.0);\n    for (size_t i = 0; i &lt; border_filenames.size(); i++) {\n      const fs::path&amp; border_filename = border_filenames[i];\n      LASData border_file(border_filename.string(),\n                          subtracker.subtracker((double)i / border_filenames.size(),\n                                                (double)(i + 1) / border_filenames.size()));\n      for (const LASPoint&amp; point : border_file) {\n        las_file.insert(point);\n      }\n      las_file.m_bounds.grow(border_file.bounds());\n    }\n    progress_tracker.text_update(\n        to_string(\"Combined \", filename.string(), \" with borders \", las_file.m_bounds));\n    return las_file;\n  }\n\n  std::size_t n_points() const { return m_points.size(); }\n  const LASPoint&amp; operator[](std::size_t i) const { return m_points[i]; }\n\n  LASPoint&amp; operator[](std::size_t i) { return m_points[i]; }\n  void push_back(const LASPoint&amp; point) { m_points.push_back(point); }\n\n  void write(const fs::path&amp; filename, std::optional&lt;ProgressTracker&gt; progress_tracker = {}) const {\n    (void)progress_tracker;\n#ifdef USE_PDAL\n    pdal::Options options;\n    options.add(\"filename\", filename.string());\n    options.add(\"dataformat_id\", 0);\n\n    pdal::PointTable table;\n    table.layout()-&gt;registerDim(pdal::Dimension::Id::X);\n    table.layout()-&gt;registerDim(pdal::Dimension::Id::Y);\n    table.layout()-&gt;registerDim(pdal::Dimension::Id::Z);\n    table.layout()-&gt;registerDim(pdal::Dimension::Id::Intensity);\n    table.layout()-&gt;registerDim(pdal::Dimension::Id::Classification);\n\n    pdal::PointViewPtr view(new pdal::PointView(table));\n    for (const LASPoint&amp; point : m_points) {\n      pdal::PointId idx = view-&gt;size();\n      point.write_to(view-&gt;point(idx));\n    }\n\n    pdal::BufferReader reader;\n    reader.addView(view);\n\n    pdal::StageFactory factory;\n    pdal::Stage* writer = factory.createStage(\"writers.las\");\n    writer-&gt;setInput(reader);\n    writer-&gt;setOptions(options);\n    writer-&gt;prepare(table);\n    writer-&gt;execute(table);\n#else\n    std::fstream file(filename, std::ios::binary | std::ios::in | std::ios::out | std::ios::trunc);\n    laspp::LASWriter las_writer(file, 128);\n    las_writer.write_wkt(m_projection.to_string());\n    std::vector&lt;LASPoint&gt; points_copy = m_points;\n    las_writer.header().transform().scale_factors().x() = 0.001;\n    las_writer.header().transform().scale_factors().y() = 0.001;\n    las_writer.header().transform().scale_factors().z() = 0.001;\n    las_writer.header().transform().offsets().x() = m_bounds.minx;\n    las_writer.header().transform().offsets().y() = m_bounds.miny;\n    las_writer.header().transform().offsets().z() = m_bounds.minz;\n    for (LASPoint&amp; point : points_copy) {\n      point.x() = (point.x() - m_bounds.minx) / 0.001;\n      point.y() = (point.y() - m_bounds.miny) / 0.001;\n      point.z() = (point.z() - m_bounds.minz) / 0.001;\n    }\n    las_writer.write_points(std::span&lt;const LASPoint&gt;(points_copy));\n#endif\n  }\n\n  void extract_borders(const fs::path&amp; tmp_dir, double border_width,\n                       ProgressTracker progress_tracker) const {\n    size_t idx = 0;\n    for (const BorderType border_type :\n         {BorderType::N, BorderType::NE, BorderType::E, BorderType::SE, BorderType::S,\n          BorderType::SW, BorderType::W, BorderType::NW}) {\n      progress_tracker.set_proportion((double)idx / 8);\n      Extent2D box = border_ranges(m_bounds, border_type, border_width);\n      LASData border_file(box, GeoProjection(m_projection));\n      for (const LASPoint&amp; point : m_points) {\n        if (box.contains(point.x(), point.y())) {\n          border_file.insert(point);\n        }\n      }\n      if (border_file.n_points() &gt; 0) {\n        border_file.write(\n            tmp_dir /\n                (unique_coord_name(static_cast&lt;const Extent2D&amp;&gt;(border_file.bounds())) + \".laz\"),\n            progress_tracker.subtracker(((double)idx + 0.5) / 8, (double)(idx + 1) / 8));\n      }\n      idx++;\n    }\n  }\n};\n\nclass AsyncLASData : public LASData {\n  std::mutex m_mutex;\n  std::promise&lt;void&gt; m_data_promise;\n  std::thread m_thread;\n\n public:\n  AsyncLASData(const fs::path&amp; filename, AsyncProgressTracker progress_tracker,\n               std::vector&lt;std::function&lt;void()&gt;&gt; callbacks = {})\n      : LASData(Extent2D(0, 0, 0, 0), GeoProjection(\"\")) {\n    std::promise&lt;void&gt; metadata_promise;\n    m_thread =\n        std::thread([this, filename, &amp;metadata_promise, progress_tracker, callbacks]() mutable {\n#ifndef USE_PDAL\n          std::ifstream file(filename, std::ios::binary);\n          laspp::LASReader reader(file);\n          this-&gt;from_las_reader(reader);\n          metadata_promise.set_value();\n          std::lock_guard&lt;std::mutex&gt; lock(m_mutex);\n          this-&gt;read_points(reader, progress_tracker.tracker()-&gt;subtracker(0.01, 1.0));\n          m_data_promise.set_value();\n          for (const auto&amp; callback : callbacks) {\n            callback();\n          }\n#endif\n        });\n    m_thread.detach();\n    metadata_promise.get_future().wait();\n  }\n\n  bool data_ready() {\n    return m_data_promise.get_future().wait_for(std::chrono::seconds(0)) ==\n           std::future_status::ready;\n  }\n  void wait_for_data() { m_thread.join(); }\n\n  std::mutex&amp; mutex() { return m_mutex; }\n\n  ~AsyncLASData() {\n    if (m_thread.joinable()) {\n      m_thread.join();\n    }\n  }\n};\n\ninline void extract_borders(const fs::path&amp; las_filename, double border_width,\n                            ProgressTracker progress_tracker) {\n  fs::path tmp_dir = LocalDataRetriever::get_local_data(\"extracted_borders\");\n  fs::create_directories(tmp_dir);\n\n  fs::path done_file = tmp_dir / (las_filename.stem().string() + \".done\");\n\n  if (fs::exists(done_file)) {\n    progress_tracker.text_update(\n        to_string(\"Skipping \", las_filename, \" because it has already been processed\"));\n    return;\n  }\n\n  progress_tracker.text_update(to_string(\"Extracting borders from \", las_filename, \" ...\"));\n  LASData las_file(las_filename.string(), progress_tracker.subtracker(0.0, 0.6));\n  las_file.extract_borders(tmp_dir, border_width, progress_tracker.subtracker(0.6, 1.0));\n\n  // create done file\n  std::ofstream bla(done_file);\n}\n</code></pre>"},{"location":"blaze/las__point_8hpp/","title":"File las_point.hpp","text":"<p>FileList &gt; las &gt; las_point.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;utilities/coordinate.hpp&gt;</code></li> <li><code>#include \"assert/assert.hpp\"</code></li> </ul>"},{"location":"blaze/las__point_8hpp/#classes","title":"Classes","text":"Type Name class LASPoint"},{"location":"blaze/las__point_8hpp/#public-types","title":"Public Types","text":"Type Name enum uint8_t LASClassification"},{"location":"blaze/las__point_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const LASClassification &amp; classification)"},{"location":"blaze/las__point_8hpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/las__point_8hpp/#enum-lasclassification","title":"enum LASClassification","text":"<pre><code>enum LASClassification {\n    CreatedNeverClassified = 0,\n    Unclassified = 1,\n    Ground = 2,\n    LowVegetation = 3,\n    MediumVegetation = 4,\n    HighVegetation = 5,\n    Building = 6,\n    LowPoint = 7,\n    ModelKeyPoint = 8,\n    Water = 9\n};\n</code></pre>"},{"location":"blaze/las__point_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/las__point_8hpp/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const LASClassification &amp; classification\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/las/las_point.hpp</code></p>"},{"location":"blaze/las__point_8hpp_source/","title":"File las_point.hpp","text":"<p>File List &gt; las &gt; las_point.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#ifdef USE_PDAL\n#include &lt;pdal/PointRef.hpp&gt;\n#endif\n#include &lt;utilities/coordinate.hpp&gt;\n\n#include \"assert/assert.hpp\"\n\nenum class LASClassification : uint8_t {\n  CreatedNeverClassified = 0,\n  Unclassified = 1,\n  Ground = 2,\n  LowVegetation = 3,\n  MediumVegetation = 4,\n  HighVegetation = 5,\n  Building = 6,\n  LowPoint = 7,\n  ModelKeyPoint = 8,\n  Water = 9\n};\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const LASClassification&amp; classification) {\n  switch (classification) {\n    case LASClassification::CreatedNeverClassified:\n      return os &lt;&lt; \"CreatedNeverClassified\";\n    case LASClassification::Unclassified:\n      return os &lt;&lt; \"Unclassified\";\n    case LASClassification::Ground:\n      return os &lt;&lt; \"Ground\";\n    case LASClassification::LowVegetation:\n      return os &lt;&lt; \"LowVegetation\";\n    case LASClassification::MediumVegetation:\n      return os &lt;&lt; \"MediumVegetation\";\n    case LASClassification::HighVegetation:\n      return os &lt;&lt; \"HighVegetation\";\n    case LASClassification::Building:\n      return os &lt;&lt; \"Building\";\n    case LASClassification::LowPoint:\n      return os &lt;&lt; \"LowPoint\";\n    case LASClassification::ModelKeyPoint:\n      return os &lt;&lt; \"ModelKeyPoint\";\n    case LASClassification::Water:\n      return os &lt;&lt; \"Water\";\n  }\n  unreachable();\n}\n\nclass LASPoint : public Coordinate3D&lt;double&gt; {\n  uint16_t m_intensity;\n  LASClassification m_classification;\n\n public:\n  LASPoint(double x, double y, double z, uint16_t intensity, LASClassification classification)\n      : Coordinate3D&lt;double&gt;(x, y, z), m_intensity(intensity), m_classification(classification) {}\n\n  LASPoint() = default;\n\n#ifdef USE_PDAL\n  explicit LASPoint(const pdal::PointRef&amp; point)\n      : Coordinate3D&lt;double&gt;(point.getFieldAs&lt;double&gt;(pdal::Dimension::Id::X),\n                             point.getFieldAs&lt;double&gt;(pdal::Dimension::Id::Y),\n                             point.getFieldAs&lt;double&gt;(pdal::Dimension::Id::Z)),\n        m_intensity(point.getFieldAs&lt;uint16_t&gt;(pdal::Dimension::Id::Intensity)),\n        m_classification(static_cast&lt;LASClassification&gt;(\n            point.getFieldAs&lt;uint8_t&gt;(pdal::Dimension::Id::Classification))) {}\n#endif\n\n  uint16_t intensity() const { return m_intensity; }\n  LASClassification classification() const { return m_classification; }\n  uint16_t&amp; intensity() { return m_intensity; }\n  LASClassification&amp; classification() { return m_classification; }\n\n#ifdef USE_PDAL\n  void write_to(pdal::PointRef point) const {\n    point.setField(pdal::Dimension::Id::X, x());\n    point.setField(pdal::Dimension::Id::Y, y());\n    point.setField(pdal::Dimension::Id::Z, z());\n    point.setField(pdal::Dimension::Id::Intensity, m_intensity);\n    point.setField(pdal::Dimension::Id::Classification, static_cast&lt;uint8_t&gt;(m_classification));\n  }\n#endif\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const LASPoint&amp; point) {\n    os &lt;&lt; \"LASPoint((\" &lt;&lt; point.x() &lt;&lt; \", \" &lt;&lt; point.y() &lt;&lt; \", \" &lt;&lt; point.z()\n       &lt;&lt; \"), I: \" &lt;&lt; point.intensity() &lt;&lt; \", C: \" &lt;&lt; point.classification() &lt;&lt; \")\";\n    return os;\n  }\n};\n</code></pre>"},{"location":"blaze/dir_d9268aef91cea3e1dbca49ee670813aa/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/printing","text":"<p>FileList &gt; lib &gt; printing</p>"},{"location":"blaze/dir_d9268aef91cea3e1dbca49ee670813aa/#files","title":"Files","text":"Type Name file to_string.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/printing/</code></p>"},{"location":"blaze/to__string_8hpp/","title":"File to_string.hpp","text":"<p>FileList &gt; lib &gt; printing &gt; to_string.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"blaze/to__string_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::string double_to_string (double d, int precision=2)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const std::vector&lt; T &gt; &amp; vec)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const std::set&lt; T &gt; &amp; set)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const std::pair&lt; T, U &gt; &amp; pair)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const std::optional&lt; T &gt; &amp; op)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const std::map&lt; T, U &gt; m)  std::string to_string (const T &amp;... args)"},{"location":"blaze/to__string_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/to__string_8hpp/#function-double_to_string","title":"function double_to_string","text":"<pre><code>inline std::string double_to_string (\n    double d,\n    int precision=2\n) \n</code></pre>"},{"location":"blaze/to__string_8hpp/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const std::vector&lt; T &gt; &amp; vec\n) \n</code></pre>"},{"location":"blaze/to__string_8hpp/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const std::set&lt; T &gt; &amp; set\n) \n</code></pre>"},{"location":"blaze/to__string_8hpp/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T, typename  U&gt;\ninline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const std::pair&lt; T, U &gt; &amp; pair\n) \n</code></pre>"},{"location":"blaze/to__string_8hpp/#function-operator_3","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T&gt;\ninline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const std::optional&lt; T &gt; &amp; op\n) \n</code></pre>"},{"location":"blaze/to__string_8hpp/#function-operator_4","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T, typename  U&gt;\ninline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const std::map&lt; T, U &gt; m\n) \n</code></pre>"},{"location":"blaze/to__string_8hpp/#function-to_string","title":"function to_string","text":"<pre><code>template&lt;typename... T&gt;\nstd::string to_string (\n    const T &amp;... args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/printing/to_string.hpp</code></p>"},{"location":"blaze/to__string_8hpp_source/","title":"File to_string.hpp","text":"<p>File List &gt; lib &gt; printing &gt; to_string.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;optional&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; vec) {\n  os &lt;&lt; \"[\";\n  for (size_t i = 0; i &lt; vec.size(); i++) {\n    os &lt;&lt; vec[i];\n    if (i &lt; vec.size() - 1) {\n      os &lt;&lt; \", \";\n    }\n  }\n  return os &lt;&lt; \"]\";\n}\n\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::set&lt;T&gt;&amp; set) {\n  os &lt;&lt; \"{\";\n  for (const T&amp; elem : set) {\n    os &lt;&lt; elem &lt;&lt; \", \";\n  }\n  return os &lt;&lt; \"}\";\n}\n\ntemplate &lt;typename T, typename U&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::pair&lt;T, U&gt;&amp; pair) {\n  return os &lt;&lt; \"(\" &lt;&lt; pair.first &lt;&lt; \", \" &lt;&lt; pair.second &lt;&lt; \")\";\n}\n\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::optional&lt;T&gt;&amp; op) {\n  if (op.has_value()) {\n    return os &lt;&lt; \"Some(\" &lt;&lt; op.value() &lt;&lt; \")\";\n  }\n  return os &lt;&lt; \"None\";\n}\n\ntemplate &lt;typename T, typename U&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::map&lt;T, U&gt; m) {\n  os &lt;&lt; \"{\";\n  for (const auto&amp; [k, v] : m) {\n    os &lt;&lt; \"(\" &lt;&lt; k &lt;&lt; \": \" &lt;&lt; v;\n  }\n  return os &lt;&lt; \"}\";\n}\n\ninline std::string double_to_string(double d, int precision = 2) {\n  std::ostringstream ss;\n  ss &lt;&lt; std::fixed &lt;&lt; std::setprecision(precision) &lt;&lt; std::noshowpoint &lt;&lt; d;\n  // Remove trailing zeros\n  std::string s = ss.str();\n  s.erase(s.find_last_not_of('0') + 1, std::string::npos);\n  if (s.back() == '.') {\n    s.pop_back();\n  }\n  return s;\n}\n\ntemplate &lt;typename... T&gt;\nstd::string to_string(const T&amp;... args) {\n  std::ostringstream ss;\n  (ss &lt;&lt; ... &lt;&lt; args);\n  return ss.str();\n}\n</code></pre>"},{"location":"blaze/dir_ca784dd9e8c063f2791dae69e4495085/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/tif","text":"<p>FileList &gt; lib &gt; tif</p>"},{"location":"blaze/dir_ca784dd9e8c063f2791dae69e4495085/#files","title":"Files","text":"Type Name file tif.cpp file tif.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/tif/</code></p>"},{"location":"blaze/tif_8cpp/","title":"File tif.cpp","text":"<p>FileList &gt; lib &gt; tif &gt; tif.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"tif.hpp\"</code></li> <li><code>#include &lt;gdal.h&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"assert/gdal_assert.hpp\"</code></li> <li><code>#include \"gdal_priv.h\"</code></li> <li><code>#include \"isom/colors.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/tif_8cpp/#classes","title":"Classes","text":"Type Name struct is_std_optional &lt;typename T&gt; struct is_std_optional&lt; std::optional&lt; T &gt; &gt; &lt;typename T&gt;"},{"location":"blaze/tif_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr bool is_std_optional_v   = <code>[**is\\_std\\_optional**](structis__std__optional.md)&amp;lt;T&amp;gt;::value</code>"},{"location":"blaze/tif_8cpp/#public-functions","title":"Public Functions","text":"Type Name constexpr GDALDataType gdal_type ()  Geo&lt; MultiBand&lt; FlexGrid &gt; &gt; read_tif (const fs::path &amp; filename)  void write_to_image_tif (const GeoGrid&lt; T &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_image_tif (const GeoGrid&lt; double &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  void write_to_tif (const Geo&lt; GridT &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_tif (const GeoGrid&lt; double &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_tif (const GeoGrid&lt; float &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_tif (const GeoGrid&lt; std::byte &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_tif (const GeoGrid&lt; RGBColor &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_tif (const GeoGrid&lt; CMYKColor &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_tif (const GeoGrid&lt; std::optional&lt; std::byte &gt; &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_tif (const GeoGrid&lt; std::optional&lt; double &gt; &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_tif (const GeoGrid&lt; std::optional&lt; float &gt; &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)  template void write_to_tif (const Geo&lt; MultiBand&lt; FlexGrid &gt; &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker)"},{"location":"blaze/tif_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/tif_8cpp/#variable-is_std_optional_v","title":"variable is_std_optional_v","text":"<pre><code>constexpr bool is_std_optional_v;\n</code></pre>"},{"location":"blaze/tif_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/tif_8cpp/#function-gdal_type","title":"function gdal_type","text":"<pre><code>template&lt;typename T&gt;\nconstexpr  GDALDataType gdal_type () \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-read_tif","title":"function read_tif","text":"<pre><code>Geo &lt; MultiBand &lt; FlexGrid &gt; &gt; read_tif (\n    const fs::path &amp; filename\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_image_tif","title":"function write_to_image_tif","text":"<pre><code>template&lt;typename T&gt;\nvoid write_to_image_tif (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_image_tif_1","title":"function write_to_image_tif","text":"<pre><code>template  void write_to_image_tif (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif","title":"function write_to_tif","text":"<pre><code>template&lt;typename GridT&gt;\nvoid write_to_tif (\n    const  Geo &lt; GridT &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif_1","title":"function write_to_tif","text":"<pre><code>template  void write_to_tif (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif_2","title":"function write_to_tif","text":"<pre><code>template  void write_to_tif (\n    const  GeoGrid &lt; float &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif_3","title":"function write_to_tif","text":"<pre><code>template  void write_to_tif (\n    const  GeoGrid &lt; std::byte &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif_4","title":"function write_to_tif","text":"<pre><code>template  void write_to_tif (\n    const  GeoGrid &lt; RGBColor &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif_5","title":"function write_to_tif","text":"<pre><code>template  void write_to_tif (\n    const  GeoGrid &lt; CMYKColor &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif_6","title":"function write_to_tif","text":"<pre><code>template  void write_to_tif (\n    const  GeoGrid &lt; std::optional&lt; std::byte &gt; &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif_7","title":"function write_to_tif","text":"<pre><code>template  void write_to_tif (\n    const  GeoGrid &lt; std::optional&lt; double &gt; &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif_8","title":"function write_to_tif","text":"<pre><code>template  void write_to_tif (\n    const  GeoGrid &lt; std::optional&lt; float &gt; &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre>"},{"location":"blaze/tif_8cpp/#function-write_to_tif_9","title":"function write_to_tif","text":"<pre><code>template  void write_to_tif (\n    const  Geo &lt; MultiBand &lt; FlexGrid &gt; &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/tif/tif.cpp</code></p>"},{"location":"blaze/tif_8cpp_source/","title":"File tif.cpp","text":"<p>File List &gt; lib &gt; tif &gt; tif.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"tif.hpp\"\n\n#include &lt;gdal.h&gt;\n\n#include &lt;optional&gt;\n#include &lt;type_traits&gt;\n\n#include \"assert/gdal_assert.hpp\"\n#include \"gdal_priv.h\"\n#include \"isom/colors.hpp\"\n#include \"utilities/timer.hpp\"\n\ntemplate &lt;typename T&gt;\nstruct is_std_optional : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct is_std_optional&lt;std::optional&lt;T&gt;&gt; : std::true_type {};\n\ntemplate &lt;typename T&gt;\ninline constexpr bool is_std_optional_v = is_std_optional&lt;T&gt;::value;\n\ntemplate &lt;typename T&gt;\nconstexpr GDALDataType gdal_type() {\n  if constexpr (std::is_same_v&lt;double, T&gt;) {\n    return GDT_Float64;\n  } else if constexpr (std::is_same_v&lt;float, T&gt;) {\n    return GDT_Float32;\n  } else if constexpr (std::is_same_v&lt;unsigned int, T&gt;) {\n    return GDT_UInt32;\n  } else if constexpr (std::is_same_v&lt;std::byte, T&gt;) {\n    return GDT_Byte;\n  } else if constexpr (is_std_optional_v&lt;T&gt;) {\n    return gdal_type&lt;typename T::value_type&gt;();\n  } else if constexpr (std::is_base_of_v&lt;Color, T&gt;) {\n    return GDT_Byte;\n  } else {\n    static_assert(std::is_base_of_v&lt;Color, T&gt;);\n  }\n}\n\nGeo&lt;MultiBand&lt;FlexGrid&gt;&gt; read_tif(const fs::path&amp; filename) {\n  TimeFunction timer(\"reading tif \" + filename.string());\n  Assert(fs::exists(filename), \"File \" + filename.string() + \" does not seem to exist\");\n  GDALAllRegister();\n  GDALDataset* dataset = (GDALDataset*)GDALOpen(filename.string().c_str(), GA_ReadOnly);\n  if (dataset == nullptr) {\n    Fail(\"Could not open file \" + filename.string());\n  }\n  size_t width = dataset-&gt;GetRasterXSize();\n  size_t height = dataset-&gt;GetRasterYSize();\n  int bands = dataset-&gt;GetRasterCount();\n  GDALDataType datatype = dataset-&gt;GetRasterBand(1)-&gt;GetRasterDataType();\n  unsigned int n_bytes = GDALGetDataTypeSizeBytes(datatype);\n  GeoTransform transform(*dataset);\n  GeoProjection projection(std::string(dataset-&gt;GetProjectionRef()));\n\n  Geo&lt;MultiBand&lt;FlexGrid&gt;&gt; result(std::move(transform), std::move(projection), bands, width, height,\n                                  n_bytes, datatype);\n  for (int band = 0; band &lt; bands; band++) {\n    GDALRasterBand* raster_band = dataset-&gt;GetRasterBand(band + 1);\n    AssertEQ(raster_band-&gt;GetRasterDataType(), datatype);\n    GDALAssert(raster_band-&gt;RasterIO(GF_Read, 0, 0, width, height, result[band].data(), width,\n                                     height, datatype, 0, 0));\n  }\n  GDALClose(dataset);\n  return result;\n}\n\ntemplate &lt;typename GridT&gt;\nvoid write_to_tif(const Geo&lt;GridT&gt;&amp; grid, const fs::path&amp; filename,\n                  std::optional&lt;ProgressTracker&gt; progress_tracker) {\n  TimeFunction timer(\"writing to tif \" + filename.string(), progress_tracker);\n  GDALAllRegister();\n\n  char** options = nullptr;\n  options = CSLSetNameValue(options, \"COMPRESS\", \"LZW\");\n  options = CSLSetNameValue(options, \"NUM_THREADS\", \"8\");\n  options = CSLSetNameValue(options, \"ALPHA\", \"YES\");\n  options = CSLSetNameValue(options, \"BIGTIFF\", \"IF_NEEDED\");\n\n  GDALDriver* driver = GetGDALDriverManager()-&gt;GetDriverByName(\"GTiff\");\n\n  int bands;\n  GDALDataType datatype;\n\n  if constexpr (std::is_same_v&lt;GridT, MultiBand&lt;FlexGrid&gt;&gt;) {\n    bands = grid.size();\n    datatype = (GDALDataType)grid[0].data_type();\n  } else {\n    using T = typename GridT::value_type;\n    bands = is_std_optional_v&lt;T&gt; ? 2 : std::is_base_of_v&lt;Color, T&gt; ? 3 : 1;\n    datatype = gdal_type&lt;T&gt;();\n  }\n  //\n  GDALDataset* dataset = driver-&gt;Create(filename.string().c_str(), grid.width(), grid.height(),\n                                        bands, datatype, options);\n\n  if (dataset == nullptr) {\n    Fail(\"Could not create file \" + filename.string());\n  }\n\n  dataset-&gt;SetGeoTransform(const_cast&lt;double*&gt;(grid.transform().get_raw()));\n  dataset-&gt;SetProjection(grid.projection().to_string().c_str());\n\n  if constexpr (std::is_same_v&lt;GridT, MultiBand&lt;FlexGrid&gt;&gt;) {\n    for (unsigned int band = 0; band &lt; grid.size(); band++) {\n      GDALAssert(dataset-&gt;GetRasterBand(band + 1)-&gt;RasterIO(\n          GF_Write, 0, 0, grid.width(), grid.height(), const_cast&lt;std::byte*&gt;(grid[band].data()),\n          grid.width(), grid.height(), datatype, 0, 0));\n    }\n  } else {\n    using T = typename GridT::value_type;\n    if constexpr (is_std_optional_v&lt;T&gt;) {\n      for (size_t i = 0; i &lt; grid.height(); i++) {\n        std::vector&lt;typename T::value_type&gt; data(grid.width());\n        std::vector&lt;typename T::value_type&gt; transparent(grid.width());\n        for (size_t j = 0; j &lt; grid.width(); j++) {\n          data[j] = grid[{j, i}].has_value() ? grid[{j, i}].value() : typename T::value_type(0);\n          transparent[j] =\n              grid[{j, i}].has_value() ? typename T::value_type(255) : typename T::value_type(0);\n        }\n\n        GDALAssert(dataset-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Write, 0, i, grid.width(), 1, data.data(),\n                                                       grid.width(), 1, datatype, 0, 0));\n        GDALAssert(dataset-&gt;GetRasterBand(2)-&gt;RasterIO(\n            GF_Write, 0, i, grid.width(), 1, transparent.data(), grid.width(), 1, datatype, 0, 0));\n      }\n    } else if constexpr (std::is_base_of_v&lt;Color, T&gt;) {\n      for (int band = 0; band &lt; 3; band++) {\n        std::vector&lt;unsigned char&gt; data(grid.width() * grid.height());\n#pragma omp parallel for\n        for (size_t i = 0; i &lt; grid.height(); i++) {\n          for (size_t j = 0; j &lt; grid.width(); j++) {\n            data[i * grid.width() + j] = grid[{j, i}].toRGB()[band];\n          }\n        }\n        GDALAssert(dataset-&gt;GetRasterBand(band + 1)-&gt;RasterIO(\n            GF_Write, 0, 0, grid.width(), grid.height(), data.data(), grid.width(), grid.height(),\n            datatype, 0, 0));\n      }\n    } else {\n      GDALAssert(dataset-&gt;GetRasterBand(1)-&gt;RasterIO(GF_Write, 0, 0, grid.width(), grid.height(),\n                                                     const_cast&lt;T*&gt;(&amp;grid[{0, 0}]), grid.width(),\n                                                     grid.height(), datatype, 0, 0));\n    }\n  }\n\n  GDALClose(dataset);\n  CSLDestroy(options);\n  ;\n}\n\ntemplate void write_to_tif(const GeoGrid&lt;double&gt;&amp; grid, const fs::path&amp; filename,\n                           std::optional&lt;ProgressTracker&gt; progress_tracker);\ntemplate void write_to_tif(const GeoGrid&lt;float&gt;&amp; grid, const fs::path&amp; filename,\n                           std::optional&lt;ProgressTracker&gt; progress_tracker);\ntemplate void write_to_tif(const GeoGrid&lt;std::byte&gt;&amp; grid, const fs::path&amp; filename,\n                           std::optional&lt;ProgressTracker&gt; progress_tracker);\ntemplate void write_to_tif(const GeoGrid&lt;RGBColor&gt;&amp; grid, const fs::path&amp; filename,\n                           std::optional&lt;ProgressTracker&gt; progress_tracker);\ntemplate void write_to_tif(const GeoGrid&lt;CMYKColor&gt;&amp; grid, const fs::path&amp; filename,\n                           std::optional&lt;ProgressTracker&gt; progress_tracker);\ntemplate void write_to_tif(const GeoGrid&lt;std::optional&lt;std::byte&gt;&gt;&amp; grid, const fs::path&amp; filename,\n                           std::optional&lt;ProgressTracker&gt; progress_tracker);\ntemplate void write_to_tif(const GeoGrid&lt;std::optional&lt;double&gt;&gt;&amp; grid, const fs::path&amp; filename,\n                           std::optional&lt;ProgressTracker&gt; progress_tracker);\ntemplate void write_to_tif(const GeoGrid&lt;std::optional&lt;float&gt;&gt;&amp; grid, const fs::path&amp; filename,\n                           std::optional&lt;ProgressTracker&gt; progress_tracker);\ntemplate void write_to_tif(const Geo&lt;MultiBand&lt;FlexGrid&gt;&gt;&amp; grid, const fs::path&amp; filename,\n                           std::optional&lt;ProgressTracker&gt; progress_tracker);\n\ntemplate &lt;typename T&gt;\nvoid write_to_image_tif(const GeoGrid&lt;T&gt;&amp; grid, const fs::path&amp; filename,\n                        std::optional&lt;ProgressTracker&gt; progress_tracker) {\n  GeoGrid&lt;std::byte&gt; result(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                            GeoProjection(grid.projection()));\n  T min = grid.min_value();\n  T max = grid.max_value();\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      if constexpr (std::is_same_v&lt;T, bool&gt;) {\n        result[{j, i}] = grid[{j, i}] ? std::byte(255) : std::byte(0);\n      } else {\n        result[{j, i}] = static_cast&lt;std::byte&gt;(255 * (grid[{j, i}] - min) / (max - min));\n      }\n    }\n  }\n  CMYKColor cmyk = CMYKColor::FromRGB(RGBColor(255, 255, 255));\n  (void)cmyk;\n  write_to_tif(result, filename,\n               progress_tracker\n                   ? std::optional&lt;ProgressTracker&gt;(progress_tracker-&gt;subtracker(0.5, 1.0))\n                   : std::nullopt);\n}\n\ntemplate void write_to_image_tif(const GeoGrid&lt;double&gt;&amp; grid, const fs::path&amp; filename,\n                                 std::optional&lt;ProgressTracker&gt; progress_tracker);\n</code></pre>"},{"location":"blaze/tif_8hpp/","title":"File tif.hpp","text":"<p>FileList &gt; lib &gt; tif &gt; tif.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"lib/grid/grid.hpp\"</code></li> <li><code>#include \"utilities/filesystem.hpp\"</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> </ul>"},{"location":"blaze/tif_8hpp/#public-functions","title":"Public Functions","text":"Type Name Geo&lt; MultiBand&lt; FlexGrid &gt; &gt; read_tif (const fs::path &amp; filename)  void write_to_image_tif (const GeoGrid&lt; T &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker={})  void write_to_tif (const Geo&lt; GridT &gt; &amp; grid, const fs::path &amp; filename, std::optional&lt; ProgressTracker &gt; progress_tracker={})"},{"location":"blaze/tif_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/tif_8hpp/#function-read_tif","title":"function read_tif","text":"<pre><code>Geo &lt; MultiBand &lt; FlexGrid &gt; &gt; read_tif (\n    const fs::path &amp; filename\n) \n</code></pre>"},{"location":"blaze/tif_8hpp/#function-write_to_image_tif","title":"function write_to_image_tif","text":"<pre><code>template&lt;typename T&gt;\nvoid write_to_image_tif (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker={}\n) \n</code></pre>"},{"location":"blaze/tif_8hpp/#function-write_to_tif","title":"function write_to_tif","text":"<pre><code>template&lt;typename GridT&gt;\nvoid write_to_tif (\n    const  Geo &lt; GridT &gt; &amp; grid,\n    const fs::path &amp; filename,\n    std::optional&lt; ProgressTracker &gt; progress_tracker={}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/tif/tif.hpp</code></p>"},{"location":"blaze/tif_8hpp_source/","title":"File tif.hpp","text":"<p>File List &gt; lib &gt; tif &gt; tif.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"lib/grid/grid.hpp\"\n#include \"utilities/filesystem.hpp\"\n#include \"utilities/progress_tracker.hpp\"\n\ntemplate &lt;typename GridT&gt;\nvoid write_to_tif(const Geo&lt;GridT&gt;&amp; grid, const fs::path&amp; filename,\n                  std::optional&lt;ProgressTracker&gt; progress_tracker = {});\n\nGeo&lt;MultiBand&lt;FlexGrid&gt;&gt; read_tif(const fs::path&amp; filename);\n\ntemplate &lt;typename T&gt;\nvoid write_to_image_tif(const GeoGrid&lt;T&gt;&amp; grid, const fs::path&amp; filename,\n                        std::optional&lt;ProgressTracker&gt; progress_tracker = {});\n</code></pre>"},{"location":"blaze/dir_f68f3bc40609949e989ead5b0b6dedfd/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/utilities","text":"<p>FileList &gt; lib &gt; utilities</p>"},{"location":"blaze/dir_f68f3bc40609949e989ead5b0b6dedfd/#files","title":"Files","text":"Type Name file coordinate.hpp file filesystem.hpp file progress_tracker.cpp file progress_tracker.hpp file resources.cpp file resources.hpp file timer.hpp"},{"location":"blaze/dir_f68f3bc40609949e989ead5b0b6dedfd/#directories","title":"Directories","text":"Type Name dir tests <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/</code></p>"},{"location":"blaze/dir_61cbaf6f69b3ff38c8740f6eb1724d7a/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/utilities/tests","text":"<p>FileList &gt; lib &gt; utilities &gt; tests</p>"},{"location":"blaze/dir_61cbaf6f69b3ff38c8740f6eb1724d7a/#files","title":"Files","text":"Type Name file progress_tracker_helper.cpp file test_progress_tracker.cpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/tests/</code></p>"},{"location":"blaze/progress__tracker__helper_8cpp/","title":"File progress_tracker_helper.cpp","text":"<p>FileList &gt; lib &gt; utilities &gt; tests &gt; progress_tracker_helper.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> </ul>"},{"location":"blaze/progress__tracker__helper_8cpp/#public-functions","title":"Public Functions","text":"Type Name void run_loop (ProgressTracker tracker)"},{"location":"blaze/progress__tracker__helper_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/progress__tracker__helper_8cpp/#function-run_loop","title":"function run_loop","text":"<pre><code>void run_loop (\n    ProgressTracker tracker\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/tests/progress_tracker_helper.cpp</code></p>"},{"location":"blaze/progress__tracker__helper_8cpp_source/","title":"File progress_tracker_helper.cpp","text":"<p>File List &gt; lib &gt; utilities &gt; tests &gt; progress_tracker_helper.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"utilities/progress_tracker.hpp\"\n\nvoid run_loop(ProgressTracker tracker) {\n  for (int i = 0; i &lt; 10; i++) {\n    ProgressTracker trackerA = tracker.subtracker(i / 10.0, (i + 1) / 10.0);\n  }\n}\n</code></pre>"},{"location":"blaze/test__progress__tracker_8cpp/","title":"File test_progress_tracker.cpp","text":"<p>FileList &gt; lib &gt; utilities &gt; tests &gt; test_progress_tracker.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;gtest/gtest.h&gt;</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> </ul>"},{"location":"blaze/test__progress__tracker_8cpp/#public-functions","title":"Public Functions","text":"Type Name TEST (ProgressTracker, ProgressTracker)  TEST (ProgressTracker, ForLoop)"},{"location":"blaze/test__progress__tracker_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/test__progress__tracker_8cpp/#function-test","title":"function TEST","text":"<pre><code>TEST (\n    ProgressTracker,\n    ProgressTracker\n) \n</code></pre>"},{"location":"blaze/test__progress__tracker_8cpp/#function-test_1","title":"function TEST","text":"<pre><code>TEST (\n    ProgressTracker,\n    ForLoop\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/tests/test_progress_tracker.cpp</code></p>"},{"location":"blaze/test__progress__tracker_8cpp_source/","title":"File test_progress_tracker.cpp","text":"<p>File List &gt; lib &gt; utilities &gt; tests &gt; test_progress_tracker.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;gtest/gtest.h&gt;\n\n#include \"utilities/progress_tracker.hpp\"\n\nTEST(ProgressTracker, ProgressTracker) {\n  ProgressTracker tracker1;\n  EXPECT_EQ(tracker1.proportion(), 0.0);\n\n  tracker1.set_proportion(0.1);\n  EXPECT_EQ(tracker1.proportion(), 0.1);\n\n  {\n    ProgressTracker trackerA(tracker1.subtracker(0.2, 0.6));\n    EXPECT_EQ(tracker1.proportion(), 0.2);\n\n    trackerA.set_proportion(0.25);\n    EXPECT_DOUBLE_EQ(tracker1.proportion(), 0.3);\n  }\n\n  EXPECT_DOUBLE_EQ(tracker1.proportion(), 0.6);\n\n  {\n    ProgressTracker trackerB = tracker1.subtracker(0.7, 0.9);\n\n    trackerB.set_proportion(0.5);\n    EXPECT_DOUBLE_EQ(tracker1.proportion(), 0.8);\n  }\n\n  {\n    ProgressTracker trackerC = tracker1.subtracker(0.9, 0.9);\n\n    trackerC.set_proportion(0.5);\n    EXPECT_DOUBLE_EQ(tracker1.proportion(), 0.9);\n  }\n\n  EXPECT_DOUBLE_EQ(tracker1.proportion(), 0.9);\n}\n\nTEST(ProgressTracker, ForLoop) {\n  ProgressTracker tracker1;\n  EXPECT_EQ(tracker1.proportion(), 0.0);\n\n  for (int i = 0; i &lt; 10; i++) {\n    ProgressTracker trackerA = tracker1.subtracker(i / 10.0, (i + 1) / 10.0);\n  }\n\n  ProgressBar bar;\n  run_loop(ProgressTracker(&amp;bar));\n}\n</code></pre>"},{"location":"blaze/coordinate_8hpp/","title":"File coordinate.hpp","text":"<p>FileList &gt; lib &gt; utilities &gt; coordinate.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"assert/assert.hpp\"</code></li> </ul>"},{"location":"blaze/coordinate_8hpp/#classes","title":"Classes","text":"Type Name class Coordinate2D &lt;typename T&gt; class Coordinate3D &lt;typename T&gt; class Direction2D struct Extent2D struct Extent3D class LineCoord2D &lt;typename T, typename&gt; class LineCoord2DCrossing &lt;typename T&gt;"},{"location":"blaze/coordinate_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name const std::array&lt; Direction2D, 8 &gt; ALL_DIRECTIONS   = <code>/* multi line expression */</code> const std::array&lt; Direction2D, 4 &gt; ORTHOGONAL_DIRECTIONS   = <code>/* multi line expression */</code>"},{"location":"blaze/coordinate_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::array&lt; Coordinate2D&lt; T &gt;, 4 &gt; orthogonal_neighbors (const Coordinate2D&lt; T &gt; &amp; coord)"},{"location":"blaze/coordinate_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/coordinate_8hpp/#variable-all_directions","title":"variable ALL_DIRECTIONS","text":"<pre><code>const std::array&lt;Direction2D, 8&gt; ALL_DIRECTIONS;\n</code></pre>"},{"location":"blaze/coordinate_8hpp/#variable-orthogonal_directions","title":"variable ORTHOGONAL_DIRECTIONS","text":"<pre><code>const std::array&lt;Direction2D, 4&gt; ORTHOGONAL_DIRECTIONS;\n</code></pre>"},{"location":"blaze/coordinate_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/coordinate_8hpp/#function-orthogonal_neighbors","title":"function orthogonal_neighbors","text":"<pre><code>template&lt;typename T, typename&gt;\nstd::array&lt; Coordinate2D &lt; T &gt;, 4 &gt; orthogonal_neighbors (\n    const  Coordinate2D &lt; T &gt; &amp; coord\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/coordinate.hpp</code></p>"},{"location":"blaze/coordinate_8hpp_source/","title":"File coordinate.hpp","text":"<p>File List &gt; lib &gt; utilities &gt; coordinate.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;ostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#include \"assert/assert.hpp\"\n\nclass Direction2D {\n public:\n  enum Dir { UP, DOWN, LEFT, RIGHT, UR, UL, DR, DL };\n\n private:\n  Dir m_dir;\n\n public:\n  Direction2D(Dir dir) : m_dir(dir) {}\n  operator Dir() const { return m_dir; }\n\n  std::array&lt;Direction2D, 2&gt; orthogonal_dirs() const {\n    if (m_dir == DOWN || m_dir == UP) return {{LEFT, RIGHT}};\n    return {{UP, DOWN}};\n  }\n  bool orthogonal_to(Direction2D other) const {\n    return ((m_dir == UP || m_dir == DOWN) &amp;&amp; (other.m_dir == LEFT || other.m_dir == RIGHT)) ||\n           ((m_dir == LEFT || m_dir == RIGHT) &amp;&amp; (other.m_dir == UP || other.m_dir == DOWN));\n  }\n\n  int dx() const {\n    switch (m_dir) {\n      case UP:\n      case DOWN:\n        return 0;\n      case LEFT:\n      case UL:\n      case DL:\n        return -1;\n      case RIGHT:\n      case UR:\n      case DR:\n        return 1;\n    }\n    unreachable();\n  }\n\n  int dy() const {\n    switch (m_dir) {\n      case UP:\n      case UR:\n      case UL:\n        return -1;\n      case DOWN:\n      case DR:\n      case DL:\n        return 1;\n      case LEFT:\n      case RIGHT:\n        return 0;\n    }\n    unreachable();\n  }\n\n  Direction2D opposite() const {\n    switch (m_dir) {\n      case UP:\n        return Direction2D(DOWN);\n      case DOWN:\n        return Direction2D(UP);\n      case LEFT:\n        return Direction2D(RIGHT);\n      case RIGHT:\n        return Direction2D(LEFT);\n      case UR:\n        return Direction2D(DL);\n      case UL:\n        return Direction2D(DR);\n      case DR:\n        return Direction2D(UL);\n      case DL:\n        return Direction2D(UR);\n    }\n    unreachable();\n  }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Direction2D&amp; dir) {\n    switch (dir.m_dir) {\n      case UP:\n        os &lt;&lt; \"UP\";\n        break;\n      case DOWN:\n        os &lt;&lt; \"DOWN\";\n        break;\n      case LEFT:\n        os &lt;&lt; \"LEFT\";\n        break;\n      case RIGHT:\n        os &lt;&lt; \"RIGHT\";\n        break;\n      case UR:\n        os &lt;&lt; \"UR\";\n        break;\n      case UL:\n        os &lt;&lt; \"UL\";\n        break;\n      case DR:\n        os &lt;&lt; \"DR\";\n        break;\n      case DL:\n        os &lt;&lt; \"DL\";\n        break;\n    }\n    return os;\n  }\n};\n\nconst std::array&lt;Direction2D, 4&gt; ORTHOGONAL_DIRECTIONS = {\n    Direction2D(Direction2D::UP), Direction2D(Direction2D::DOWN), Direction2D(Direction2D::LEFT),\n    Direction2D(Direction2D::RIGHT)};\n\nconst std::array&lt;Direction2D, 8&gt; ALL_DIRECTIONS = {\n    Direction2D(Direction2D::UP),    Direction2D(Direction2D::DOWN), Direction2D(Direction2D::LEFT),\n    Direction2D(Direction2D::RIGHT), Direction2D(Direction2D::UR),   Direction2D(Direction2D::UL),\n    Direction2D(Direction2D::DR),    Direction2D(Direction2D::DL)};\n\ntemplate &lt;typename T&gt;\nclass Coordinate2D {\n  static_assert(std::is_arithmetic&lt;T&gt;::value, \"Coordinate2D only supports arithmetic types\");\n\n  std::array&lt;T, 2&gt; m_data;\n\n public:\n  Coordinate2D(T x, T y) : m_data{{x, y}} {}\n\n  Coordinate2D() = default;\n\n  const T&amp; x() const { return m_data[0]; }\n  const T&amp; y() const { return m_data[1]; }\n  T&amp; x() { return m_data[0]; }\n  T&amp; y() { return m_data[1]; }\n\n  template &lt;typename U&gt;\n  operator Coordinate2D&lt;U&gt;() const {\n    return Coordinate2D&lt;U&gt;(x(), y());\n  }\n\n  Coordinate2D&lt;double&gt; offset_to_center() const {\n    return Coordinate2D&lt;double&gt;(x() + 0.5, y() + 0.5);\n  }\n\n  Coordinate2D&lt;double&gt; round_NW(double grid_size) const {\n    return Coordinate2D&lt;double&gt;(x() - fmod(x(), grid_size), y() + grid_size - fmod(y(), grid_size));\n  }\n\n  Coordinate2D&lt;size_t&gt; round() const { return Coordinate2D&lt;size_t&gt;(x() + 0.5, y() + 0.5); }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Coordinate2D&amp; coord) {\n    os &lt;&lt; \"Coordinate2D(\" &lt;&lt; coord.x() &lt;&lt; \", \" &lt;&lt; coord.y() &lt;&lt; \")\";\n    return os;\n  }\n\n  Coordinate2D operator+(Direction2D dir) const {\n    switch (dir) {\n      case Direction2D::UP:\n        return Coordinate2D(x(), y() - 1);\n      case Direction2D::DOWN:\n        return Coordinate2D(x(), y() + 1);\n      case Direction2D::LEFT:\n        return Coordinate2D(x() - 1, y());\n      case Direction2D::RIGHT:\n        return Coordinate2D(x() + 1, y());\n      case Direction2D::UR:\n        return Coordinate2D(x() + 1, y() - 1);\n      case Direction2D::UL:\n        return Coordinate2D(x() - 1, y() - 1);\n      case Direction2D::DR:\n        return Coordinate2D(x() + 1, y() + 1);\n      case Direction2D::DL:\n        return Coordinate2D(x() - 1, y() + 1);\n    }\n    unreachable();\n  }\n\n  Coordinate2D operator+(Coordinate2D o) const { return Coordinate2D(x() + o.x(), y() + o.y()); }\n  Coordinate2D operator-(Coordinate2D o) const { return Coordinate2D(x() - o.x(), y() - o.y()); }\n  bool operator==(const Coordinate2D&amp; o) const { return x() == o.x() &amp;&amp; y() == o.y(); }\n\n  T magnitude_sqd() const { return x() * x() + y() * y(); }\n  T magnitude() const { return std::sqrt(magnitude_sqd()); }\n};\n\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt;\nstd::array&lt;Coordinate2D&lt;T&gt;, 4&gt; orthogonal_neighbors(const Coordinate2D&lt;T&gt;&amp; coord) {\n  return {Coordinate2D&lt;T&gt;(coord.x() - 1, coord.y()), Coordinate2D&lt;T&gt;(coord.x() + 1, coord.y()),\n          Coordinate2D&lt;T&gt;(coord.x(), coord.y() - 1), Coordinate2D&lt;T&gt;(coord.x(), coord.y() + 1)};\n}\n\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt;\nclass LineCoord2D : public Coordinate2D&lt;T&gt; {\n  Direction2D m_dir;\n\n public:\n  LineCoord2D(T x, T y, Direction2D dir) : Coordinate2D&lt;T&gt;(x, y), m_dir(dir) {}\n  LineCoord2D(const Coordinate2D&lt;T&gt;&amp; coord, Direction2D dir) : Coordinate2D&lt;T&gt;(coord), m_dir(dir) {}\n  Coordinate2D&lt;T&gt; start() const { return *this; }\n  Coordinate2D&lt;T&gt; end() const { return *this + m_dir; }\n\n  Direction2D dir() const { return m_dir; }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const LineCoord2D&amp; line_coord) {\n    os &lt;&lt; \"LineCoord2D(\" &lt;&lt; line_coord.start() &lt;&lt; \", \" &lt;&lt; line_coord.dir() &lt;&lt; \")\";\n    return os;\n  }\n};\n\ntemplate &lt;typename T&gt;\nclass Coordinate3D : public Coordinate2D&lt;T&gt; {\n  double m_z;\n\n public:\n  Coordinate3D(T x, T y, T z) : Coordinate2D&lt;T&gt;(x, y), m_z(z) {}\n\n  Coordinate3D() = default;\n\n  const T z() const { return m_z; }\n  T&amp; z() { return m_z; }\n};\n\ntemplate &lt;typename T&gt;\nclass LineCoord2DCrossing : public LineCoord2D&lt;T&gt; {\n  Direction2D m_crossing_dir;\n\n public:\n  LineCoord2DCrossing(T x, T y, Direction2D dir, Direction2D crossing_dir)\n      : LineCoord2D&lt;T&gt;(x, y, dir), m_crossing_dir(crossing_dir) {}\n  LineCoord2DCrossing(const LineCoord2D&lt;T&gt;&amp; line_coord, Direction2D crossing_dir)\n      : LineCoord2D&lt;T&gt;(line_coord), m_crossing_dir(crossing_dir) {}\n\n  Direction2D crossing_dir() const { return m_crossing_dir; }\n\n  LineCoord2DCrossing flip() const {\n    return LineCoord2DCrossing({LineCoord2D&lt;T&gt;::end(), LineCoord2D&lt;T&gt;::dir().opposite()},\n                               m_crossing_dir);\n  }\n\n  std::vector&lt;LineCoord2DCrossing&gt; next_points() const {\n    std::vector&lt;LineCoord2DCrossing&gt; result;\n\n    std::vector&lt;Direction2D&gt; dirs;\n    if (LineCoord2D&lt;T&gt;::dir().orthogonal_to(crossing_dir())) {\n      dirs.emplace_back(crossing_dir());\n    } else {\n      for (Direction2D dir :\n           {Direction2D::UP, Direction2D::DOWN, Direction2D::LEFT, Direction2D::RIGHT}) {\n        if (dir.orthogonal_to(LineCoord2D&lt;T&gt;::dir())) {\n          dirs.emplace_back(dir);\n        }\n      }\n    }\n\n    for (Direction2D dir : dirs) {\n      Assert(dir.orthogonal_to(LineCoord2D&lt;T&gt;::dir()),\n             \"Crossing direction is not orthogonal to direction\");\n      result.emplace_back(LineCoord2DCrossing&lt;T&gt;({LineCoord2D&lt;T&gt;::start() + dir, dir.opposite()},\n                                                 LineCoord2D&lt;T&gt;::dir().opposite()));\n      result.emplace_back(LineCoord2DCrossing&lt;T&gt;({LineCoord2D&lt;T&gt;::end() + dir, dir.opposite()},\n                                                 LineCoord2D&lt;T&gt;::dir()));\n      result.emplace_back(\n          LineCoord2DCrossing&lt;T&gt;({LineCoord2D&lt;T&gt;::start() + dir, LineCoord2D&lt;T&gt;::dir()}, dir));\n    }\n\n    for (size_t i = 0; i &lt; result.size(); i++) {\n      if (result[i].dir() == Direction2D::UP || result[i].dir() == Direction2D::LEFT) {\n        result[i] = result[i].flip();\n      }\n    }\n\n    return result;\n  }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const LineCoord2DCrossing&amp; line_coord) {\n    os &lt;&lt; \"LineCoord2DCrossing(\" &lt;&lt; line_coord.start() &lt;&lt; \", \" &lt;&lt; line_coord.dir() &lt;&lt; \", \"\n       &lt;&lt; line_coord.crossing_dir() &lt;&lt; \")\";\n    return os;\n  }\n};\n\nstruct Extent2D {\n  double minx = std::numeric_limits&lt;double&gt;::infinity();\n  double maxx = -std::numeric_limits&lt;double&gt;::infinity();\n  double miny = std::numeric_limits&lt;double&gt;::infinity();\n  double maxy = -std::numeric_limits&lt;double&gt;::infinity();\n\n  bool contains(double x, double y) const {\n    return minx &lt;= x &amp;&amp; x &lt;= maxx &amp;&amp; miny &lt;= y &amp;&amp; y &lt;= maxy;\n  }\n\n  void grow(const Extent2D&amp; other) {\n    minx = std::min(minx, other.minx);\n    maxx = std::max(maxx, other.maxx);\n    miny = std::min(miny, other.miny);\n    maxy = std::max(maxy, other.maxy);\n  }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Extent2D&amp; extent) {\n    return os &lt;&lt; \"[(\" &lt;&lt; extent.minx &lt;&lt; \", \" &lt;&lt; extent.maxx &lt;&lt; \"), (\" &lt;&lt; extent.miny &lt;&lt; \", \"\n              &lt;&lt; extent.maxy &lt;&lt; \")]\";\n  }\n};\n\nstruct Extent3D : Extent2D {\n  double minz = std::numeric_limits&lt;double&gt;::infinity();\n  double maxz = -std::numeric_limits&lt;double&gt;::infinity();\n\n  Extent3D() = default;\n  Extent3D(const Extent2D&amp; extent, double minz, double maxz)\n      : Extent2D(extent), minz(minz), maxz(maxz) {}\n  Extent3D(double minx, double maxx, double miny, double maxy, double minz, double maxz)\n      : Extent2D{minx, maxx, miny, maxy}, minz(minz), maxz(maxz) {}\n\n  void grow(double x, double y, double z) {\n    minx = std::min(x, minx);\n    maxx = std::max(x, maxx);\n    miny = std::min(y, miny);\n    maxy = std::max(y, maxy);\n    minz = std::min(z, minz);\n    maxz = std::max(z, maxz);\n  }\n\n  void grow(double border) {\n    minx -= border;\n    maxx += border;\n    miny -= border;\n    maxy += border;\n    minz -= border;\n    maxz += border;\n  }\n\n  bool intersects(const Extent3D&amp; other) const {\n    return !(other.minx &gt; maxx || other.maxx &lt; minx || other.miny &gt; maxy || other.maxy &lt; miny ||\n             other.minz &gt; maxz || other.maxz &lt; minz);\n  }\n\n  Coordinate3D&lt;double&gt; center() const {\n    return Coordinate3D&lt;double&gt;((minx + maxx) / 2, (miny + maxy) / 2, (minz + maxz) / 2);\n  }\n\n  double max_extent() const { return std::max(std::max(maxx - minx, maxy - miny), maxz - minz); }\n\n  void grow(const Extent3D&amp; other) {\n    Extent2D::grow(other);\n    minz = std::min(minz, other.minz);\n    maxz = std::max(maxz, other.maxz);\n  }\n\n  Extent3D operator-(const Coordinate3D&lt;double&gt;&amp; offset) const {\n    return {minx - offset.x(), maxx - offset.x(), miny - offset.y(),\n            maxy - offset.y(), minz - offset.z(), maxz - offset.z()};\n  }\n\n  Extent3D intersection(const Extent3D&amp; other) const {\n    return {std::max(minx, other.minx), std::min(maxx, other.maxx), std::max(miny, other.miny),\n            std::min(maxy, other.maxy), std::max(minz, other.minz), std::min(maxz, other.maxz)};\n  }\n\n  bool operator!=(const Extent3D&amp; other) const {\n    return minx != other.minx || maxx != other.maxx || miny != other.miny || maxy != other.maxy ||\n           minz != other.minz || maxz != other.maxz;\n  }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Extent3D&amp; extent) {\n    return os &lt;&lt; \"[(\" &lt;&lt; extent.minx &lt;&lt; \", \" &lt;&lt; extent.maxx &lt;&lt; \"), (\" &lt;&lt; extent.miny &lt;&lt; \", \"\n              &lt;&lt; extent.maxy &lt;&lt; \"), (\" &lt;&lt; extent.minz &lt;&lt; \", \" &lt;&lt; extent.maxz &lt;&lt; \")]\";\n  }\n};\n</code></pre>"},{"location":"blaze/filesystem_8hpp/","title":"File filesystem.hpp","text":"<p>FileList &gt; lib &gt; utilities &gt; filesystem.hpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/filesystem.hpp</code></p>"},{"location":"blaze/filesystem_8hpp_source/","title":"File filesystem.hpp","text":"<p>File List &gt; lib &gt; utilities &gt; filesystem.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Check if the compiler supports C++17 or later\n#if __cplusplus &gt;= 201703L || defined(_HAS_CXX17) || defined(_MSC_VER) &amp;&amp; _MSVC_LANG &gt;= 201703L\n#include &lt;filesystem&gt;\nnamespace fs = std::filesystem;\n#elif __cplusplus &gt;= 201402L  // Check if the compiler supports C++14\n#include &lt;experimental/filesystem&gt;\nnamespace fs = std::experimental::filesystem;\n#else\n#error \"No filesystem support\"\n#endif\n</code></pre>"},{"location":"blaze/progress__tracker_8cpp/","title":"File progress_tracker.cpp","text":"<p>FileList &gt; lib &gt; utilities &gt; progress_tracker.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"progress_tracker.hpp\"</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"assert/assert.hpp\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/progress_tracker.cpp</code></p>"},{"location":"blaze/progress__tracker_8cpp_source/","title":"File progress_tracker.cpp","text":"<p>File List &gt; lib &gt; utilities &gt; progress_tracker.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"progress_tracker.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;optional&gt;\n#include &lt;utility&gt;\n\n#include \"assert/assert.hpp\"\n\nProgressObserver::~ProgressObserver() {};\n\nvoid ProgressBar::update_progress(double progress) {\n  if (progress - m_last_progress &lt; 0.0001) {\n    return;\n  }\n  std::cout &lt;&lt; \"Progress: \" &lt;&lt; progress * 100 &lt;&lt; \"%\" &lt;&lt; std::endl;\n  m_last_progress = progress;\n}\n\nvoid ProgressBar::text_update(const std::string&amp; text, int depth) {\n  std::cout &lt;&lt; std::string(2 * (depth - 1), ' ') &lt;&lt; text &lt;&lt; std::endl;\n};\n\nvoid ProgressTracker::_set_proportion(double proportion) {\n  AssertGE(proportion, m_proportion);\n  AssertGE(1, proportion);\n  m_proportion = proportion;\n  if (m_observer != nullptr) {\n    m_observer-&gt;update_progress(m_proportion);\n  }\n}\n\nProgressTracker::ProgressTracker(ProgressObserver* observer)\n    : m_proportion(0), m_observer(observer) {\n  if (m_observer != nullptr) {\n    m_observer-&gt;m_child = this;\n  }\n  ProgressTracker* parent_tracker = dynamic_cast&lt;ProgressTracker*&gt;(observer);\n  if (parent_tracker != nullptr) {\n    Assert(parent_tracker-&gt;m_subtracker_range.has_value());\n  }\n}\n\nProgressTracker::ProgressTracker(ProgressTracker&amp;&amp; other) {\n  m_proportion = other.m_proportion;\n  m_observer = other.m_observer;\n  Assert(!other.m_subtracker_range.has_value());\n  other.m_observer = nullptr;\n};\n\nvoid ProgressTracker::set_proportion(double proportion) {\n  Assert(!m_subtracker_range.has_value());\n  _set_proportion(proportion);\n}\n\nvoid ProgressTracker::update_progress(double progress) {\n  Assert(m_subtracker_range.has_value());\n  _set_proportion(m_subtracker_range-&gt;first +\n                  progress * (m_subtracker_range-&gt;second - m_subtracker_range-&gt;first));\n}\n\nvoid ProgressTracker::text_update(const std::string&amp; text, int depth) {\n  if (m_observer != nullptr) {\n    m_observer-&gt;text_update(text, depth + 1);\n  }\n};\n\nProgressTracker ProgressTracker::subtracker(double start, double end) {\n  set_proportion(start);\n  AssertGE(end, start);\n  AssertGE(1, end);\n  m_subtracker_range = std::make_pair(start, end);\n  ProgressTracker to_return(this);\n  m_child = &amp;to_return;\n  m_child-&gt;_set_proportion(0);\n  return to_return;\n}\n\nProgressTracker::~ProgressTracker() {\n  _set_proportion(1);\n  if (m_observer != nullptr) {\n    m_observer-&gt;m_child = nullptr;\n  }\n  ProgressTracker* ptr = dynamic_cast&lt;ProgressTracker*&gt;(m_observer);\n  if (ptr != nullptr) {\n    ptr-&gt;m_subtracker_range.reset();\n  }\n}\n</code></pre>"},{"location":"blaze/progress__tracker_8hpp/","title":"File progress_tracker.hpp","text":"<p>FileList &gt; lib &gt; utilities &gt; progress_tracker.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"blaze/progress__tracker_8hpp/#classes","title":"Classes","text":"Type Name class AsyncProgressTracker class ProgressBar class ProgressObserver class ProgressTracker"},{"location":"blaze/progress__tracker_8hpp/#public-functions","title":"Public Functions","text":"Type Name void run_loop (ProgressTracker tracker)"},{"location":"blaze/progress__tracker_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/progress__tracker_8hpp/#function-run_loop","title":"function run_loop","text":"<pre><code>void run_loop (\n    ProgressTracker tracker\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/progress_tracker.hpp</code></p>"},{"location":"blaze/progress__tracker_8hpp_source/","title":"File progress_tracker.hpp","text":"<p>File List &gt; lib &gt; utilities &gt; progress_tracker.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\nclass ProgressTracker;\n\nclass ProgressObserver {\n  ProgressTracker* m_child;\n\n protected:\n  virtual void update_progress(double progress) = 0;\n  virtual void text_update(const std::string&amp; text, int depth = 0) = 0;\n\n  ProgressObserver() : m_child(nullptr) {}\n\n public:\n  ProgressTracker* child() { return m_child; }\n\n  virtual ~ProgressObserver();\n  friend class ProgressTracker;\n};\n\nclass ProgressBar : public ProgressObserver {\n  double m_last_progress = -1;\n\n protected:\n  virtual void update_progress(double progress) override;\n  virtual void text_update(const std::string&amp; text, int depth = 0) override;\n};\n\nclass ProgressTracker : public ProgressObserver {\n  double m_proportion;\n  ProgressObserver* m_observer;\n  std::optional&lt;std::pair&lt;double, double&gt;&gt; m_subtracker_range;\n\n  void _set_proportion(double proportion);\n\n protected:\n  virtual void update_progress(double progress) override;\n\n public:\n  explicit ProgressTracker(ProgressObserver* observer = nullptr);\n\n  virtual void text_update(const std::string&amp; text, int depth = 0) override;\n\n  ProgressTracker(const ProgressTracker&amp; other) = delete;\n  ProgressTracker&amp; operator=(const ProgressTracker&amp; other) = delete;\n  ProgressTracker(ProgressTracker&amp;&amp; other);\n  ProgressTracker&amp; operator=(ProgressTracker&amp;&amp; other) = delete;\n\n  void set_proportion(double proportion);\n\n  ProgressTracker subtracker(double start, double end);\n\n  virtual ~ProgressTracker();\n\n  double proportion() const { return m_proportion; }\n};\n\nclass AsyncProgressTracker {\n  std::shared_ptr&lt;ProgressTracker&gt; m_tracker;\n\n public:\n  AsyncProgressTracker() : m_tracker(std::make_shared&lt;ProgressTracker&gt;()) {}\n\n  std::shared_ptr&lt;ProgressTracker&gt; tracker() { return m_tracker; }\n};\n\nvoid run_loop(ProgressTracker tracker);\n</code></pre>"},{"location":"blaze/resources_8cpp/","title":"File resources.cpp","text":"<p>FileList &gt; lib &gt; utilities &gt; resources.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"resources.hpp\"</code></li> <li><code>#include \"assert/assert.hpp\"</code></li> <li><code>#include \"printing/to_string.hpp\"</code></li> </ul>"},{"location":"blaze/resources_8cpp/#public-functions","title":"Public Functions","text":"Type Name fs::path get_asset_dir ()  fs::path get_local_data_dir ()"},{"location":"blaze/resources_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/resources_8cpp/#function-get_asset_dir","title":"function get_asset_dir","text":"<pre><code>fs::path get_asset_dir () \n</code></pre>"},{"location":"blaze/resources_8cpp/#function-get_local_data_dir","title":"function get_local_data_dir","text":"<pre><code>fs::path get_local_data_dir () \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/resources.cpp</code></p>"},{"location":"blaze/resources_8cpp_source/","title":"File resources.cpp","text":"<p>File List &gt; lib &gt; utilities &gt; resources.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"resources.hpp\"\n\n#include \"assert/assert.hpp\"\n#include \"printing/to_string.hpp\"\n\n#if defined(__WIN32__) || defined(_WIN32)\n#include &lt;winsock2.h&gt;\n// Don't reorder\n#include &lt;KnownFolders.h&gt;\n#include &lt;shlobj.h&gt;\n#include &lt;windows.h&gt;\n#endif\n#ifdef __linux__\n#include &lt;linux/limits.h&gt;\n#include &lt;unistd.h&gt;\n#endif\n\nfs::path get_asset_dir() {\n#if defined(__WIN32__) || defined(_WIN32)\n  char buffer[MAX_PATH];\n  GetModuleFileNameA(NULL, buffer, MAX_PATH);\n  fs::path path(buffer);\n#endif\n#ifdef __linux__\n  char buffer[PATH_MAX];\n  ssize_t len = readlink(\"/proc/self/exe\", buffer, sizeof(buffer) - 1);\n  if (len != -1) {\n    buffer[len] = '\\0';\n  }\n  fs::path path(buffer);\n#endif\n  std::vector&lt;fs::path&gt; asset_paths = {path.parent_path().parent_path() / \"share\" / \"assets\"};\n  while (path.has_parent_path() &amp;&amp; path.parent_path() != path) {\n    path = path.parent_path();\n    asset_paths.push_back(path / \"assets\");\n  }\n  for (fs::path asset_path : asset_paths) {\n    if (fs::exists(asset_path)) {\n      return asset_path;\n    }\n  }\n  Fail(\"Could not find asset directory. Tried \" + to_string(asset_paths));\n}\n\nfs::path AssetRetriever::get_asset(const fs::path&amp; asset) { return get_asset_dir() / asset; }\n\nfs::path get_local_data_dir() {\n#if defined(__WIN32__) || defined(_WIN32)\n  PWSTR path = nullptr;\n  HRESULT hr = SHGetKnownFolderPath(FOLDERID_LocalAppData, 0, nullptr, &amp;path);\n\n  if (SUCCEEDED(hr)) {\n    std::wstring ws(path);\n    CoTaskMemFree(path);\n    fs::path data_path = fs::path(std::string(ws.begin(), ws.end())) / \"blaze\";\n    fs::create_directories(data_path);\n    return data_path;\n  }\n  Fail(\"Could not get local windows data directory\");\n#endif\n#ifdef __linux__\n  const char* home_dir = getenv(\"HOME\");\n  if (home_dir == nullptr) {\n    Fail(\"Could not get local linux data directory\");\n  }\n  fs::path path = fs::path(home_dir) / \".local\" / \"share\" / \"blaze\";\n  fs::create_directories(path);\n  return path;\n#endif\n}\n\nfs::path LocalDataRetriever::get_local_data(const fs::path&amp; asset) {\n  return get_local_data_dir() / asset;\n}\n</code></pre>"},{"location":"blaze/resources_8hpp/","title":"File resources.hpp","text":"<p>FileList &gt; lib &gt; utilities &gt; resources.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"utilities/filesystem.hpp\"</code></li> </ul>"},{"location":"blaze/resources_8hpp/#classes","title":"Classes","text":"Type Name class AssetRetriever class LocalDataRetriever <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/resources.hpp</code></p>"},{"location":"blaze/resources_8hpp_source/","title":"File resources.hpp","text":"<p>File List &gt; lib &gt; utilities &gt; resources.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"utilities/filesystem.hpp\"\n\nclass AssetRetriever {\n public:\n  static fs::path get_asset(const fs::path&amp; asset);\n};\n\nclass LocalDataRetriever {\n public:\n  static fs::path get_local_data(const fs::path&amp; asset);\n};\n</code></pre>"},{"location":"blaze/timer_8hpp/","title":"File timer.hpp","text":"<p>FileList &gt; lib &gt; utilities &gt; timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;ostream&gt;</code></li> <li><code>#include \"printing/to_string.hpp\"</code></li> <li><code>#include \"progress_tracker.hpp\"</code></li> </ul>"},{"location":"blaze/timer_8hpp/#classes","title":"Classes","text":"Type Name class TimeFunction class Timer"},{"location":"blaze/timer_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, const std::chrono::duration&lt; double &gt; &amp; duration)"},{"location":"blaze/timer_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/timer_8hpp/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; os,\n    const std::chrono::duration&lt; double &gt; &amp; duration\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/utilities/timer.hpp</code></p>"},{"location":"blaze/timer_8hpp_source/","title":"File timer.hpp","text":"<p>File List &gt; lib &gt; utilities &gt; timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;ostream&gt;\n\n#include \"printing/to_string.hpp\"\n#include \"progress_tracker.hpp\"\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::chrono::duration&lt;double&gt;&amp; duration) {\n  if (duration.count() &lt; 1e-6) {\n    os &lt;&lt; duration.count() * 1e9 &lt;&lt; \"ns\";\n  } else if (duration.count() &lt; 1e-3) {\n    os &lt;&lt; duration.count() * 1e6 &lt;&lt; \"us\";\n  } else if (duration.count() &lt; 1) {\n    os &lt;&lt; duration.count() * 1e3 &lt;&lt; \"ms\";\n  } else {\n    os &lt;&lt; duration.count() &lt;&lt; \"s\";\n  }\n  return os;\n}\n\nclass Timer {\n  std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_start;\n\n public:\n  Timer() : m_start(std::chrono::high_resolution_clock::now()) {}\n\n  std::chrono::duration&lt;double&gt; duration() const {\n    return std::chrono::high_resolution_clock::now() - m_start;\n  }\n\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Timer&amp; timer) {\n    os &lt;&lt; timer.duration();\n    return os;\n  }\n};\n\nclass TimeFunction : public Timer {\n  std::string m_name;\n  ProgressTracker* m_progress_tracker;\n\n public:\n  TimeFunction(const std::string&amp; name, ProgressTracker* progress_tracker = nullptr)\n      : m_name(name), m_progress_tracker(progress_tracker) {\n    if (m_progress_tracker) {\n      m_progress_tracker-&gt;text_update(to_string(\"Starting \", m_name, \" ...\"));\n    } else {\n      std::cout &lt;&lt; \"Starting \" &lt;&lt; m_name &lt;&lt; \" ...\" &lt;&lt; std::endl;\n    }\n  }\n\n  TimeFunction(const std::string&amp; name, std::optional&lt;ProgressTracker&gt;&amp; progress_tracker)\n      : TimeFunction(name, progress_tracker ? &amp;*progress_tracker : nullptr) {}\n\n  ~TimeFunction() {\n    if (m_progress_tracker) {\n      m_progress_tracker-&gt;text_update(to_string(\"Finished \", m_name, \" in \", duration().count()));\n    } else {\n      std::cout &lt;&lt; \"Finished \" &lt;&lt; m_name &lt;&lt; \" in \" &lt;&lt; duration().count() &lt;&lt; std::endl;\n    }\n  }\n};\n</code></pre>"},{"location":"blaze/dir_b743e47c5a2b15e05ebb68ed1bfc6ebf/","title":"Dir /home/runner/work/Blaze/Blaze/src/lib/vegetation","text":"<p>FileList &gt; lib &gt; vegetation</p>"},{"location":"blaze/dir_b743e47c5a2b15e05ebb68ed1bfc6ebf/#files","title":"Files","text":"Type Name file vegetation.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/vegetation/</code></p>"},{"location":"blaze/vegetation_8hpp/","title":"File vegetation.hpp","text":"<p>FileList &gt; lib &gt; vegetation &gt; vegetation.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"grid/grid.hpp\"</code></li> <li><code>#include \"las/las_point.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/vegetation_8hpp/#public-functions","title":"Public Functions","text":"Type Name GeoGrid&lt; std::optional&lt; float &gt; &gt; get_blocked_proportion (const GeoGrid&lt; std::vector&lt; LASPoint &gt; &gt; &amp; grid, const GeoGrid&lt; double &gt; &amp; ground, const VegeHeightConfig &amp; vege_config)  GeoGrid&lt; float &gt; low_pass (const GeoGrid&lt; float &gt; &amp; grid, int delta=8)  GeoGrid&lt; float &gt; low_pass (const GeoGrid&lt; std::optional&lt; float &gt; &gt; &amp; grid, int delta=8)"},{"location":"blaze/vegetation_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/vegetation_8hpp/#function-get_blocked_proportion","title":"function get_blocked_proportion","text":"<pre><code>inline GeoGrid &lt; std::optional&lt; float &gt; &gt; get_blocked_proportion (\n    const  GeoGrid &lt; std::vector&lt; LASPoint &gt; &gt; &amp; grid,\n    const  GeoGrid &lt; double &gt; &amp; ground,\n    const  VegeHeightConfig &amp; vege_config\n) \n</code></pre>"},{"location":"blaze/vegetation_8hpp/#function-low_pass","title":"function low_pass","text":"<pre><code>inline GeoGrid &lt; float &gt; low_pass (\n    const  GeoGrid &lt; float &gt; &amp; grid,\n    int delta=8\n) \n</code></pre>"},{"location":"blaze/vegetation_8hpp/#function-low_pass_1","title":"function low_pass","text":"<pre><code>inline GeoGrid &lt; float &gt; low_pass (\n    const  GeoGrid &lt; std::optional&lt; float &gt; &gt; &amp; grid,\n    int delta=8\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/lib/vegetation/vegetation.hpp</code></p>"},{"location":"blaze/vegetation_8hpp_source/","title":"File vegetation.hpp","text":"<p>File List &gt; lib &gt; vegetation &gt; vegetation.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstddef&gt;\n\n#include \"config_input/config_input.hpp\"\n#include \"grid/grid.hpp\"\n#include \"las/las_point.hpp\"\n#include \"utilities/coordinate.hpp\"\n#include \"utilities/timer.hpp\"\n\ninline GeoGrid&lt;std::optional&lt;float&gt;&gt; get_blocked_proportion(\n    const GeoGrid&lt;std::vector&lt;LASPoint&gt;&gt;&amp; grid, const GeoGrid&lt;double&gt;&amp; ground,\n    const VegeHeightConfig&amp; vege_config) {\n  TimeFunction timer(\"counting \" + vege_config.name + \" blocked proportion\");\n  GeoGrid&lt;std::optional&lt;float&gt;&gt; blocked_proportion(grid.width(), grid.height(),\n                                                   GeoTransform(grid.transform()),\n                                                   GeoProjection(grid.projection()));\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      size_t below_count = 0;\n      size_t in_count = 0;\n      for (const LASPoint&amp; las_point : grid[{j, i}]) {\n        double ground_height = interpolate_value(ground, las_point);\n        double height = las_point.z() - ground_height;\n        if (height &gt; -1 &amp;&amp; height &lt; vege_config.max_height) {\n          if (height &lt; vege_config.min_height) {\n            below_count++;\n          } else {\n            in_count++;\n          }\n        }\n      }\n      blocked_proportion[{j, i}] =\n          (in_count + below_count) &gt; 0\n              ? std::make_optional&lt;float&gt;((double)in_count / (in_count + below_count))\n              : std::nullopt;\n    }\n  }\n  return blocked_proportion;\n}\n\ninline GeoGrid&lt;float&gt; low_pass(const GeoGrid&lt;float&gt;&amp; grid, int delta = 8) {\n  TimeFunction timer(\"Low pass filter\");\n  GeoGrid&lt;float&gt; low_pass(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                          GeoProjection(grid.projection()));\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      float sum = 0;\n      float weight_sum = 0;\n      for (int x = -delta; x &lt;= delta; x++) {\n        for (int y = -delta; y &lt;= delta; y++) {\n          if (y + (int)i &gt;= 0 &amp;&amp; i + y &lt; grid.height() &amp;&amp; x + (int)j &gt;= 0 &amp;&amp;\n              (unsigned int)j + x &lt; grid.width()) {\n            if (sqrt(x * x + y * y) &lt;= delta) {\n              float weight = 1 - (sqrt(x * x + y * y) / delta);\n              sum += grid[{j + x, i + y}] * weight;\n              weight_sum += weight;\n            }\n          }\n        }\n      }\n      low_pass[{j, i}] = sum / weight_sum;\n    }\n  }\n  return low_pass;\n}\n\ninline GeoGrid&lt;float&gt; low_pass(const GeoGrid&lt;std::optional&lt;float&gt;&gt;&amp; grid, int delta = 8) {\n  TimeFunction timer(\"Low pass filter\");\n  GeoGrid&lt;float&gt; low_pass(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                          GeoProjection(grid.projection()));\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      float sum = 0;\n      float weight_sum = 0;\n      for (int x = -delta; x &lt;= delta; x++) {\n        for (int y = -delta; y &lt;= delta; y++) {\n          if (y + (int)i &gt;= 0 &amp;&amp; i + y &lt; grid.height() &amp;&amp; x + (int)j &gt;= 0 &amp;&amp;\n              (unsigned int)j + x &lt; grid.width()) {\n            if (sqrt(x * x + y * y) &lt;= delta) {\n              float weight = 1 - (sqrt(x * x + y * y) / delta);\n              if (grid[{j + x, i + y}].has_value()) {\n                sum += *grid[{j + x, i + y}] * weight;\n                weight_sum += weight;\n              }\n            }\n          }\n        }\n      }\n      if (weight_sum == 0) {\n        low_pass[{j, i}] = 0;\n        continue;\n      }\n      low_pass[{j, i}] = sum / weight_sum;\n    }\n  }\n  return low_pass;\n}\n</code></pre>"},{"location":"blaze/dir_0525f968218f30056a0344f59b10bbbb/","title":"Dir /home/runner/work/Blaze/Blaze/src/methods","text":"<p>FileList &gt; methods</p>"},{"location":"blaze/dir_0525f968218f30056a0344f59b10bbbb/#directories","title":"Directories","text":"Type Name dir hill_shade dir water <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/</code></p>"},{"location":"blaze/dir_e03c0efc459c079af38b3a453937aed0/","title":"Dir /home/runner/work/Blaze/Blaze/src/methods/hill_shade","text":"<p>FileList &gt; hill_shade</p>"},{"location":"blaze/dir_e03c0efc459c079af38b3a453937aed0/#files","title":"Files","text":"Type Name file hill_shade.hpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/hill_shade/</code></p>"},{"location":"blaze/hill__shade_8hpp/","title":"File hill_shade.hpp","text":"<p>FileList &gt; hill_shade &gt; hill_shade.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;numbers&gt;</code></li> <li><code>#include \"grid/grid.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/hill__shade_8hpp/#public-functions","title":"Public Functions","text":"Type Name GeoGrid&lt; double &gt; hill_shade (const GeoGrid&lt; T &gt; &amp; grid, double azimuth=315, double altitude=45, bool multidirectional=true)  GeoGrid&lt; double &gt; slope (const GeoGrid&lt; T &gt; &amp; grid)"},{"location":"blaze/hill__shade_8hpp/#macros","title":"Macros","text":"Type Name define DEG2RAD (x) <code>((x) \\* std::numbers::pi / 180)</code> define SQ (x) <code>((x) \\* (x))</code>"},{"location":"blaze/hill__shade_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/hill__shade_8hpp/#function-hill_shade","title":"function hill_shade","text":"<pre><code>template&lt;typename T&gt;\nGeoGrid &lt; double &gt; hill_shade (\n    const  GeoGrid &lt; T &gt; &amp; grid,\n    double azimuth=315,\n    double altitude=45,\n    bool multidirectional=true\n) \n</code></pre>"},{"location":"blaze/hill__shade_8hpp/#function-slope","title":"function slope","text":"<pre><code>template&lt;typename T&gt;\nGeoGrid &lt; double &gt; slope (\n    const  GeoGrid &lt; T &gt; &amp; grid\n) \n</code></pre>"},{"location":"blaze/hill__shade_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"blaze/hill__shade_8hpp/#define-deg2rad","title":"define DEG2RAD","text":"<pre><code>#define DEG2RAD (\n    x\n) `((x) * std::numbers::pi / 180)`\n</code></pre>"},{"location":"blaze/hill__shade_8hpp/#define-sq","title":"define SQ","text":"<pre><code>#define SQ (\n    x\n) `((x) * (x))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/hill_shade/hill_shade.hpp</code></p>"},{"location":"blaze/hill__shade_8hpp_source/","title":"File hill_shade.hpp","text":"<p>File List &gt; hill_shade &gt; hill_shade.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cmath&gt;\n#include &lt;numbers&gt;\n\n#include \"grid/grid.hpp\"\n#include \"utilities/timer.hpp\"\n\n#define DEG2RAD(x) ((x) * std::numbers::pi / 180)\n#define SQ(x) ((x) * (x))\n\ntemplate &lt;typename T&gt;\nGeoGrid&lt;double&gt; hill_shade(const GeoGrid&lt;T&gt;&amp; grid, double azimuth = 315, double altitude = 45,\n                           bool multidirectional = true) {\n  TimeFunction timer(\"hill shade\");\n  GeoGrid&lt;double&gt; result(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                         GeoProjection(grid.projection()));\n  for (size_t i = 1; i &lt; grid.height() - 1; i++) {\n    for (size_t j = 1; j &lt; grid.width() - 1; j++) {\n      double dz_dy = (grid[{j + 1, i}] - grid[{j - 1, i}]) / (2 * grid.dx());\n      double dz_dx = (grid[{j, i + 1}] - grid[{j, i - 1}]) / (2 * grid.dy());\n      double slope = atan(sqrt(dz_dx * dz_dx + dz_dy * dz_dy));\n      double aspect = atan2(dz_dy, dz_dx);\n      double hill_shade_val = 0;\n      if (!multidirectional) {\n        hill_shade_val = (cos(DEG2RAD(altitude)) * cos(slope) +\n                          sin(DEG2RAD(altitude)) * sin(slope) * cos(DEG2RAD(azimuth) - aspect));\n      } else {\n        // Multidirectional hillshade https://pubs.usgs.gov/of/1992/of92-422/of92-422.pdf\n        for (double az : std::array&lt;double, 4&gt;{\n                 {azimuth - 67.5, azimuth - 22.5, azimuth + 22.5, azimuth + 67.5}}) {\n          hill_shade_val += SQ(sin(aspect - DEG2RAD(az))) *\n                            (cos(DEG2RAD(altitude)) * cos(slope) +\n                             sin(DEG2RAD(altitude)) * sin(slope) * cos(DEG2RAD(az) - aspect));\n        }\n      }\n      result[{j, i}] = hill_shade_val;\n    }\n  }\n  return result;\n}\n\ntemplate &lt;typename T&gt;\nGeoGrid&lt;double&gt; slope(const GeoGrid&lt;T&gt;&amp; grid) {\n  TimeFunction timer(\"slope calculation\");\n  GeoGrid&lt;double&gt; result(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                         GeoProjection(grid.projection()));\n  for (size_t i = 1; i &lt; grid.height() - 1; i++) {\n    for (size_t j = 1; j &lt; grid.width() - 1; j++) {\n      double dz_dy = (grid[{j + 1, i}] - grid[{j - 1, i}]) / (2 * grid.dx());\n      double dz_dx = (grid[{j, i + 1}] - grid[{j, i - 1}]) / (2 * grid.dy());\n      result[{j, i}] = -atan(sqrt(dz_dx * dz_dx + dz_dy * dz_dy));\n    }\n  }\n  return result;\n}\n</code></pre>"},{"location":"blaze/dir_9906ac72c69ac5c4da1443f27a433c13/","title":"Dir /home/runner/work/Blaze/Blaze/src/methods/water","text":"<p>FileList &gt; methods &gt; water</p>"},{"location":"blaze/dir_9906ac72c69ac5c4da1443f27a433c13/#files","title":"Files","text":"Type Name file water.cpp file water.hpp"},{"location":"blaze/dir_9906ac72c69ac5c4da1443f27a433c13/#directories","title":"Directories","text":"Type Name dir tests <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/water/</code></p>"},{"location":"blaze/dir_bea8c7e26f40f75291ccc2650200ba17/","title":"Dir /home/runner/work/Blaze/Blaze/src/methods/water/tests","text":"<p>FileList &gt; methods &gt; water &gt; tests</p>"},{"location":"blaze/dir_bea8c7e26f40f75291ccc2650200ba17/#files","title":"Files","text":"Type Name file test_water.cpp <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/water/tests/</code></p>"},{"location":"blaze/test__water_8cpp/","title":"File test_water.cpp","text":"<p>FileList &gt; methods &gt; water &gt; tests &gt; test_water.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;gtest/gtest.h&gt;</code></li> <li><code>#include &lt;iomanip&gt;</code></li> <li><code>#include \"lib/grid/grid.hpp\"</code></li> <li><code>#include \"methods/water/water.hpp\"</code></li> </ul>"},{"location":"blaze/test__water_8cpp/#classes","title":"Classes","text":"Type Name class TestGrid"},{"location":"blaze/test__water_8cpp/#public-functions","title":"Public Functions","text":"Type Name TEST (Water, FillHoles3x3)  TEST (Water, FillHoles5x5)  TEST (Water, FillHoles5x5_2)"},{"location":"blaze/test__water_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/test__water_8cpp/#function-test","title":"function TEST","text":"<pre><code>TEST (\n    Water,\n    FillHoles3x3\n) \n</code></pre>"},{"location":"blaze/test__water_8cpp/#function-test_1","title":"function TEST","text":"<pre><code>TEST (\n    Water,\n    FillHoles5x5\n) \n</code></pre>"},{"location":"blaze/test__water_8cpp/#function-test_2","title":"function TEST","text":"<pre><code>TEST (\n    Water,\n    FillHoles5x5_2\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/water/tests/test_water.cpp</code></p>"},{"location":"blaze/test__water_8cpp_source/","title":"File test_water.cpp","text":"<p>File List &gt; methods &gt; water &gt; tests &gt; test_water.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;gtest/gtest.h&gt;\n\n#include &lt;iomanip&gt;\n\n#include \"lib/grid/grid.hpp\"\n#include \"methods/water/water.hpp\"\n\nclass TestGrid : public GeoGrid&lt;double&gt; {\n public:\n  explicit TestGrid(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; data)\n      : GeoGrid&lt;double&gt;(data[0].size(), data.size(), GeoTransform(), GeoProjection()) {\n    for (size_t i = 0; i &lt; data.size(); i++) {\n      for (size_t j = 0; j &lt; data[0].size(); j++) {\n        (*this)[{j, i}] = data[i][j];\n      }\n    }\n  }\n};\n\nTEST(Water, FillHoles3x3) {\n  std::vector&lt;std::vector&lt;double&gt;&gt; data = {{0.5, 0.5, 0.5}, {0.5, 0.4, 0.5}, {0.5, 0.5, 0.5}};\n  TestGrid grid(data);\n\n  GeoGrid&lt;double&gt; filled = fill_depressions(grid);\n\n  ASSERT_GE((filled[{1, 1}]), 0.5);\n}\n\nTEST(Water, FillHoles5x5) {\n  std::vector&lt;std::vector&lt;double&gt;&gt; data = {{0.7, 0.6, 0.5, 0.6, 0.7},\n                                           {0.6, 0.45, 0.4, 0.45, 0.6},\n                                           {1, 0.4, 0.3, 0.4, 1},\n                                           {0.6, 0.45, 0.4, 0.45, 0.6},\n                                           {1, 1, 1, 1, 1}};\n  TestGrid grid(data);\n\n  GeoGrid&lt;double&gt; filled = fill_depressions(grid);\n\n  for (size_t i = 0; i &lt; filled.height(); i++) {\n    for (size_t j = 0; j &lt; filled.width(); j++) {\n      ASSERT_GE((filled[{j, i}]), 0.5);\n    }\n  }\n}\n\nTEST(Water, FillHoles5x5_2) {\n  std::vector&lt;std::vector&lt;double&gt;&gt; data = {{0.7, 0.6, 0.5, 0.6, 0.7},\n                                           {0.6, 0.6, 0.6, 0.6, 0.6},\n                                           {1, 0.6, 0.3, 0.6, 1},\n                                           {0.6, 0.6, 0.6, 0.6, 0.6},\n                                           {1, 1, 1, 1, 1}};\n  TestGrid grid(data);\n\n  GeoGrid&lt;double&gt; filled = fill_depressions(grid);\n\n  std::cout &lt;&lt; std::setprecision(10) &lt;&lt; filled &lt;&lt; std::endl;\n  for (size_t i = 0; i &lt; filled.height(); i++) {\n    for (size_t j = 0; j &lt; filled.width(); j++) {\n      ASSERT_GE((filled[{j, i}]), 0.5);\n    }\n  }\n}\n</code></pre>"},{"location":"blaze/water_8cpp/","title":"File water.cpp","text":"<p>FileList &gt; methods &gt; water &gt; water.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"water.hpp\"</code></li> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"grid/grid.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/water_8cpp/#classes","title":"Classes","text":"Type Name struct PriorityPoint"},{"location":"blaze/water_8cpp/#public-functions","title":"Public Functions","text":"Type Name GeoGrid&lt; double &gt; catchment_size (const GeoGrid&lt; double &gt; &amp; filled)  GeoGrid&lt; double &gt; fill_depressions (const GeoGrid&lt; double &gt; &amp; grid, const std::vector&lt; Coordinate2D&lt; size_t &gt; &gt; &amp; sinks)  std::optional&lt; Coordinate2D&lt; size_t &gt; &gt; flows_to (const GeoGrid&lt; double &gt; &amp; grid, const Coordinate2D&lt; size_t &gt; &amp; coord)  std::vector&lt; Coordinate2D&lt; size_t &gt; &gt; identify_sinks (const GeoGrid&lt; double &gt; &amp; grid, double depth, double min_area)  std::vector&lt; Coordinate2D&lt; double &gt; &gt; smoothify (const std::vector&lt; Coordinate2D&lt; double &gt; &gt; &amp; path)  std::vector&lt; Coordinate2D&lt; size_t &gt; &gt; stream_path (const GeoGrid&lt; bool &gt; &amp; stream, GeoGrid&lt; bool &gt; &amp; visited, const GeoGrid&lt; double &gt; &amp; heights, std::vector&lt; Coordinate2D&lt; size_t &gt; &gt; &amp;&amp; start, std::queue&lt; std::vector&lt; Coordinate2D&lt; size_t &gt; &gt; &gt; &amp; queue_of_starts)  std::vector&lt; Stream &gt; stream_paths (const GeoGrid&lt; double &gt; &amp; grid, const WaterConfigs &amp; config, ProgressTracker progress_tracker, bool already_filled)  GeoGrid&lt; bool &gt; streams (const GeoGrid&lt; double &gt; &amp; filled_ground, const GeoGrid&lt; double &gt; &amp; catchment, double minimum_catchment)"},{"location":"blaze/water_8cpp/#macros","title":"Macros","text":"Type Name define SQ (x) <code>((x) \\* (x))</code>"},{"location":"blaze/water_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/water_8cpp/#function-catchment_size","title":"function catchment_size","text":"<pre><code>GeoGrid &lt; double &gt; catchment_size (\n    const  GeoGrid &lt; double &gt; &amp; filled\n) \n</code></pre>"},{"location":"blaze/water_8cpp/#function-fill_depressions","title":"function fill_depressions","text":"<pre><code>GeoGrid &lt; double &gt; fill_depressions (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    const std::vector&lt; Coordinate2D &lt; size_t &gt; &gt; &amp; sinks\n) \n</code></pre>"},{"location":"blaze/water_8cpp/#function-flows_to","title":"function flows_to","text":"<pre><code>std::optional&lt; Coordinate2D &lt; size_t &gt; &gt; flows_to (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    const  Coordinate2D &lt; size_t &gt; &amp; coord\n) \n</code></pre>"},{"location":"blaze/water_8cpp/#function-identify_sinks","title":"function identify_sinks","text":"<pre><code>std::vector&lt; Coordinate2D &lt; size_t &gt; &gt; identify_sinks (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    double depth,\n    double min_area\n) \n</code></pre>"},{"location":"blaze/water_8cpp/#function-smoothify","title":"function smoothify","text":"<pre><code>std::vector&lt; Coordinate2D &lt; double &gt; &gt; smoothify (\n    const std::vector&lt; Coordinate2D &lt; double &gt; &gt; &amp; path\n) \n</code></pre>"},{"location":"blaze/water_8cpp/#function-stream_path","title":"function stream_path","text":"<pre><code>std::vector&lt; Coordinate2D &lt; size_t &gt; &gt; stream_path (\n    const  GeoGrid &lt; bool &gt; &amp; stream,\n    GeoGrid &lt; bool &gt; &amp; visited,\n    const  GeoGrid &lt; double &gt; &amp; heights,\n    std::vector&lt; Coordinate2D &lt; size_t &gt; &gt; &amp;&amp; start,\n    std::queue&lt; std::vector&lt; Coordinate2D &lt; size_t &gt; &gt; &gt; &amp; queue_of_starts\n) \n</code></pre>"},{"location":"blaze/water_8cpp/#function-stream_paths","title":"function stream_paths","text":"<pre><code>std::vector&lt; Stream &gt; stream_paths (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    const  WaterConfigs &amp; config,\n    ProgressTracker progress_tracker,\n    bool already_filled\n) \n</code></pre>"},{"location":"blaze/water_8cpp/#function-streams","title":"function streams","text":"<pre><code>GeoGrid &lt; bool &gt; streams (\n    const  GeoGrid &lt; double &gt; &amp; filled_ground,\n    const  GeoGrid &lt; double &gt; &amp; catchment,\n    double minimum_catchment\n) \n</code></pre>"},{"location":"blaze/water_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"blaze/water_8cpp/#define-sq","title":"define SQ","text":"<pre><code>#define SQ (\n    x\n) `((x) * (x))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/water/water.cpp</code></p>"},{"location":"blaze/water_8cpp_source/","title":"File water.cpp","text":"<p>File List &gt; methods &gt; water &gt; water.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"water.hpp\"\n\n#include &lt;queue&gt;\n\n#include \"config_input/config_input.hpp\"\n#include \"grid/grid.hpp\"\n#include \"utilities/coordinate.hpp\"\n#include \"utilities/timer.hpp\"\n\nstruct PriorityPoint {\n  double priority;\n  double secondary_priority;\n  Coordinate2D&lt;size_t&gt; coord;\n\n  bool operator&lt;(const PriorityPoint&amp; other) const {\n    if (priority == other.priority) {\n      return secondary_priority &lt; other.secondary_priority;\n    }\n    return priority &lt; other.priority;\n  }\n};\n\n#define SQ(x) ((x) * (x))\n\nstd::optional&lt;Coordinate2D&lt;size_t&gt;&gt; flows_to(const GeoGrid&lt;double&gt;&amp; grid,\n                                             const Coordinate2D&lt;size_t&gt;&amp; coord) {\n  double slope = 0;\n  Coordinate2D&lt;size_t&gt; min_neighbour = coord;\n  for (Direction2D dir : ALL_DIRECTIONS) {\n    Coordinate2D&lt;size_t&gt; neighbour = coord + dir;\n    if (!grid.in_bounds(neighbour)) {\n      continue;\n    }\n    double neighbour_slope = (grid[coord] - grid[neighbour]) /\n                             std::sqrt(SQ(dir.dx() * grid.dx()) + SQ(dir.dy() * grid.dy()));\n    if (neighbour_slope &gt; slope) {\n      slope = neighbour_slope;\n      min_neighbour = neighbour;\n    }\n  }\n  return slope == 0 ? std::nullopt : std::make_optional(min_neighbour);\n}\n\nGeoGrid&lt;double&gt; fill_depressions(const GeoGrid&lt;double&gt;&amp; grid,\n                                 const std::vector&lt;Coordinate2D&lt;size_t&gt;&gt;&amp; sinks) {\n  TimeFunction timer(\"fill depressions\");\n  GeoGrid&lt;double&gt; result(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                         GeoProjection(grid.projection()));\n  result.copy_from(grid);\n\n  std::priority_queue&lt;PriorityPoint&gt; queue;\n  GeoGrid&lt;bool&gt; filled(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                       GeoProjection(grid.projection()));\n  filled.fill(false);\n\n  for (size_t i = 0; i &lt; grid.height() - 1; i++) {\n    for (Coordinate2D&lt;size_t&gt; coord :\n         {Coordinate2D&lt;size_t&gt;{0, i}, Coordinate2D&lt;size_t&gt;{grid.width() - 1, i + 1}}) {\n      queue.push({-grid[coord], 0, coord});\n      filled[coord] = true;\n    }\n  }\n\n  for (size_t j = 0; j &lt; grid.width() - 1; j++) {\n    for (Coordinate2D&lt;size_t&gt; coord :\n         {Coordinate2D&lt;size_t&gt;{j, 0}, Coordinate2D&lt;size_t&gt;{j + 1, grid.height() - 1}}) {\n      queue.push({-grid[coord], 0, coord});\n      filled[coord] = true;\n    }\n  }\n\n  for (const Coordinate2D&lt;size_t&gt;&amp; sink : sinks) {\n    queue.push({-grid[sink], 0, sink});\n    filled[sink] = true;\n  }\n\n  while (!queue.empty()) {\n    PriorityPoint current = queue.top();\n    Assert(std::isfinite(grid[current.coord]), \"Grid value is not finite\");\n    queue.pop();\n\n    for (Direction2D dir : ALL_DIRECTIONS) {\n      Coordinate2D&lt;size_t&gt; neighbour = current.coord + dir;\n      if (!filled.in_bounds(neighbour) || filled[neighbour]) {\n        continue;\n      }\n      double secondary_priority = 0;\n      if (result[neighbour] &lt;= result[current.coord]) {\n        result[neighbour] = result[current.coord] + 1e-7;\n        secondary_priority = current.secondary_priority - 1;\n      }\n      queue.push({-grid[neighbour], secondary_priority, neighbour});\n      filled[neighbour] = true;\n    }\n  }\n\n  return result;\n}\nstd::vector&lt;Coordinate2D&lt;size_t&gt;&gt; identify_sinks(const GeoGrid&lt;double&gt;&amp; grid, double depth,\n                                                 double min_area) {\n  TimeFunction timer(\"identify sinks\");\n  GeoGrid&lt;double&gt; filled = fill_depressions(grid);\n\n  std::vector&lt;Coordinate2D&lt;size_t&gt;&gt; sinks;\n  GeoGrid&lt;bool&gt; visited(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                        GeoProjection(grid.projection()));\n  visited.fill(false);\n\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      if (filled[{j, i}] &gt;= grid[{j, i}] + depth) {\n        double min_height = grid[{j, i}];\n        Coordinate2D&lt;size_t&gt; sink = {j, i};\n        double area = 0;\n        std::queue&lt;Coordinate2D&lt;size_t&gt;&gt; queue;\n        queue.push({j, i});\n        visited[{j, i}] = true;\n        while (!queue.empty()) {\n          Coordinate2D&lt;size_t&gt; current = queue.front();\n          queue.pop();\n          area += std::abs(grid.dx() * grid.dy());\n          if (grid[current] &lt; min_height) {\n            min_height = grid[current];\n            sink = current;\n          }\n          for (Direction2D dir : ALL_DIRECTIONS) {\n            Coordinate2D&lt;size_t&gt; neighbour = current + dir;\n            if (!grid.in_bounds(neighbour) || visited[neighbour]) {\n              continue;\n            }\n            if (filled[neighbour] &gt;= grid[neighbour] + depth) {\n              queue.push(neighbour);\n              visited[neighbour] = true;\n            }\n          }\n        }\n        if (area &gt; min_area) {\n          sinks.push_back(sink);\n        }\n      }\n    }\n  }\n\n  return sinks;\n}\nGeoGrid&lt;double&gt; catchment_size(const GeoGrid&lt;double&gt;&amp; filled) {\n  TimeFunction timer(\"catchment size\");\n\n  GeoGrid&lt;double&gt; result(filled.width(), filled.height(), GeoTransform(filled.transform()),\n                         GeoProjection(filled.projection()));\n\n  std::vector&lt;std::pair&lt;double, Coordinate2D&lt;size_t&gt;&gt;&gt; cells;\n  for (size_t i = 0; i &lt; filled.height(); i++) {\n    for (size_t j = 0; j &lt; filled.width(); j++) {\n      cells.emplace_back(filled[{j, i}], Coordinate2D&lt;size_t&gt;{j, i});\n      result[{j, i}] = 0;\n    }\n  }\n  std::sort(cells.begin(), cells.end(),\n            [](const auto&amp; a, const auto&amp; b) { return a.first &gt; b.first; });\n\n  for (const auto&amp; [_, coord] : cells) {\n    std::optional&lt;Coordinate2D&lt;size_t&gt;&gt; steepest_neighbour = flows_to(filled, coord);\n    if (steepest_neighbour)\n      result[*steepest_neighbour] += result[coord] + std::abs(filled.dx() * filled.dy());\n  }\n\n  return result;\n}\nGeoGrid&lt;bool&gt; streams(const GeoGrid&lt;double&gt;&amp; filled_ground, const GeoGrid&lt;double&gt;&amp; catchment,\n                      double minimum_catchment) {\n  TimeFunction timer(\"streams\");\n\n  GeoGrid&lt;bool&gt; result(filled_ground.width(), filled_ground.height(),\n                       GeoTransform(filled_ground.transform()),\n                       GeoProjection(filled_ground.projection()));\n\n  for (size_t i = 0; i &lt; filled_ground.height(); i++) {\n    for (size_t j = 0; j &lt; filled_ground.width(); j++) {\n      result[{j, i}] = catchment[{j, i}] &gt; 1000000 * minimum_catchment;\n    }\n  }\n\n  return result;\n}\nstd::vector&lt;Coordinate2D&lt;size_t&gt;&gt; stream_path(\n    const GeoGrid&lt;bool&gt;&amp; stream, GeoGrid&lt;bool&gt;&amp; visited, const GeoGrid&lt;double&gt;&amp; heights,\n    std::vector&lt;Coordinate2D&lt;size_t&gt;&gt;&amp;&amp; start,\n    std::queue&lt;std::vector&lt;Coordinate2D&lt;size_t&gt;&gt;&gt;&amp; queue_of_starts) {\n  for (const Coordinate2D&lt;size_t&gt;&amp; coord : start) visited[coord] = true;\n\n  while (true) {\n    Coordinate2D&lt;size_t&gt; last_point = start.back();\n    std::vector&lt;Coordinate2D&lt;size_t&gt;&gt; unvisited_neighbours;\n    for (Direction2D dir : ALL_DIRECTIONS) {\n      Coordinate2D&lt;size_t&gt; neighbour = last_point + dir;\n      if (stream.in_bounds(neighbour) &amp;&amp; stream[neighbour] &amp;&amp; !visited[neighbour]) {\n        std::optional&lt;Coordinate2D&lt;size_t&gt;&gt; flow = flows_to(heights, neighbour);\n        if (flow &amp;&amp; flow.value() == last_point) {\n          unvisited_neighbours.push_back(neighbour);\n        }\n      }\n    }\n    if (unvisited_neighbours.size() == 0) {\n      break;\n    } else if (unvisited_neighbours.size() == 1) {\n      start.push_back(unvisited_neighbours.back());\n      visited[unvisited_neighbours.back()] = true;\n    } else {\n      for (const Coordinate2D&lt;size_t&gt;&amp; neighbour : unvisited_neighbours) {\n        queue_of_starts.push({last_point, neighbour});\n      }\n      break;\n    }\n  }\n  return start;\n}\nstd::vector&lt;Coordinate2D&lt;double&gt;&gt; smoothify(const std::vector&lt;Coordinate2D&lt;double&gt;&gt;&amp; path) {\n  std::vector&lt;Coordinate2D&lt;double&gt;&gt; result;\n  for (size_t i = 0; i &lt; path.size(); i++) {\n    if (i == 0 || i == path.size() - 1) {\n      result.push_back(path[i]);\n    } else {\n      Coordinate2D&lt;double&gt; sum = path[i - 1] + path[i] + path[i + 1];\n      result.push_back({sum.x() / 3, sum.y() / 3});\n    }\n  }\n  return result;\n}\nstd::vector&lt;Stream&gt; stream_paths(const GeoGrid&lt;double&gt;&amp; grid, const WaterConfigs&amp; config,\n                                 ProgressTracker progress_tracker, bool already_filled) {\n  TimeFunction timer(\"stream paths\", &amp;progress_tracker);\n\n  std::optional&lt;GeoGrid&lt;double&gt;&gt; local_filled;\n  if (!already_filled) {\n    std::vector&lt;Coordinate2D&lt;size_t&gt;&gt; sinks = identify_sinks(grid);\n    local_filled.emplace(fill_depressions(grid, sinks));\n  }\n  const GeoGrid&lt;double&gt;&amp; filled = local_filled ? *local_filled : grid;\n\n  GeoGrid&lt;double&gt; catchment = catchment_size(filled);\n  GeoGrid&lt;bool&gt; stream = streams(filled, catchment, config.minimum_catchment());\n\n  std::vector&lt;std::vector&lt;Coordinate2D&lt;size_t&gt;&gt;&gt; result;\n  GeoGrid&lt;bool&gt; visited(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                        GeoProjection(grid.projection()));\n  visited.fill(false);\n\n  std::vector&lt;std::pair&lt;double, Coordinate2D&lt;size_t&gt;&gt;&gt; stream_cells;\n  for (size_t i = 0; i &lt; grid.height(); i++) {\n    for (size_t j = 0; j &lt; grid.width(); j++) {\n      if (stream[{j, i}]) {\n        stream_cells.emplace_back(filled[{j, i}], Coordinate2D&lt;size_t&gt;{j, i});\n      }\n    }\n  }\n\n  std::sort(stream_cells.begin(), stream_cells.end(),\n            [](const auto&amp; a, const auto&amp; b) { return a.first &lt; b.first; });\n\n  std::queue&lt;std::vector&lt;Coordinate2D&lt;size_t&gt;&gt;&gt; starting_points;\n\n  for (size_t i = 0; i &lt; stream_cells.size(); i++) {\n    while (!starting_points.empty()) {\n      if (visited[starting_points.front().back()]) {\n        starting_points.pop();\n        continue;\n      }\n      std::vector&lt;Coordinate2D&lt;size_t&gt;&gt; cur_stream =\n          stream_path(stream, visited, filled, std::move(starting_points.front()), starting_points);\n      if (cur_stream.size() &gt; 1) result.push_back(cur_stream);\n      starting_points.pop();\n    }\n    if (!visited[stream_cells[i].second]) {\n      starting_points.push({stream_cells[i].second});\n    }\n  }\n\n  std::vector&lt;Stream&gt; projected_result;\n  for (const std::vector&lt;Coordinate2D&lt;size_t&gt;&gt;&amp; path : result) {\n    std::vector&lt;Coordinate2D&lt;double&gt;&gt; projected_path;\n    for (const Coordinate2D&lt;size_t&gt;&amp; coord : path) {\n      projected_path.push_back(\n          grid.transform().pixel_to_projection(Coordinate2D&lt;double&gt;(0.5, 0.5) + coord));\n    }\n    projected_result.emplace_back(Stream{smoothify(projected_path), catchment[path.back()]});\n  }\n\n  return projected_result;\n}\n</code></pre>"},{"location":"blaze/water_8hpp/","title":"File water.hpp","text":"<p>FileList &gt; methods &gt; water &gt; water.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"grid/forward_grid.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> </ul>"},{"location":"blaze/water_8hpp/#classes","title":"Classes","text":"Type Name struct Stream"},{"location":"blaze/water_8hpp/#public-functions","title":"Public Functions","text":"Type Name GeoGrid&lt; double &gt; fill_depressions (const GeoGrid&lt; double &gt; &amp; grid, const std::vector&lt; Coordinate2D&lt; size_t &gt; &gt; &amp; sinks={})  std::vector&lt; Coordinate2D&lt; size_t &gt; &gt; identify_sinks (const GeoGrid&lt; double &gt; &amp; grid, double depth=10, double min_area=5000)  std::vector&lt; Stream &gt; stream_paths (const GeoGrid&lt; double &gt; &amp; grid, const WaterConfigs &amp; config, ProgressTracker progress_tracker, bool already_filled=false)"},{"location":"blaze/water_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/water_8hpp/#function-fill_depressions","title":"function fill_depressions","text":"<pre><code>GeoGrid &lt; double &gt; fill_depressions (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    const std::vector&lt; Coordinate2D &lt; size_t &gt; &gt; &amp; sinks={}\n) \n</code></pre>"},{"location":"blaze/water_8hpp/#function-identify_sinks","title":"function identify_sinks","text":"<pre><code>std::vector&lt; Coordinate2D &lt; size_t &gt; &gt; identify_sinks (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    double depth=10,\n    double min_area=5000\n) \n</code></pre>"},{"location":"blaze/water_8hpp/#function-stream_paths","title":"function stream_paths","text":"<pre><code>std::vector&lt; Stream &gt; stream_paths (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    const  WaterConfigs &amp; config,\n    ProgressTracker progress_tracker,\n    bool already_filled=false\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/methods/water/water.hpp</code></p>"},{"location":"blaze/water_8hpp_source/","title":"File water.hpp","text":"<p>File List &gt; methods &gt; water &gt; water.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstddef&gt;\n#include &lt;vector&gt;\n\n#include \"grid/forward_grid.hpp\"\n#include \"utilities/coordinate.hpp\"\n\nstruct WaterConfigs;\nclass ProgressTracker;\n\nstruct Stream {\n  std::vector&lt;Coordinate2D&lt;double&gt;&gt; coords;\n  double catchment;\n};\n\nGeoGrid&lt;double&gt; fill_depressions(const GeoGrid&lt;double&gt;&amp; grid,\n                                 const std::vector&lt;Coordinate2D&lt;size_t&gt;&gt;&amp; sinks = {});\n\nstd::vector&lt;Coordinate2D&lt;size_t&gt;&gt; identify_sinks(const GeoGrid&lt;double&gt;&amp; grid, double depth = 10,\n                                                 double min_area = 5000);\n\nstd::vector&lt;Stream&gt; stream_paths(const GeoGrid&lt;double&gt;&amp; grid, const WaterConfigs&amp; config,\n                                 ProgressTracker progress_tracker, bool already_filled = false);\n</code></pre>"},{"location":"blaze/blaze_8cpp/","title":"File blaze.cpp","text":"<p>FileList &gt; src &gt; blaze.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"run.hpp\"</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> </ul>"},{"location":"blaze/blaze_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char * argv)"},{"location":"blaze/blaze_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/blaze_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/blaze.cpp</code></p>"},{"location":"blaze/blaze_8cpp_source/","title":"File blaze.cpp","text":"<p>File List &gt; src &gt; blaze.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;iostream&gt;\n\n#include \"config_input/config_input.hpp\"\n#include \"run.hpp\"\n#include \"utilities/progress_tracker.hpp\"\n\nint main([[maybe_unused]] int argc, char* argv[]) {\n  fs::path config_path = AssetRetriever::get_asset(\"default_config.json\");\n  if (argc &gt; 1) {\n    config_path = argv[1];\n  }\n  Config config = Config::FromFile(config_path);\n  std::cout &lt;&lt; config &lt;&lt; std::endl;\n\n  std::vector&lt;fs::path&gt; las_files;\n  if (argc &gt; 2) {\n    las_files.push_back(argv[2]);\n  } else if (config.las_files.size() == 0) {\n    std::cerr &lt;&lt; \"No LAS files specified in config.json\" &lt;&lt; std::endl;\n    if (argc != 3) {\n      std::cerr &lt;&lt; \"Usage: blaze &lt;config_file&gt; &lt;las_file&gt;\" &lt;&lt; std::endl;\n      exit(1);\n    }\n    las_files.push_back(argv[1]);\n  }\n\n  ProgressBar progress_bar;\n  run_with_config(config, las_files, ProgressTracker(&amp;progress_bar));\n}\n</code></pre>"},{"location":"blaze/precompiled__headers_8hpp/","title":"File precompiled_headers.hpp","text":"<p>FileList &gt; src &gt; precompiled_headers.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;QAction&gt;</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QButtonGroup&gt;</code></li> <li><code>#include &lt;QCheckBox&gt;</code></li> <li><code>#include &lt;QColor&gt;</code></li> <li><code>#include &lt;QComboBox&gt;</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QDrag&gt;</code></li> <li><code>#include &lt;QFileDialog&gt;</code></li> <li><code>#include &lt;QFrame&gt;</code></li> <li><code>#include &lt;QHBoxLayout&gt;</code></li> <li><code>#include &lt;QHeaderView&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QLineEdit&gt;</code></li> <li><code>#include &lt;QMap&gt;</code></li> <li><code>#include &lt;QMimeData&gt;</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QPointer&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> <li><code>#include &lt;QRadioButton&gt;</code></li> <li><code>#include &lt;QSpacerItem&gt;</code></li> <li><code>#include &lt;QStackedWidget&gt;</code></li> <li><code>#include &lt;QStringList&gt;</code></li> <li><code>#include &lt;QStyle&gt;</code></li> <li><code>#include &lt;QTabWidget&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;QToolButton&gt;</code></li> <li><code>#include &lt;QToolTip&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> <li><code>#include &lt;QValidator&gt;</code></li> <li><code>#include &lt;QVariant&gt;</code></li> <li><code>#include &lt;QVector&gt;</code></li> <li><code>#include &lt;QtCore/QVariant&gt;</code></li> <li><code>#include &lt;QtWidgets/QApplication&gt;</code></li> <li><code>#include &lt;QtWidgets/QTextEdit&gt;</code></li> <li><code>#include &lt;QtWidgets/QVBoxLayout&gt;</code></li> <li><code>#include &lt;QtWidgets/QWidget&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;bitset&gt;</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;cfloat&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;complex&gt;</code></li> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;cstdlib&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;initializer_list&gt;</code></li> <li><code>#include &lt;iterator&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;numeric&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;unordered_map&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/precompiled_headers.hpp</code></p>"},{"location":"blaze/precompiled__headers_8hpp_source/","title":"File precompiled_headers.hpp","text":"<p>File List &gt; src &gt; precompiled_headers.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n// From\n// https://developex.com/blog/how-to-make-your-c-qt-project-build-10x-faster-with-4-optimizations/\n#include &lt;QAction&gt;\n#include &lt;QApplication&gt;\n#include &lt;QButtonGroup&gt;\n#include &lt;QCheckBox&gt;\n#include &lt;QColor&gt;\n#include &lt;QComboBox&gt;\n#include &lt;QDir&gt;\n#include &lt;QDrag&gt;\n#include &lt;QFileDialog&gt;\n#include &lt;QFrame&gt;\n#include &lt;QHBoxLayout&gt;\n#include &lt;QHeaderView&gt;\n#include &lt;QLabel&gt;\n#include &lt;QLineEdit&gt;\n#include &lt;QMap&gt;\n#include &lt;QMimeData&gt;\n#include &lt;QMouseEvent&gt;\n#include &lt;QPointer&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QRadioButton&gt;\n#include &lt;QSpacerItem&gt;\n#include &lt;QStackedWidget&gt;\n#include &lt;QStringList&gt;\n#include &lt;QStyle&gt;\n#include &lt;QTabWidget&gt;\n#include &lt;QTimer&gt;\n#include &lt;QToolButton&gt;\n#include &lt;QToolTip&gt;\n#include &lt;QVBoxLayout&gt;\n#include &lt;QValidator&gt;\n#include &lt;QVariant&gt;\n#include &lt;QVector&gt;\n#include &lt;QtCore/QVariant&gt;\n#include &lt;QtWidgets/QApplication&gt;\n#include &lt;QtWidgets/QTextEdit&gt;\n#include &lt;QtWidgets/QVBoxLayout&gt;\n#include &lt;QtWidgets/QWidget&gt;\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;cfloat&gt;\n#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;condition_variable&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstdlib&gt;\n#include &lt;functional&gt;\n#include &lt;initializer_list&gt;\n#include &lt;iterator&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;numeric&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;type_traits&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n</code></pre>"},{"location":"blaze/process_8cpp/","title":"File process.cpp","text":"<p>FileList &gt; src &gt; process.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"process.hpp\"</code></li> <li><code>#include \"cliff/cliff.hpp\"</code></li> <li><code>#include \"contour/contour_gen.hpp\"</code></li> <li><code>#include \"dxf/dxf.hpp\"</code></li> <li><code>#include \"grid/grid_ops.hpp\"</code></li> <li><code>#include \"grid/img_grid.hpp\"</code></li> <li><code>#include \"isom/colors.hpp\"</code></li> <li><code>#include \"las/las_file.hpp\"</code></li> <li><code>#include \"las/las_point.hpp\"</code></li> <li><code>#include \"lib/grid/grid.hpp\"</code></li> <li><code>#include \"lib/vegetation/vegetation.hpp\"</code></li> <li><code>#include \"methods/hill_shade/hill_shade.hpp\"</code></li> <li><code>#include \"methods/water/water.hpp\"</code></li> <li><code>#include \"tif/tif.hpp\"</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> </ul>"},{"location":"blaze/process_8cpp/#public-types","title":"Public Types","text":"Type Name enum GroundMethod"},{"location":"blaze/process_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name constexpr bool OUT_LAS   = <code>[**false**](classCoordinate2D.md)</code>"},{"location":"blaze/process_8cpp/#public-functions","title":"Public Functions","text":"Type Name GeoGrid&lt; double &gt; adjust_ground_to_slope (const GeoGrid&lt; double &gt; &amp; grid, double original_resolution)  GeoGrid&lt; double &gt; get_pixel_heights (const GeoGrid&lt; std::optional&lt; LASPoint &gt; &gt; &amp; ground_points, GroundMethod method=GroundMethod::LOWEST_POINT)  void process_las_data (LASData &amp; las_file, const fs::path &amp; output_dir, const Config &amp; config, ProgressTracker progress_tracker)  void process_las_file (const fs::path &amp; las_filename, const Config &amp; config, ProgressTracker progress_tracker)  size_t round_up (double x)"},{"location":"blaze/process_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"blaze/process_8cpp/#enum-groundmethod","title":"enum GroundMethod","text":"<pre><code>enum GroundMethod {\n    LOWER_BOUND,\n    LOWEST_POINT,\n    INTERPOLATE\n};\n</code></pre>"},{"location":"blaze/process_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"blaze/process_8cpp/#variable-out_las","title":"variable OUT_LAS","text":"<pre><code>constexpr bool OUT_LAS;\n</code></pre>"},{"location":"blaze/process_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/process_8cpp/#function-adjust_ground_to_slope","title":"function adjust_ground_to_slope","text":"<pre><code>GeoGrid &lt; double &gt; adjust_ground_to_slope (\n    const  GeoGrid &lt; double &gt; &amp; grid,\n    double original_resolution\n) \n</code></pre>"},{"location":"blaze/process_8cpp/#function-get_pixel_heights","title":"function get_pixel_heights","text":"<pre><code>GeoGrid &lt; double &gt; get_pixel_heights (\n    const  GeoGrid &lt; std::optional&lt; LASPoint &gt; &gt; &amp; ground_points,\n    GroundMethod method=GroundMethod::LOWEST_POINT\n) \n</code></pre>"},{"location":"blaze/process_8cpp/#function-process_las_data","title":"function process_las_data","text":"<pre><code>void process_las_data (\n    LASData &amp; las_file,\n    const fs::path &amp; output_dir,\n    const  Config &amp; config,\n    ProgressTracker progress_tracker\n) \n</code></pre>"},{"location":"blaze/process_8cpp/#function-process_las_file","title":"function process_las_file","text":"<pre><code>void process_las_file (\n    const fs::path &amp; las_filename,\n    const  Config &amp; config,\n    ProgressTracker progress_tracker\n) \n</code></pre>"},{"location":"blaze/process_8cpp/#function-round_up","title":"function round_up","text":"<pre><code>size_t round_up (\n    double x\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/process.cpp</code></p>"},{"location":"blaze/process_8cpp_source/","title":"File process.cpp","text":"<p>File List &gt; src &gt; process.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"process.hpp\"\n\n#include \"cliff/cliff.hpp\"\n#include \"contour/contour_gen.hpp\"\n#include \"dxf/dxf.hpp\"\n#include \"grid/grid_ops.hpp\"\n#include \"grid/img_grid.hpp\"\n#include \"isom/colors.hpp\"\n#include \"las/las_file.hpp\"\n#include \"las/las_point.hpp\"\n#include \"lib/grid/grid.hpp\"\n#include \"lib/vegetation/vegetation.hpp\"\n#include \"methods/hill_shade/hill_shade.hpp\"\n#include \"methods/water/water.hpp\"\n#include \"tif/tif.hpp\"\n#include \"utilities/progress_tracker.hpp\"\n\nconstexpr bool OUT_LAS = false;\n\nsize_t round_up(double x) { return std::ceil(1e-6 + std::abs(x)); }\n\nenum class GroundMethod { LOWER_BOUND, LOWEST_POINT, INTERPOLATE };\n\nGeoGrid&lt;double&gt; get_pixel_heights(const GeoGrid&lt;std::optional&lt;LASPoint&gt;&gt;&amp; ground_points,\n                                  GroundMethod method = GroundMethod::LOWEST_POINT) {\n  GeoGrid&lt;double&gt; ground(ground_points.width(), ground_points.height(),\n                         GeoTransform(ground_points.transform()),\n                         GeoProjection(ground_points.projection()));\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; ground.height(); i++) {\n    for (size_t j = 0; j &lt; ground.width(); j++) {\n      if (ground_points[{j, i}]) {\n        if (method == GroundMethod::LOWEST_POINT) {\n          ground[{j, i}] = ground_points[{j, i}]-&gt;z();\n        } else {\n          Fail(\"Not implemented\");\n        }\n      } else {\n        ground[{j, i}] = std::numeric_limits&lt;double&gt;::max();\n      }\n    }\n  }\n  return ground;\n}\n\nGeoGrid&lt;double&gt; adjust_ground_to_slope(const GeoGrid&lt;double&gt;&amp; grid, double original_resolution) {\n  GeoGrid&lt;double&gt; result(grid.width(), grid.height(), GeoTransform(grid.transform()),\n                         GeoProjection(grid.projection()));\n\n  result.copy_from(grid);\n  for (size_t i = 1; i &lt; grid.height() - 1; i++) {\n    for (size_t j = 1; j &lt; grid.width() - 1; j++) {\n      double dz_dy = (grid[{j + 1, i}] - grid[{j - 1, i}]) / (2 * grid.dx());\n      double dz_dx = (grid[{j, i + 1}] - grid[{j, i - 1}]) / (2 * grid.dy());\n      result[{j, i}] =\n          grid[{j, i}] + 0.5 * (std::abs(dz_dx) + std::abs(dz_dy)) * original_resolution;\n    }\n  }\n  return result;\n}\n\nvoid process_las_file(const fs::path&amp; las_filename, const Config&amp; config,\n                      ProgressTracker progress_tracker) {\n  TimeFunction outer_timer(\"processing LAS file \" + las_filename.string(), &amp;progress_tracker);\n  fs::path output_dir = config.output_path() / las_filename.stem();\n  fs::create_directories(output_dir);\n\n  LASData las_file = LASData::with_border(las_filename, config.border_width,\n                                          progress_tracker.subtracker(0.0, 0.4));\n  process_las_data(las_file, output_dir, config, progress_tracker.subtracker(0.4, 1.0));\n}\n\nvoid process_las_data(LASData&amp; las_file, const fs::path&amp; output_dir, const Config&amp; config,\n                      ProgressTracker progress_tracker) {\n  double bin_resolution = config.grid.bin_resolution;\n  GeoGrid&lt;std::vector&lt;LASPoint&gt;&gt; binned_points(\n      round_up(las_file.width() / bin_resolution + config.grid.downsample_factor),\n      round_up(las_file.height() / bin_resolution + config.grid.downsample_factor),\n      GeoTransform(las_file.top_left().round_NW(bin_resolution * config.grid.downsample_factor),\n                   bin_resolution),\n      GeoProjection(las_file.projection()));\n\n  {\n    TimeFunction timer(\"binning points\", &amp;progress_tracker);\n    size_t n_out_of_bounds = 0;\n    for (const LASPoint&amp; las_point : las_file) {\n      if (!binned_points.extent()-&gt;contains(las_point.x(), las_point.y())) {\n        n_out_of_bounds++;\n        continue;\n      }\n      auto pixel_coord = binned_points.transform().projection_to_pixel(\n          Coordinate2D&lt;double&gt;(las_point.x(), las_point.y()));\n      if (pixel_coord.x() &gt;= binned_points.width() || pixel_coord.y() &gt;= binned_points.height()) {\n        n_out_of_bounds++;\n        continue;\n      }\n      binned_points[binned_points.transform().projection_to_pixel(las_point)].emplace_back(\n          las_point);\n    }\n    if (n_out_of_bounds &gt; 0) {\n      std::cerr &lt;&lt; \"Warning: \" &lt;&lt; n_out_of_bounds\n                &lt;&lt; \" points were out of bounds and were not included in the processing.\\n\";\n    }\n  }\n  progress_tracker.set_proportion(0.5);\n\n  GeoGrid&lt;std::optional&lt;LASPoint&gt;&gt; ground_points(binned_points.width(), binned_points.height(),\n                                                 GeoTransform(binned_points.transform()),\n                                                 GeoProjection(las_file.projection()));\n\n  GeoGrid&lt;std::optional&lt;std::byte&gt;&gt; buildings = GeoGrid&lt;std::optional&lt;std::byte&gt;&gt;(\n      ground_points.width(), ground_points.height(), GeoTransform(ground_points.transform()),\n      GeoProjection(ground_points.projection()));\n\n  GeoGrid&lt;RGBColor&gt; ground_intensity_img(ground_points.width(), ground_points.height(),\n                                         GeoTransform(ground_points.transform()),\n                                         GeoProjection(las_file.projection()));\n\n  GeoGrid&lt;std::optional&lt;std::byte&gt;&gt; water = GeoGrid&lt;std::optional&lt;std::byte&gt;&gt;(\n      ground_points.width(), ground_points.height(), GeoTransform(ground_points.transform()),\n      GeoProjection(ground_points.projection()));\n\n  {\n    bool only_classified_ground = true;\n    LASData ground_points_las =\n        LASData(*ground_points.extent(), GeoProjection(ground_points.projection()));\n    TimeFunction timer(\"min finding\", &amp;progress_tracker);\n#pragma omp parallel for\n    for (size_t i = 0; i &lt; binned_points.height(); i++) {\n      for (size_t j = 0; j &lt; binned_points.width(); j++) {\n        bool is_building = false;\n        bool is_water = false;\n        double min = std::numeric_limits&lt;unsigned int&gt;::max();\n        std::optional&lt;LASPoint&gt; min_point = std::nullopt;\n        for (const LASPoint&amp; las_point : binned_points[{j, i}]) {\n          if (las_point.z() &lt; min &amp;&amp; (las_point.classification() == LASClassification::Ground ||\n                                      !only_classified_ground)) {\n            min = las_point.z();\n            min_point = las_point;\n            uint8_t intensity = std::clamp(\n                (double)(las_point.intensity() - config.ground.min_ground_intensity) /\n                    (config.ground.max_ground_intensity - config.ground.min_ground_intensity) *\n                    255.0,\n                0.0, 255.0);\n            ground_intensity_img[{j, i}] = RGBColor(intensity, intensity, intensity);\n          }\n          if (las_point.classification() == LASClassification::Building) {\n            is_building = true;\n          } else if (las_point.classification() == LASClassification::Water) {\n            is_water = true;\n          }\n        }\n        ground_points[{j, i}] = min_point;\n        if (min_point) {\n#pragma omp critical\n          ground_points_las.insert(min_point.value());\n        }\n        buildings[{j, i}] = is_building ? std::optional&lt;std::byte&gt;{std::byte{0}} : std::nullopt;\n        water[{j, i}] = is_water ? std::optional&lt;std::byte&gt;{std::byte{0}} : std::nullopt;\n      }\n    }\n    if (OUT_LAS)\n      ground_points_las.write(output_dir / \"ground_points_mins.las\",\n                              progress_tracker.subtracker(0.59, 0.6));\n  }\n  progress_tracker.set_proportion(0.6);\n\n  GeoGrid&lt;double&gt; ground = get_pixel_heights(ground_points);\n\n  write_to_tif(ground_intensity_img.slice(las_file.export_bounds()),\n               output_dir / \"ground_intensity.tif\", progress_tracker.subtracker(0.62, 0.63));\n\n  ground = remove_outliers(ground, progress_tracker.subtracker(0.63, 0.64),\n                           config.ground.outlier_removal_height_diff);\n  ground = interpolate_holes(ground, progress_tracker.subtracker(0.64, 0.65));\n\n  write_to_tif(ground.slice(las_file.export_bounds()), output_dir / \"ground.tif\",\n               progress_tracker.subtracker(0.65, 0.66));\n  write_to_tif(buildings.slice(las_file.export_bounds()), output_dir / \"buildings.tif\",\n               progress_tracker.subtracker(0.66, 0.67));\n  write_to_tif(water.slice(las_file.export_bounds()), output_dir / \"water.tif\",\n               progress_tracker.subtracker(0.67, 0.68));\n\n  if (OUT_LAS)\n    LASData(ground).write(output_dir / \"ground.las\", progress_tracker.subtracker(0.68, 0.69));\n\n  std::unique_ptr&lt;GeoGrid&lt;double&gt;&gt; downsampled_ground = std::make_unique&lt;GeoGrid&lt;double&gt;&gt;(\n      downsample(ground, config.grid.downsample_factor, progress_tracker.subtracker(0.69, 0.7)));\n  GeoGrid&lt;double&gt; smooth_ground =\n      remove_outliers(*downsampled_ground, progress_tracker.subtracker(0.7, 0.71),\n                      config.ground.outlier_removal_height_diff * config.grid.downsample_factor);\n  if (OUT_LAS)\n    LASData(*downsampled_ground).write(output_dir / \"smooth_ground_no_outlier_removal.las\");\n  downsampled_ground.reset();\n\n  write_to_tif(smooth_ground.slice(las_file.export_bounds()), output_dir / \"smooth_ground.tif\",\n               progress_tracker.subtracker(0.72, 0.73));\n\n  if (OUT_LAS)\n    LASData(smooth_ground)\n        .write(output_dir.parent_path() / \"smooth_ground.las\",\n               progress_tracker.subtracker(0.73, 0.74));\n\n  {\n    GeoGrid&lt;double&gt; slope_grid = slope(smooth_ground);\n    write_to_image_tif(slope_grid.slice(las_file.export_bounds()), output_dir / \"slope.tif\",\n                       progress_tracker.subtracker(0.74, 0.75));\n  }\n\n  smooth_ground = adjust_ground_to_slope(smooth_ground, ground.dx());\n  if (OUT_LAS) LASData(smooth_ground).write(output_dir / \"smooth_ground.las\");\n\n  const std::vector&lt;Contour&gt; contours =\n      generate_contours(smooth_ground, config.contours, progress_tracker.subtracker(0.75, 0.76));\n\n  std::vector&lt;Stream&gt; stream_path =\n      stream_paths(smooth_ground, config.water, progress_tracker.subtracker(0.76, 0.77));\n\n  std::vector&lt;Coordinate2D&lt;size_t&gt;&gt; sinks = identify_sinks(smooth_ground);\n  GeoGrid&lt;double&gt; filled = fill_depressions(smooth_ground, sinks);\n  write_to_tif(filled.slice(las_file.export_bounds()), output_dir / \"filled_dem.tif\");\n\n  double contour_points_resolution = 20;\n  GeoGrid&lt;std::vector&lt;std::shared_ptr&lt;ContourPoint&gt;&gt;&gt; contour_points(\n      round_up(smooth_ground.width_m() / contour_points_resolution) + 1,\n      round_up(smooth_ground.height_m() / contour_points_resolution) + 1,\n      GeoTransform(smooth_ground.transform().pixel_to_projection({0, 0}),\n                   contour_points_resolution),\n      GeoProjection(las_file.projection()));\n\n  std::vector&lt;std::shared_ptr&lt;ContourPoint&gt;&gt; all_contour_points;\n\n  for (const Contour&amp; contour : contours) {\n    std::shared_ptr&lt;ContourPoint&gt; last_point = nullptr;\n    for (size_t i = 0; i &lt; contour.points().size(); i++) {\n      const Coordinate2D&lt;double&gt;&amp; point = contour.points().at(i);\n      std::shared_ptr&lt;ContourPoint&gt; contour_point =\n          std::make_shared&lt;ContourPoint&gt;(point.x(), point.y(), contour.height());\n      if (last_point) {\n        contour_point-&gt;set_previous(last_point);\n        last_point-&gt;set_next(contour_point);\n      }\n      contour_points[contour_points.transform().projection_to_pixel(point)].emplace_back(\n          contour_point);\n      all_contour_points.emplace_back(contour_point);\n      last_point = contour_point;\n    }\n  }\n\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; contour_points.height(); i++) {\n    for (size_t j = 0; j &lt; contour_points.width(); j++) {\n      std::vector&lt;std::shared_ptr&lt;ContourPoint&gt;&gt;&amp; points = contour_points[{j, i}];\n      for (std::shared_ptr&lt;ContourPoint&gt;&amp; point : points) {\n        point-&gt;find_up_down(contour_points);\n      }\n    }\n  }\n\n  const std::vector&lt;Contour&gt; trimmed_contours = trim_contours(contours, las_file.original_bounds());\n  write_to_dxf(contours, output_dir / \"contours.dxf\", config.contours);\n\n  write_to_dxf(trimmed_contours, output_dir / \"trimmed_contours.dxf\", config.contours);\n  // crt name must match dxf name\n  write_to_crt(output_dir / \"contours.crt\");\n\n  write_to_dxf(stream_path, output_dir / \"streams.dxf\", \"streams\");\n\n  // VEGE\n  std::map&lt;std::string, GeoGrid&lt;float&gt;&gt; vege_maps;\n  for (const VegeHeightConfig&amp; vege_config : config.vege.height_configs) {\n    GeoGrid&lt;std::optional&lt;float&gt;&gt; blocked_proportion =\n        get_blocked_proportion(binned_points, smooth_ground, vege_config);\n    fs::create_directories(output_dir / \"raw_vege\");\n    write_to_tif(blocked_proportion.slice(las_file.export_bounds()),\n                 output_dir / \"raw_vege\" / (vege_config.name + \".tif\"));\n    GeoGrid&lt;float&gt; smooth_blocked_proportion = low_pass(blocked_proportion, 5);\n    write_to_tif(smooth_blocked_proportion.slice(las_file.export_bounds()),\n                 output_dir / \"raw_vege\" / (\"smoothed_\" + vege_config.name + \".tif\"));\n    vege_maps.emplace(vege_config.name, std::move(smooth_blocked_proportion));\n  }\n\n  progress_tracker.set_proportion(0.78);\n\n  write_to_image_tif(hill_shade(smooth_ground).slice(las_file.export_bounds()),\n                     output_dir / \"hill_shade_multi.tif\");\n\n  GeoGrid&lt;CMYKColor&gt; vege_color(binned_points.width(), binned_points.height(),\n                                GeoTransform(binned_points.transform()),\n                                GeoProjection(binned_points.projection()));\n\n  GeoGrid&lt;RGBColor&gt; building_color(buildings.width(), buildings.height(),\n                                   GeoTransform(buildings.transform()),\n                                   GeoProjection(buildings.projection()));\n  GeoGrid&lt;RGBColor&gt; water_color(water.width(), water.height(), GeoTransform(water.transform()),\n                                GeoProjection(water.projection()));\n\n#pragma omp parallel for\n  for (size_t i = 0; i &lt; vege_color.height(); i++) {\n    for (size_t j = 0; j &lt; vege_color.width(); j++) {\n      vege_color[{j, i}] = to_cmyk(config.vege.background_color);\n      if (buildings[{j, i}]) building_color[{j, i}] = to_rgb(config.buildings.color);\n      if (water[{j, i}]) water_color[{j, i}] = to_rgb(CMYKColor(100, 0, 0, 0));\n    }\n  }\n  for (const VegeHeightConfig&amp; vege_config : config.vege.height_configs) {\n#pragma omp parallel for\n    for (size_t i = 0; i &lt; vege_maps.at(vege_config.name).height(); i++) {\n      for (size_t j = 0; j &lt; vege_maps.at(vege_config.name).width(); j++) {\n        std::optional&lt;ColorVariant&gt; color =\n            vege_config.pick_from_blocked_proportion(vege_maps.at(vege_config.name)[{j, i}]);\n        if (color) {\n          vege_color[{j, i}] = to_cmyk(color.value());\n        }\n      }\n    }\n  }\n  write_to_tif(vege_color.slice(las_file.export_bounds()), output_dir / \"vege_color.tif\");\n\n  constexpr double INCHES_PER_METER = 39.3701;\n  double render_pixel_resolution = config.render.scale / config.render.dpi / INCHES_PER_METER;\n  GeoImgGrid final_img(\n      round_up(ground.width() * ground.transform().dx() / render_pixel_resolution),\n      round_up(ground.height() * ground.transform().dy() / render_pixel_resolution),\n      GeoTransform(vege_color.transform().with_new_resolution(render_pixel_resolution)),\n      GeoProjection(vege_color.projection()));\n\n  {\n    TimeFunction timer(\"drawing vege\", &amp;progress_tracker);\n    final_img.draw(GeoImgGrid(vege_color));\n  }\n\n  progress_tracker.set_proportion(0.8);\n  {\n    TimeFunction timer(\"drawing stuff\", &amp;progress_tracker);\n    final_img.draw(GeoImgGrid(water_color));\n  }\n\n  {\n    TimeFunction timer(\"drawing contours\", &amp;progress_tracker);\n    for (const Contour&amp; contour : contours) {\n      if (config.contours.layer_name_from_height(contour.height()) == \"Contour\") continue;\n      const ContourConfig&amp; contour_config = config.contours.pick_from_height(contour.height());\n      RGBColor color = to_rgb(contour_config.color);\n      final_img.draw(contour, color, contour_config.width / 1000 * config.render.scale);\n    }\n  }\n\n  {\n    TimeFunction timer(\"drawing paths\", &amp;progress_tracker);\n    for (const Stream&amp; stream : stream_path) {\n      const WaterConfig&amp; water_config = config.water.config_from_catchment(stream.catchment);\n      final_img.draw(stream.coords, water_config.color,\n                     water_config.width / 1000 * config.render.scale);\n    }\n  }\n\n  {\n    TimeFunction timer(\"drawing stuff\", &amp;progress_tracker);\n    final_img.draw(GeoImgGrid(building_color));\n  }\n\n  final_img.save_to(output_dir / \"final_img.tif\", las_file.export_bounds());\n\n  progress_tracker.set_proportion(0.9);\n\n  for (const Contour&amp; contour : contours) {\n    if (config.contours.layer_name_from_height(contour.height()) != \"Contour\") continue;\n    const ContourConfig&amp; contour_config = config.contours.pick_from_height(contour.height());\n    RGBColor color = to_rgb(contour_config.color);\n    final_img.draw(contour, color, contour_config.width / 1000 * config.render.scale);\n  }\n\n  {\n    TimeFunction timer(\"drawing paths\", &amp;progress_tracker);\n    for (const Stream&amp; stream : stream_path) {\n      const WaterConfig&amp; water_config = config.water.config_from_catchment(stream.catchment);\n      final_img.draw(stream.coords, water_config.color,\n                     water_config.width / 1000 * config.render.scale);\n    }\n  }\n\n  final_img.draw(GeoImgGrid(building_color));\n\n  for (const std::shared_ptr&lt;ContourPoint&gt;&amp; point : all_contour_points) {\n    if (point-&gt;slope() &gt; 0.8) {\n      final_img.draw_point(*point, RGBColor(0, 0, 0), 1.5);\n    }\n  }\n\n  final_img.save_to(output_dir / \"final_img_extra_contours.tif\", las_file.export_bounds());\n}\n</code></pre>"},{"location":"blaze/process_8hpp/","title":"File process.hpp","text":"<p>FileList &gt; src &gt; process.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"las/las_file.hpp\"</code></li> </ul>"},{"location":"blaze/process_8hpp/#public-functions","title":"Public Functions","text":"Type Name void process_las_data (LASData &amp; las_file, const fs::path &amp; output_dir, const Config &amp; config, ProgressTracker tracker)  void process_las_file (const fs::path &amp; las_file, const Config &amp; config, ProgressTracker tracker)"},{"location":"blaze/process_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/process_8hpp/#function-process_las_data","title":"function process_las_data","text":"<pre><code>void process_las_data (\n    LASData &amp; las_file,\n    const fs::path &amp; output_dir,\n    const  Config &amp; config,\n    ProgressTracker tracker\n) \n</code></pre>"},{"location":"blaze/process_8hpp/#function-process_las_file","title":"function process_las_file","text":"<pre><code>void process_las_file (\n    const fs::path &amp; las_file,\n    const  Config &amp; config,\n    ProgressTracker tracker\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/process.hpp</code></p>"},{"location":"blaze/process_8hpp_source/","title":"File process.hpp","text":"<p>File List &gt; src &gt; process.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"config_input/config_input.hpp\"\n#include \"las/las_file.hpp\"\n\nclass ProgressTracker;\n\nvoid process_las_file(const fs::path&amp; las_file, const Config&amp; config, ProgressTracker tracker);\nvoid process_las_data(LASData&amp; las_file, const fs::path&amp; output_dir, const Config&amp; config,\n                      ProgressTracker tracker);\n</code></pre>"},{"location":"blaze/run_8cpp/","title":"File run.cpp","text":"<p>FileList &gt; src &gt; run.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"run.hpp\"</code></li> <li><code>#include &lt;omp.h&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"config_input/config_input.hpp\"</code></li> <li><code>#include \"contour/contour.hpp\"</code></li> <li><code>#include \"contour/contour_gen.hpp\"</code></li> <li><code>#include \"dxf/dxf.hpp\"</code></li> <li><code>#include \"grid/grid.hpp\"</code></li> <li><code>#include \"io/gpkg.hpp\"</code></li> <li><code>#include \"las/las_file.hpp\"</code></li> <li><code>#include \"printing/to_string.hpp\"</code></li> <li><code>#include \"process.hpp\"</code></li> <li><code>#include \"tif/tif.hpp\"</code></li> <li><code>#include \"utilities/coordinate.hpp\"</code></li> <li><code>#include \"utilities/filesystem.hpp\"</code></li> <li><code>#include \"utilities/progress_tracker.hpp\"</code></li> <li><code>#include \"utilities/timer.hpp\"</code></li> </ul>"},{"location":"blaze/run_8cpp/#public-functions","title":"Public Functions","text":"Type Name void run_with_config (const Config &amp; config, const std::vector&lt; fs::path &gt; &amp; additional_las_files, ProgressTracker &amp;&amp; tracker)"},{"location":"blaze/run_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/run_8cpp/#function-run_with_config","title":"function run_with_config","text":"<pre><code>void run_with_config (\n    const  Config &amp; config,\n    const std::vector&lt; fs::path &gt; &amp; additional_las_files,\n    ProgressTracker &amp;&amp; tracker\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/run.cpp</code></p>"},{"location":"blaze/run_8cpp_source/","title":"File run.cpp","text":"<p>File List &gt; src &gt; run.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"run.hpp\"\n\n#include &lt;omp.h&gt;\n\n#include &lt;filesystem&gt;\n#include &lt;iostream&gt;\n\n#include \"config_input/config_input.hpp\"\n#include \"contour/contour.hpp\"\n#include \"contour/contour_gen.hpp\"\n#include \"dxf/dxf.hpp\"\n#include \"grid/grid.hpp\"\n#include \"io/gpkg.hpp\"\n#include \"las/las_file.hpp\"\n#include \"printing/to_string.hpp\"\n#include \"process.hpp\"\n#include \"tif/tif.hpp\"\n#include \"utilities/coordinate.hpp\"\n#include \"utilities/filesystem.hpp\"\n#include \"utilities/progress_tracker.hpp\"\n#include \"utilities/timer.hpp\"\n\nvoid run_with_config(const Config&amp; config, const std::vector&lt;fs::path&gt;&amp; additional_las_files,\n                     ProgressTracker&amp;&amp; tracker) {\n  std::cout &lt;&lt; \"Using \" &lt;&lt; omp_get_max_threads() &lt;&lt; \" threads for processing.\" &lt;&lt; std::endl;\n  std::vector&lt;fs::path&gt; las_files = additional_las_files;\n  for (const fs::path&amp; las_file : config.las_filepaths()) {\n    if (!fs::exists(las_file)) {\n      Fail(\"LAS file \" + las_file.string() + \" does not exist\");\n    } else if (fs::is_directory(las_file)) {\n      for (const fs::directory_entry&amp; entry : fs::directory_iterator(las_file)) {\n        if (entry.path().extension() == \".las\" || entry.path().extension() == \".laz\") {\n          las_files.push_back(entry.path());\n        } else {\n          std::cerr &lt;&lt; \"Ignoring file \" &lt;&lt; entry.path() &lt;&lt; \" with extension \"\n                    &lt;&lt; entry.path().extension() &lt;&lt; std::endl;\n        }\n      }\n    } else {\n      las_files.push_back(las_file);\n    }\n  }\n\n  std::vector&lt;double&gt; time_ratios;\n  double total_time = 0.01;\n  for (ProcessingStep step : config.processing_steps) {\n    switch (step) {\n      case ProcessingStep::Tiles:\n        time_ratios.push_back(0.9);\n        break;\n      case ProcessingStep::Combine:\n        time_ratios.push_back(0.1);\n        break;\n    }\n    total_time += time_ratios.back();\n  }\n\n  int idx = 0;\n  std::vector&lt;std::pair&lt;Extent3D, fs::path&gt;&gt; las_bounds;\n  for (const fs::path&amp; las_file : las_files) {\n    double multiplier = 0.01 / total_time;\n    if (!fs::exists(las_file)) {\n      throw std::runtime_error(\"LAS file \" + las_file.string() + \" does not exist\");\n    }\n    if (fs::is_directory(las_file)) {\n      throw std::runtime_error(\"LAS file \" + las_file.string() + \" is a directory\");\n    }\n    LASFile las(las_file, tracker.subtracker(multiplier * idx / las_files.size(),\n                                             multiplier * (idx + 1) / las_files.size()));\n    las_bounds.emplace_back(\n        std::pair&lt;Extent3D, fs::path&gt;{Extent3D(las.bounds()), fs::path(las_file)});\n    idx++;\n  }\n\n  double current_time = 0.01 / total_time;\n  idx = 0;\n  for (ProcessingStep step : config.processing_steps) {\n    TimeFunction timer(to_string(\"processing step \", step));\n    tracker.text_update(to_string(\"Processing step \", step));\n    ProgressTracker step_tracker =\n        tracker.subtracker(current_time, current_time + time_ratios[idx] / total_time);\n    current_time += time_ratios[idx++] / total_time;\n    switch (step) {\n      case ProcessingStep::Tiles:\n        for (size_t i = 0; i &lt; las_files.size(); i++) {\n          step_tracker.text_update(\"Processing tile \" + std::to_string(i + 1) + \" of \" +\n                                   std::to_string(las_files.size()) + \": \" +\n                                   las_files[i].filename().string());\n\n          {\n            ProgressTracker progress_tracker = step_tracker.subtracker(\n                (double)i / las_files.size(), (double)(i + 1) / las_files.size());\n\n            fs::path output_dir = config.output_path() / las_files[i].stem();\n            fs::create_directories(output_dir);\n\n            LASData las_file = LASData::with_border(las_files[i], config.border_width, las_bounds,\n                                                    progress_tracker.subtracker(0.0, 0.4));\n            process_las_data(las_file, output_dir, config, progress_tracker.subtracker(0.4, 1.0));\n          }\n\n          // process_las_file(las_files[i], config,\n          // step_tracker.subtracker((double)i / las_files.size(),\n          //(double)(i + 1) / las_files.size()));\n        }\n        break;\n      case ProcessingStep::Combine:\n        std::optional&lt;std::string&gt; projection;\n\n        // Combine TIFs\n        fs::create_directories(config.output_path() / \"combined\" / \"raw_vege\");\n        for (const std::string filename :\n             {\"final_img.tif\", \"final_img_extra_contours.tif\", \"ground_intensity.tif\",\n              \"buildings.tif\", \"slope.tif\", \"vege_color.tif\", \"hill_shade_multi.tif\",\n              \"filled_dem.tif\", \"raw_vege/canopy.tif\", \"raw_vege/green.tif\",\n              \"raw_vege/smoothed_green.tif\", \"raw_vege/smoothed_canopy.tif\"}) {\n          // for (const std::string filename :\n          //{\"filled_dem.tif\"}) {\n          TimeFunction combining_timer(\"Combining \" + filename);\n\n          std::vector&lt;Geo&lt;MultiBand&lt;FlexGrid&gt;&gt;&gt; grids;\n\n          Extent2D extent;\n          std::optional&lt;double&gt; dx, dy;\n          for (const fs::path&amp; las_file : las_files) {\n            fs::path output_dir = config.output_path() / las_file.stem();\n            fs::path img_path = output_dir / filename;\n            if (!fs::exists(img_path)) {\n              std::cerr &lt;&lt; \"Image \" &lt;&lt; img_path &lt;&lt; \" does not exist\" &lt;&lt; std::endl;\n              continue;\n            }\n            grids.emplace_back(read_tif(img_path));\n            if (!projection.has_value()) {\n              projection = grids.back().projection().to_string();\n            } else {\n              AssertEQ(projection, grids.back().projection().to_string());\n            }\n            extent.grow(*grids.back().extent());\n            if (!dx.has_value()) {\n              dx = grids.back().transform().dx();\n              dy = grids.back().transform().dy();\n            } else {\n              if (dx != grids.back().transform().dx() || dy != grids.back().transform().dy()) {\n                Fail(\"dx or dy mismatch\");\n              }\n            }\n          }\n\n          AssertGE(grids.size(), 1);\n          AssertGE(grids[0].size(), 1);\n\n          size_t width = (extent.maxx - extent.minx) / (*dx);\n          size_t height = (extent.maxy - extent.miny) / (std::abs(*dy));\n\n          size_t required_memory = width * height * grids[0].size() * grids[0][0].n_bytes();\n          std::cout &lt;&lt; \"Creating combined grid with dimensions \" &lt;&lt; width &lt;&lt; \"x\" &lt;&lt; height\n                    &lt;&lt; \" requiring \" &lt;&lt; (double)required_memory / 1e9 &lt;&lt; \" GB\" &lt;&lt; std::endl;\n          if (required_memory &gt; 16e9) {\n            std::cout &lt;&lt; \"Skipping \" &lt;&lt; filename &lt;&lt; \" due to memory requirements\" &lt;&lt; std::endl;\n            continue;\n          }\n          Geo&lt;MultiBand&lt;FlexGrid&gt;&gt; combined_grid(\n              GeoTransform(extent.minx, extent.maxy, *dx, *dy),\n              GeoProjection(grids[0].projection()), grids[0].size(),\n              (extent.maxx - extent.minx) / (*dx), (extent.maxy - extent.miny) / (std::abs(*dy)),\n              grids[0][0].n_bytes(), grids[0][0].data_type());\n\n          for (const auto&amp; grid : grids) {\n            combined_grid.fill_from(grid);\n          }\n\n          fs::create_directories((config.output_path() / \"combined\" / filename).parent_path());\n          write_to_tif(combined_grid, config.output_path() / \"combined\" / filename);\n\n          if (filename == \"filled_dem.tif\") {\n            GeoGrid&lt;double&gt; filled_dem(combined_grid.width(), combined_grid.height(),\n                                       GeoTransform(combined_grid.transform()),\n                                       GeoProjection(combined_grid.projection()));\n            filled_dem.fill_from(combined_grid[0]);\n\n#pragma omp parallel for\n            for (size_t i = 0; i &lt; filled_dem.height(); i++) {\n              for (size_t j = 0; j &lt; filled_dem.width(); j++) {\n                if (!std::isfinite(filled_dem[{j, i}])) {\n                  filled_dem[{j, i}] = 0;\n                }\n              }\n            }\n\n            write_to_tif(filled_dem, config.output_path() / \"combined\" / \"filled_filled_dem.tif\");\n\n            std::vector&lt;Stream&gt; stream_path =\n                stream_paths(filled_dem, config.water, step_tracker.subtracker(0.8, 0.9), false);\n            // write_to_dxf(stream_path, config.output_path() / \"combined\" / \"streams.dxf\",\n            // \"streams\");\n\n            {\n              GPKGWriter writer((config.output_path() / \"combined\" / \"streams.gpkg\").string(),\n                                projection.value());\n              for (const Stream&amp; stream : stream_path) {\n                writer.write_polyline(Polyline{.layer = \"streams\",\n                                               .name = std::to_string(stream.catchment),\n                                               .vertices = stream.coords},\n                                      {{\"catchment\", stream.catchment}});\n              }\n            }\n          }\n        }\n\n        // Combine contours\n        std::map&lt;double, std::vector&lt;Contour&gt;&gt; contours_by_height;\n        for (const fs::path&amp; las_file : las_files) {\n          fs::path output_dir = config.output_path() / las_file.stem();\n          fs::path dxf_path = output_dir / \"trimmed_contours.dxf\";\n          if (!fs::exists(dxf_path)) {\n            std::cerr &lt;&lt; \"DXF \" &lt;&lt; dxf_path &lt;&lt; \" does not exist\" &lt;&lt; std::endl;\n            continue;\n          }\n\n          std::vector&lt;Contour&gt; contours = read_dxf(dxf_path);\n          for (Contour&amp; contour : contours) {\n            contours_by_height[contour.height()].push_back(contour);\n          }\n        }\n        std::vector&lt;Contour&gt; joined_contours;\n        for (const auto&amp; [height, contours] : contours_by_height) {\n          std::vector&lt;Contour&gt; jc = join_contours(\n              contours, 5 * config.grid.bin_resolution * config.grid.downsample_factor);\n          for (Contour&amp; contour : jc) {\n            joined_contours.emplace_back(contour);\n          }\n        }\n        // write_to_dxf(joined_contours, config.output_path() / \"combined\" / \"contours.dxf\",\n        // config.contours);\n        {\n          GPKGWriter writer((config.output_path() / \"combined\" / \"contours.gpkg\").string(),\n                            projection.value());\n          for (const Contour&amp; contour : joined_contours) {\n            writer.write_polyline(contour.to_polyline(config.contours),\n                                  {{\"elevation\", contour.height()}});\n          }\n        }\n\n        write_to_crt(config.output_path() / \"combined\" / \"contours.crt\");\n\n        break;\n    }\n  }\n}\n</code></pre>"},{"location":"blaze/run_8hpp/","title":"File run.hpp","text":"<p>FileList &gt; src &gt; run.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"utilities/filesystem.hpp\"</code></li> </ul>"},{"location":"blaze/run_8hpp/#public-functions","title":"Public Functions","text":"Type Name void run_with_config (const Config &amp; config, const std::vector&lt; fs::path &gt; &amp; additional_las_files, ProgressTracker &amp;&amp; tracker)"},{"location":"blaze/run_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/run_8hpp/#function-run_with_config","title":"function run_with_config","text":"<pre><code>void run_with_config (\n    const  Config &amp; config,\n    const std::vector&lt; fs::path &gt; &amp; additional_las_files,\n    ProgressTracker &amp;&amp; tracker\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/run.hpp</code></p>"},{"location":"blaze/run_8hpp_source/","title":"File run.hpp","text":"<p>File List &gt; src &gt; run.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;vector&gt;\n\n#include \"utilities/filesystem.hpp\"\n\nstruct Config;\nclass ProgressTracker;\n\nvoid run_with_config(const Config&amp; config, const std::vector&lt;fs::path&gt;&amp; additional_las_files,\n                     ProgressTracker&amp;&amp; tracker);\n</code></pre>"},{"location":"blaze/unit__tests_8cpp/","title":"File unit_tests.cpp","text":"<p>FileList &gt; src &gt; unit_tests.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;gtest/gtest.h&gt;</code></li> </ul>"},{"location":"blaze/unit__tests_8cpp/#public-functions","title":"Public Functions","text":"Type Name int main (int argc, char * argv)"},{"location":"blaze/unit__tests_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"blaze/unit__tests_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/home/runner/work/Blaze/Blaze/src/unit_tests.cpp</code></p>"},{"location":"blaze/unit__tests_8cpp_source/","title":"File unit_tests.cpp","text":"<p>File List &gt; src &gt; unit_tests.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include &lt;gtest/gtest.h&gt;\n\nint main(int argc, char* argv[]) {\n  testing::InitGoogleTest(&amp;argc, argv);\n  return RUN_ALL_TESTS();\n}\n</code></pre>"},{"location":"blaze/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace Ui </li> <li>namespace cv </li> <li>namespace nlohmann </li> <li>namespace std </li> </ul>"},{"location":"blaze/classes/","title":"Class Index","text":""},{"location":"blaze/classes/#a","title":"a","text":"<ul> <li>adl_serializer&lt; BlockingThresholdColorPair &gt; (nlohmann)</li> <li>adl_serializer&lt; BuildingsConfig &gt; (nlohmann)</li> <li>adl_serializer&lt; CanopyConfig &gt; (nlohmann)</li> <li>adl_serializer&lt; CMYKColor &gt; (nlohmann)</li> <li>adl_serializer&lt; ColorVariant &gt; (nlohmann)</li> <li>adl_serializer&lt; ContourConfig &gt; (nlohmann)</li> <li>adl_serializer&lt; ContourConfigs &gt; (nlohmann)</li> <li>adl_serializer&lt; GridConfig &gt; (nlohmann)</li> <li>adl_serializer&lt; GroundConfig &gt; (nlohmann)</li> <li>adl_serializer&lt; RenderConfig &gt; (nlohmann)</li> <li>adl_serializer&lt; RGBColor &gt; (nlohmann)</li> <li>adl_serializer&lt; VegeConfig &gt; (nlohmann)</li> <li>adl_serializer&lt; VegeHeightConfig &gt; (nlohmann)</li> <li>adl_serializer&lt; WaterConfig &gt; (nlohmann)</li> <li>adl_serializer&lt; WaterConfigs &gt; (nlohmann)</li> <li>AssetRetriever</li> <li>AsyncLASData</li> <li>AsyncProgressTracker</li> </ul>"},{"location":"blaze/classes/#b","title":"b","text":"<ul> <li>BlazeBool</li> <li>BlockingThresholdColorPair</li> <li>BuildingsConfig</li> </ul>"},{"location":"blaze/classes/#c","title":"c","text":"<ul> <li>Camera</li> <li>CanopyConfig</li> <li>CMYKColor</li> <li>Color</li> <li>Config</li> <li>ConfigEditor</li> <li>Contour</li> <li>ContourConfig</li> <li>ContourConfigs</li> <li>ContourPoint</li> <li>Coordinate2D</li> <li>Coordinate3D</li> </ul>"},{"location":"blaze/classes/#d","title":"d","text":"<ul> <li>Direction2D</li> </ul>"},{"location":"blaze/classes/#e","title":"e","text":"<ul> <li>Extent2D</li> <li>Extent3D</li> </ul>"},{"location":"blaze/classes/#f","title":"f","text":"<ul> <li>FlexGrid</li> </ul>"},{"location":"blaze/classes/#g","title":"g","text":"<ul> <li>GDALDataset_w</li> <li>Geo</li> <li>GeoGridData</li> <li>GeoImgGrid</li> <li>GeoProjection</li> <li>GeoTransform</li> <li>GLWidget</li> <li>GPKGWriter</li> <li>Grid</li> <li>GridConfig</li> <li>GridData</li> <li>GridGraph</li> <li>GroundConfig</li> </ul>"},{"location":"blaze/classes/#i","title":"i","text":"<ul> <li>ImgGrid</li> <li>is_specialization</li> <li>is_specialization&lt; Ref&lt; Args... &gt;, Ref &gt;</li> <li>is_std_optional</li> <li>is_std_optional&lt; std::optional&lt; T &gt; &gt;</li> </ul>"},{"location":"blaze/classes/#l","title":"l","text":"<ul> <li>LASData</li> <li>LASFile</li> <li>LASLayer</li> <li>LASLayerRenderer</li> <li>LASPoint</li> <li>Layer</li> <li>LayerRenderer</li> <li>LineCoord2D</li> <li>LineCoord2DCrossing</li> <li>LocalDataRetriever</li> </ul>"},{"location":"blaze/classes/#m","title":"m","text":"<ul> <li>Main3DWindow</li> <li>MainWindow</li> <li>MultiBand</li> </ul>"},{"location":"blaze/classes/#p","title":"p","text":"<ul> <li>ParentFolderExistsValidator</li> <li>PointLayer</li> <li>Polyline</li> <li>PriorityPoint</li> <li>ProgressBar</li> <li>ProgressBox</li> <li>ProgressObserver</li> <li>ProgressTracker</li> <li>ProgressTrackerBar</li> </ul>"},{"location":"blaze/classes/#r","title":"r","text":"<ul> <li>RenderConfig</li> <li>RGBColor</li> </ul>"},{"location":"blaze/classes/#s","title":"s","text":"<ul> <li>Scalar_ (cv)</li> <li>Stream</li> </ul>"},{"location":"blaze/classes/#t","title":"t","text":"<ul> <li>TaskException</li> <li>TestGrid</li> <li>TimeFunction</li> <li>Timer</li> </ul>"},{"location":"blaze/classes/#v","title":"v","text":"<ul> <li>VegeConfig</li> <li>VegeHeightConfig</li> </ul>"},{"location":"blaze/classes/#w","title":"w","text":"<ul> <li>WaterConfig</li> <li>WaterConfigs</li> </ul>"},{"location":"blaze/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class AssetRetriever </li> <li>class LASFile <ul> <li>class LASData <ul> <li>class AsyncLASData </li> </ul> </li> </ul> </li> <li>class AsyncProgressTracker </li> <li>class Color <ul> <li>class CMYKColor </li> <li>class RGBColor </li> </ul> </li> <li>class Camera </li> <li>class Contour </li> <li>class Coordinate2D <ul> <li>class Coordinate3D </li> <li>class Coordinate3D </li> <li>class LineCoord2D <ul> <li>class LineCoord2DCrossing </li> </ul> </li> </ul> </li> <li>class Direction2D </li> <li>class GridData <ul> <li>class Grid </li> <li>class FlexGrid </li> <li>class Grid </li> <li>class ImgGrid <ul> <li>class GeoImgGrid </li> </ul> </li> </ul> </li> <li>class GDALDataset_w </li> <li>class GPKGWriter </li> <li>class GeoGridData <ul> <li>class Geo <ul> <li>class TestGrid </li> <li>class TestGrid </li> </ul> </li> <li>class GeoImgGrid </li> </ul> </li> <li>class GeoProjection </li> <li>class GeoTransform </li> <li>class GridGraph </li> <li>class LocalDataRetriever </li> <li>class MultiBand </li> <li>class Polyline </li> <li>class ProgressObserver <ul> <li>class ProgressBar </li> <li>class ProgressBox </li> <li>class ProgressTracker </li> <li>class ProgressTrackerBar </li> </ul> </li> <li>class Timer <ul> <li>class TimeFunction </li> </ul> </li> <li>class cv::Scalar_ </li> <li>struct BlazeBool </li> <li>struct BlockingThresholdColorPair </li> <li>struct BuildingsConfig </li> <li>struct CanopyConfig </li> <li>struct Config </li> <li>struct ContourConfig </li> <li>struct ContourConfigs </li> <li>struct Extent2D <ul> <li>struct Extent3D </li> </ul> </li> <li>struct GridConfig </li> <li>struct GroundConfig </li> <li>struct PriorityPoint </li> <li>struct RenderConfig </li> <li>struct Stream </li> <li>struct VegeConfig </li> <li>struct VegeHeightConfig </li> <li>struct WaterConfig </li> <li>struct WaterConfigs </li> <li>struct nlohmann::adl_serializer&lt; BlockingThresholdColorPair &gt; </li> <li>struct nlohmann::adl_serializer&lt; BuildingsConfig &gt; </li> <li>struct nlohmann::adl_serializer&lt; CMYKColor &gt; </li> <li>struct nlohmann::adl_serializer&lt; CanopyConfig &gt; </li> <li>struct nlohmann::adl_serializer&lt; ColorVariant &gt; </li> <li>struct nlohmann::adl_serializer&lt; ContourConfig &gt; </li> <li>struct nlohmann::adl_serializer&lt; ContourConfigs &gt; </li> <li>struct nlohmann::adl_serializer&lt; GridConfig &gt; </li> <li>struct nlohmann::adl_serializer&lt; GroundConfig &gt; </li> <li>struct nlohmann::adl_serializer&lt; RGBColor &gt; </li> <li>struct nlohmann::adl_serializer&lt; RenderConfig &gt; </li> <li>struct nlohmann::adl_serializer&lt; VegeConfig &gt; </li> <li>struct nlohmann::adl_serializer&lt; VegeHeightConfig &gt; </li> <li>struct nlohmann::adl_serializer&lt; WaterConfig &gt; </li> <li>struct nlohmann::adl_serializer&lt; WaterConfigs &gt; </li> <li>class QWidget <ul> <li>class ConfigEditor </li> </ul> </li> <li>class QOpenGLWidget <ul> <li>class GLWidget </li> </ul> </li> <li>class QOpenGLFunctions <ul> <li>class GLWidget </li> </ul> </li> <li>class GridT <ul> <li>class Geo <ul> <li>class TestGrid </li> <li>class TestGrid </li> </ul> </li> <li>class Geo <ul> <li>class TestGrid </li> <li>class TestGrid </li> </ul> </li> <li>class Geo <ul> <li>class TestGrid </li> <li>class TestGrid </li> </ul> </li> </ul> </li> <li>class QObject <ul> <li>class Layer <ul> <li>class PointLayer <ul> <li>class LASLayer </li> </ul> </li> </ul> </li> <li>class LayerRenderer <ul> <li>class LASLayerRenderer </li> </ul> </li> <li>class Layer <ul> <li>class PointLayer <ul> <li>class LASLayer </li> </ul> </li> </ul> </li> <li>class LayerRenderer <ul> <li>class LASLayerRenderer </li> </ul> </li> <li>class Layer <ul> <li>class PointLayer <ul> <li>class LASLayer </li> </ul> </li> </ul> </li> </ul> </li> <li>class QMainWindow <ul> <li>class Main3DWindow </li> <li>class MainWindow </li> </ul> </li> <li>class QValidator <ul> <li>class ParentFolderExistsValidator </li> </ul> </li> <li>class QDialog <ul> <li>class ProgressBox </li> </ul> </li> <li>class QProgressBar <ul> <li>class ProgressTrackerBar </li> </ul> </li> <li>class QException <ul> <li>class TaskException </li> </ul> </li> <li>class std::false_type <ul> <li>struct is_specialization </li> <li>struct is_std_optional </li> </ul> </li> <li>class std::true_type <ul> <li>struct is_specialization&lt; Ref&lt; Args... &gt;, Ref &gt; </li> <li>struct is_std_optional&lt; std::optional&lt; T &gt; &gt; </li> </ul> </li> </ul>"},{"location":"blaze/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"blaze/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"blaze/class_members/","title":"Class Members","text":""},{"location":"blaze/class_members/#a","title":"a","text":"<ul> <li>AsyncLASData (AsyncLASData)</li> <li>AsyncProgressTracker (AsyncProgressTracker)</li> <li>add_layer (GLWidget, GPKGWriter, Main3DWindow)</li> <li>add_progress_tracker (Main3DWindow)</li> </ul>"},{"location":"blaze/class_members/#b","title":"b","text":"<ul> <li>BlazeBool (BlazeBool)</li> <li>blocking_threshold (BlockingThresholdColorPair, CanopyConfig)</li> <li>bound_rotation (Camera)</li> <li>border_width (Config)</li> <li>buildings (Config)</li> <li>bin_resolution (GridConfig)</li> <li>begin (LASData)</li> <li>bounds (LASFile)</li> <li>background_color (VegeConfig)</li> </ul>"},{"location":"blaze/class_members/#c","title":"c","text":"<ul> <li>color (BlockingThresholdColorPair, BuildingsConfig, ContourConfig, WaterConfig)</li> <li>CMYKColor (CMYKColor)</li> <li>Camera (Camera)</li> <li>current_altitude_angle (Camera)</li> <li>Color (Color)</li> <li>Config (Config)</li> <li>contours (Config)</li> <li>ConfigEditor (ConfigEditor)</li> <li>Contour (Contour)</li> <li>ContourConfigs (ContourConfigs)</li> <li>configs (ContourConfigs, WaterConfigs)</li> <li>ContourPoint (ContourPoint)</li> <li>Coordinate2D (Coordinate2D)</li> <li>Coordinate3D (Coordinate3D)</li> <li>contains (Extent2D)</li> <li>center (Extent3D)</li> <li>copy_from (Grid)</li> <li>classification (LASPoint)</li> <li>create (LayerRenderer)</li> <li>crossing_dir (LineCoord2DCrossing)</li> <li>coord (PriorityPoint)</li> <li>child (ProgressObserver)</li> <li>catchment (Stream, WaterConfig)</li> <li>coords (Stream)</li> <li>clone (TaskException)</li> <li>colors (VegeHeightConfig)</li> <li>config_from_catchment (WaterConfigs)</li> </ul>"},{"location":"blaze/class_members/#d","title":"d","text":"<ul> <li>data_ready (AsyncLASData)</li> <li>direction (Camera)</li> <li>Default (Config)</li> <li>Dir (Direction2D)</li> <li>Direction2D (Direction2D)</li> <li>dx (Direction2D, GeoGridData, GeoTransform)</li> <li>dy (Direction2D, GeoGridData, GeoTransform)</li> <li>data (FlexGrid)</li> <li>data_type (FlexGrid)</li> <li>dataset (GDALDataset_w, GPKGWriter)</li> <li>draw (GeoImgGrid)</li> <li>draw_point (GeoImgGrid)</li> <li>downsample_factor (GridConfig)</li> <li>data_update_required (LayerRenderer)</li> <li>dir (LineCoord2D)</li> <li>dpi (RenderConfig)</li> <li>duration (Timer)</li> </ul>"},{"location":"blaze/class_members/#e","title":"e","text":"<ul> <li>Extent3D (Extent3D)</li> <li>extent (Geo, LASLayer, Layer)</li> <li>end (LASData, LineCoord2D)</li> <li>extract_borders (LASData)</li> <li>export_bounds (LASFile)</li> </ul>"},{"location":"blaze/class_members/#f","title":"f","text":"<ul> <li>FromRGB (CMYKColor)</li> <li>fly (Camera)</li> <li>FromFile (Config)</li> <li>FromGridGraph (Contour)</li> <li>from_polyline (Contour)</li> <li>find_up_down (ContourPoint)</li> <li>FlexGrid (FlexGrid)</li> <li>fill_from (FlexGrid, Geo, Grid, MultiBand)</li> <li>FromGeoImg (Geo)</li> <li>FromPoints (Geo)</li> <li>fill (Grid)</li> <li>from_las_reader (LASFile)</li> <li>flip (LineCoord2DCrossing)</li> <li>FromCMYK (RGBColor)</li> <li>from_json (nlohmann::adl_serializer&lt; BlockingThresholdColorPair &gt;, nlohmann::adl_serializer&lt; BuildingsConfig &gt;, nlohmann::adl_serializer&lt; CMYKColor &gt;, nlohmann::adl_serializer&lt; CanopyConfig &gt;, nlohmann::adl_serializer&lt; ColorVariant &gt;, nlohmann::adl_serializer&lt; ContourConfig &gt;, nlohmann::adl_serializer&lt; ContourConfigs &gt;, nlohmann::adl_serializer&lt; GridConfig &gt;, nlohmann::adl_serializer&lt; GroundConfig &gt;, nlohmann::adl_serializer&lt; RGBColor &gt;, nlohmann::adl_serializer&lt; RenderConfig &gt;, nlohmann::adl_serializer&lt; VegeConfig &gt;, nlohmann::adl_serializer&lt; VegeHeightConfig &gt;, nlohmann::adl_serializer&lt; WaterConfig &gt;, nlohmann::adl_serializer&lt; WaterConfigs &gt;)</li> </ul>"},{"location":"blaze/class_members/#g","title":"g","text":"<ul> <li>get_asset (AssetRetriever)</li> <li>getBlack (CMYKColor)</li> <li>getCyan (CMYKColor)</li> <li>getMagenta (CMYKColor)</li> <li>getYellow (CMYKColor)</li> <li>get_las_files (Config)</li> <li>grid (Config)</li> <li>ground (Config)</li> <li>get_config (ConfigEditor)</li> <li>grow (Extent2D, Extent3D)</li> <li>get (FlexGrid)</li> <li>GDALDataset_w (GDALDataset_w)</li> <li>GLWidget (GLWidget)</li> <li>GPKGWriter (GPKGWriter)</li> <li>Geo (Geo)</li> <li>GeoGridData (GeoGridData)</li> <li>GeoImgGrid (GeoImgGrid)</li> <li>GeoProjection (GeoProjection)</li> <li>GeoTransform (GeoTransform)</li> <li>geoTransform (GeoTransform)</li> <li>get_raw (GeoTransform)</li> <li>Grid (Grid)</li> <li>get_values (Grid)</li> <li>GridData (GridData)</li> <li>GridGraph (GridGraph)</li> <li>get_rgb_color (ImgGrid)</li> <li>get_local_data (LocalDataRetriever)</li> <li>gl_widget (Main3DWindow)</li> <li>getAlpha (RGBColor)</li> <li>getBlue (RGBColor)</li> <li>getGreen (RGBColor)</li> <li>getRed (RGBColor)</li> </ul>"},{"location":"blaze/class_members/#h","title":"h","text":"<ul> <li>height (Contour, ContourPoint, GridData, GridGraph, LASFile, MultiBand)</li> <li>height_m (Geo)</li> <li>horizontal (GridGraph)</li> <li>height_range (LASFile)</li> <li>height_configs (VegeConfig)</li> </ul>"},{"location":"blaze/class_members/#i","title":"i","text":"<ul> <li>is_valid (ConfigEditor)</li> <li>is_loop (Contour)</li> <li>interval (ContourConfig)</li> <li>intersection (Extent3D)</li> <li>intersects (Extent3D)</li> <li>initializeGL (GLWidget)</li> <li>in_bounds (GridData, GridGraph, MultiBand)</li> <li>ImgGrid (ImgGrid)</li> <li>insert (LASData)</li> <li>intensity_range (LASData)</li> <li>intensity (LASPoint)</li> </ul>"},{"location":"blaze/class_members/#k","title":"k","text":"<ul> <li>keyPressEvent (GLWidget)</li> </ul>"},{"location":"blaze/class_members/#l","title":"l","text":"<ul> <li>las_filepaths (Config)</li> <li>las_files (Config)</li> <li>load_color_details (ConfigEditor)</li> <li>load_contour_details (ConfigEditor)</li> <li>load_vege_details (ConfigEditor)</li> <li>load_water_details (ConfigEditor)</li> <li>layer_name_from_height (ContourConfigs)</li> <li>layers (GLWidget)</li> <li>layer_names (GPKGWriter)</li> <li>LASData (LASData)</li> <li>LASFile (LASFile)</li> <li>LASLayer (LASLayer)</li> <li>las_file (LASLayer)</li> <li>LASLayerRenderer (LASLayerRenderer)</li> <li>load_data (LASLayerRenderer)</li> <li>LASPoint (LASPoint)</li> <li>LineCoord2D (LineCoord2D)</li> <li>LineCoord2DCrossing (LineCoord2DCrossing)</li> <li>layer (Polyline)</li> </ul>"},{"location":"blaze/class_members/#m","title":"m","text":"<ul> <li>m_data_promise (AsyncLASData)</li> <li>m_mutex (AsyncLASData)</li> <li>m_thread (AsyncLASData)</li> <li>mutex (AsyncLASData)</li> <li>m_tracker (AsyncProgressTracker)</li> <li>m_data (CMYKColor, Coordinate2D, FlexGrid, Grid, RGBColor)</li> <li>m_direction (Camera)</li> <li>m_fov (Camera)</li> <li>m_height (Camera, Contour, ContourPoint, GridData)</li> <li>m_position (Camera)</li> <li>m_up (Camera, ContourPoint)</li> <li>m_width (Camera, GridData)</li> <li>m_world_offset (Camera)</li> <li>move (Camera)</li> <li>move_towards (Camera)</li> <li>max_height (CanopyConfig, VegeHeightConfig)</li> <li>min_height (CanopyConfig, VegeHeightConfig)</li> <li>m_config (ConfigEditor)</li> <li>m_updating_ui (ConfigEditor)</li> <li>m_is_loop (Contour)</li> <li>m_points (Contour, LASData, LASLayerRenderer)</li> <li>min_points (ContourConfig)</li> <li>min_interval (ContourConfigs)</li> <li>minimum_interval (ContourConfigs)</li> <li>m_down (ContourPoint)</li> <li>m_next (ContourPoint)</li> <li>m_prev (ContourPoint)</li> <li>m_slope (ContourPoint)</li> <li>magnitude (Coordinate2D)</li> <li>magnitude_sqd (Coordinate2D)</li> <li>m_z (Coordinate3D)</li> <li>m_dir (Direction2D, LineCoord2D)</li> <li>maxx (Extent2D)</li> <li>maxy (Extent2D)</li> <li>minx (Extent2D)</li> <li>miny (Extent2D)</li> <li>max_extent (Extent3D)</li> <li>maxz (Extent3D)</li> <li>minz (Extent3D)</li> <li>m_data_size (FlexGrid)</li> <li>m_data_type (FlexGrid)</li> <li>m_camera (GLWidget)</li> <li>m_last_mouse_pos (GLWidget)</li> <li>m_layers (GLWidget)</li> <li>m_point_radius_loc (GLWidget, LASLayerRenderer)</li> <li>m_proj_matrix_loc (GLWidget, LASLayerRenderer)</li> <li>m_projection (GLWidget, GeoGridData, GeoProjection, LASFile)</li> <li>m_renderers (GLWidget)</li> <li>m_vao (GLWidget, LASLayerRenderer)</li> <li>m_vbo (GLWidget, LASLayerRenderer)</li> <li>mouseMoveEvent (GLWidget)</li> <li>mousePressEvent (GLWidget)</li> <li>m_transform (GeoGridData)</li> <li>m_repeats (Grid)</li> <li>max_value (Grid)</li> <li>min_value (Grid)</li> <li>m_horizontal (GridGraph)</li> <li>m_vertical (GridGraph)</li> <li>max_ground_intensity (GroundConfig)</li> <li>min_ground_intensity (GroundConfig)</li> <li>m_img (ImgGrid)</li> <li>m_intensity_range (LASData)</li> <li>m_bounds (LASFile)</li> <li>m_filename (LASFile)</li> <li>m_original_bounds (LASFile)</li> <li>m_spatial_index (LASFile)</li> <li>m_las_file (LASLayer)</li> <li>m_data_mutex (LASLayerRenderer)</li> <li>m_data_updated (LASLayerRenderer)</li> <li>m_layer (LASLayerRenderer)</li> <li>m_shader (LASLayerRenderer)</li> <li>m_classification (LASPoint)</li> <li>m_intensity (LASPoint)</li> <li>m_name (Layer, TimeFunction)</li> <li>m_data_update_required (LayerRenderer)</li> <li>m_crossing_dir (LineCoord2DCrossing)</li> <li>Main3DWindow (Main3DWindow)</li> <li>MainWindow (MainWindow)</li> <li>MultiBand (MultiBand)</li> <li>m_grids (MultiBand)</li> <li>m_last_progress (ProgressBar)</li> <li>m_progress (ProgressBox)</li> <li>m_child (ProgressObserver)</li> <li>m_observer (ProgressTracker)</li> <li>m_proportion (ProgressTracker)</li> <li>m_subtracker_range (ProgressTracker)</li> <li>m_progress_tracker (ProgressTrackerBar, TimeFunction)</li> <li>m_tracker_obtained (ProgressTrackerBar)</li> <li>m_what (TaskException)</li> <li>m_start (Timer)</li> <li>minimum_catchment (WaterConfigs)</li> </ul>"},{"location":"blaze/class_members/#n","title":"n","text":"<ul> <li>n_bytes (FlexGrid)</li> <li>n_points (LASData)</li> <li>name (Layer, Polyline, VegeHeightConfig)</li> <li>next_points (LineCoord2DCrossing)</li> </ul>"},{"location":"blaze/class_members/#o","title":"o","text":"<ul> <li>operator bool (BlazeBool)</li> <li>operator= (BlazeBool, Color, Config, ProgressTracker)</li> <li>operator* (CMYKColor)</li> <li>operator+ (CMYKColor, Coordinate2D)</li> <li>operator[] (CMYKColor, ContourConfigs, FlexGrid, Grid, GridGraph, LASData, MultiBand, RGBColor)</li> <li>output_directory (Config)</li> <li>output_path (Config)</li> <li>open_output_directory (ConfigEditor)</li> <li>offset_to_center (Coordinate2D)</li> <li>operator Coordinate2D&lt; U &gt; (Coordinate2D)</li> <li>operator- (Coordinate2D, Extent3D)</li> <li>operator== (Coordinate2D)</li> <li>operator Dir (Direction2D)</li> <li>opposite (Direction2D)</li> <li>orthogonal_dirs (Direction2D)</li> <li>orthogonal_to (Direction2D)</li> <li>operator!= (Extent3D)</li> <li>operator-&gt; (GDALDataset_w)</li> <li>outlier_removal_height_diff (GroundConfig)</li> <li>original_bounds (LASFile)</li> <li>operator&lt; (PriorityPoint)</li> </ul>"},{"location":"blaze/class_members/#p","title":"p","text":"<ul> <li>pan (Camera)</li> <li>planar_direction (Camera)</li> <li>position (Camera)</li> <li>proj_matrix (Camera)</li> <li>projection_scale (Camera)</li> <li>processing_steps (Config)</li> <li>populate_color_combo (ConfigEditor)</li> <li>populate_color_list (ConfigEditor)</li> <li>populate_contour_list (ConfigEditor)</li> <li>populate_vege_list (ConfigEditor)</li> <li>populate_water_list (ConfigEditor)</li> <li>points (Contour)</li> <li>push_back (Contour, LASData)</li> <li>pick_from_height (ContourConfigs)</li> <li>paintGL (GLWidget)</li> <li>projection (GPKGWriter, GeoGridData, LASFile, LASLayer, Layer)</li> <li>pixel_to_projection (GeoTransform)</li> <li>projection_to_pixel (GeoTransform)</li> <li>priority (PriorityPoint)</li> <li>ProgressBox (ProgressBox)</li> <li>ProgressObserver (ProgressObserver)</li> <li>ProgressTracker (ProgressTracker)</li> <li>proportion (ProgressTracker)</li> <li>ProgressTrackerBar (ProgressTrackerBar)</li> <li>pick_from_blocked_proportion (VegeHeightConfig)</li> </ul>"},{"location":"blaze/class_members/#r","title":"r","text":"<ul> <li>reset_to_origin (Camera)</li> <li>rotate_around_center (Camera)</li> <li>rotate_view (Camera)</li> <li>relative_path_to_config (Config)</li> <li>render (Config, LASLayerRenderer, LayerRenderer)</li> <li>round (Coordinate2D)</li> <li>round_NW (Coordinate2D)</li> <li>rot_x (GeoTransform)</li> <li>rot_y (GeoTransform)</li> <li>read_points (LASData)</li> <li>read_from_dxf (Polyline)</li> <li>RGBColor (RGBColor)</li> <li>raise (TaskException)</li> </ul>"},{"location":"blaze/class_members/#s","title":"s","text":"<ul> <li>set_screen_size (Camera)</li> <li>set_output_directory (Config)</li> <li>set_ui_to_config (ConfigEditor)</li> <li>set_next (ContourPoint)</li> <li>set_previous (ContourPoint)</li> <li>slope (ContourPoint)</li> <li>sizeHint (GLWidget)</li> <li>slice (Geo)</li> <li>save_to (GeoImgGrid, ImgGrid)</li> <li>set_dx (GeoTransform)</li> <li>set_dy (GeoTransform)</li> <li>start (LineCoord2D)</li> <li>size (MultiBand)</li> <li>secondary_priority (PriorityPoint)</li> <li>start_task (ProgressBox)</li> <li>set_proportion (ProgressTracker)</li> <li>subtracker (ProgressTracker)</li> <li>scale (RenderConfig)</li> </ul>"},{"location":"blaze/class_members/#t","title":"t","text":"<ul> <li>tracker (AsyncProgressTracker, ProgressTrackerBar)</li> <li>toCMYK (CMYKColor, Color, RGBColor)</li> <li>toRGB (CMYKColor, Color, RGBColor)</li> <li>to_polyline (Contour)</li> <li>transform (GeoGridData)</li> <li>to_string (GeoProjection)</li> <li>T (Grid)</li> <li>top_left (LASFile)</li> <li>text_update (ProgressBar, ProgressBox, ProgressObserver, ProgressTracker, ProgressTrackerBar)</li> <li>toScalar (RGBColor)</li> <li>TaskException (TaskException)</li> <li>TestGrid (TestGrid)</li> <li>TimeFunction (TimeFunction)</li> <li>Timer (Timer)</li> <li>to_json (nlohmann::adl_serializer&lt; BlockingThresholdColorPair &gt;, nlohmann::adl_serializer&lt; BuildingsConfig &gt;, nlohmann::adl_serializer&lt; CMYKColor &gt;, nlohmann::adl_serializer&lt; CanopyConfig &gt;, nlohmann::adl_serializer&lt; ColorVariant &gt;, nlohmann::adl_serializer&lt; ContourConfig &gt;, nlohmann::adl_serializer&lt; ContourConfigs &gt;, nlohmann::adl_serializer&lt; GridConfig &gt;, nlohmann::adl_serializer&lt; GroundConfig &gt;, nlohmann::adl_serializer&lt; RGBColor &gt;, nlohmann::adl_serializer&lt; RenderConfig &gt;, nlohmann::adl_serializer&lt; VegeConfig &gt;, nlohmann::adl_serializer&lt; VegeHeightConfig &gt;, nlohmann::adl_serializer&lt; WaterConfig &gt;, nlohmann::adl_serializer&lt; WaterConfigs &gt;)</li> </ul>"},{"location":"blaze/class_members/#u","title":"u","text":"<ul> <li>unproject (Camera)</li> <li>up (Camera)</li> <li>ui (ConfigEditor, Main3DWindow, MainWindow, ProgressBox)</li> <li>update_progress (ProgressBar, ProgressBox, ProgressObserver, ProgressTracker, ProgressTrackerBar)</li> </ul>"},{"location":"blaze/class_members/#v","title":"v","text":"<ul> <li>value (BlazeBool)</li> <li>view_right (Camera)</li> <li>view_up (Camera)</li> <li>vege (Config)</li> <li>value_type (Grid)</li> <li>vertical (GridGraph)</li> <li>validate (ParentFolderExistsValidator)</li> <li>vertices (Polyline)</li> </ul>"},{"location":"blaze/class_members/#w","title":"w","text":"<ul> <li>wait_for_data (AsyncLASData)</li> <li>world_offset (Camera)</li> <li>water (Config)</li> <li>write_to_file (Config)</li> <li>width (ContourConfig, GridData, GridGraph, LASFile, MultiBand, WaterConfig)</li> <li>wheelEvent (GLWidget)</li> <li>write_polyline (GPKGWriter)</li> <li>width_m (Geo)</li> <li>with_new_resolution (GeoTransform)</li> <li>with_border (LASData)</li> <li>write (LASData)</li> <li>write_to_dxf (Polyline)</li> <li>what (TaskException)</li> </ul>"},{"location":"blaze/class_members/#x","title":"x","text":"<ul> <li>x (Coordinate2D, GeoTransform)</li> </ul>"},{"location":"blaze/class_members/#y","title":"y","text":"<ul> <li>y (Coordinate2D, GeoTransform)</li> </ul>"},{"location":"blaze/class_members/#z","title":"z","text":"<ul> <li>zoom_to_fit (Camera)</li> <li>z (Coordinate3D)</li> </ul>"},{"location":"blaze/class_members/#_1","title":"~","text":"<ul> <li>~AsyncLASData (AsyncLASData)</li> <li>~Color (Color)</li> <li>~ConfigEditor (ConfigEditor)</li> <li>~GDALDataset_w (GDALDataset_w)</li> <li>~GLWidget (GLWidget)</li> <li>~ImgGrid (ImgGrid)</li> <li>~LASLayerRenderer (LASLayerRenderer)</li> <li>~Layer (Layer)</li> <li>~LayerRenderer (LayerRenderer)</li> <li>~Main3DWindow (Main3DWindow)</li> <li>~MainWindow (MainWindow)</li> <li>~PointLayer (PointLayer)</li> <li>~ProgressObserver (ProgressObserver)</li> <li>~ProgressTracker (ProgressTracker)</li> <li>~TimeFunction (TimeFunction)</li> </ul>"},{"location":"blaze/class_members/#_","title":"_","text":"<ul> <li>_set_proportion (ProgressTracker)</li> </ul>"},{"location":"blaze/class_member_functions/","title":"Class Member Functions","text":""},{"location":"blaze/class_member_functions/#a","title":"a","text":"<ul> <li>AsyncLASData (AsyncLASData)</li> <li>AsyncProgressTracker (AsyncProgressTracker)</li> <li>add_layer (GLWidget, GPKGWriter, Main3DWindow)</li> <li>add_progress_tracker (Main3DWindow)</li> </ul>"},{"location":"blaze/class_member_functions/#b","title":"b","text":"<ul> <li>BlazeBool (BlazeBool)</li> <li>bound_rotation (Camera)</li> <li>begin (LASData)</li> <li>bounds (LASFile)</li> </ul>"},{"location":"blaze/class_member_functions/#c","title":"c","text":"<ul> <li>CMYKColor (CMYKColor)</li> <li>Camera (Camera)</li> <li>current_altitude_angle (Camera)</li> <li>Color (Color)</li> <li>Config (Config)</li> <li>ConfigEditor (ConfigEditor)</li> <li>Contour (Contour)</li> <li>ContourConfigs (ContourConfigs)</li> <li>ContourPoint (ContourPoint)</li> <li>Coordinate2D (Coordinate2D)</li> <li>Coordinate3D (Coordinate3D)</li> <li>contains (Extent2D)</li> <li>center (Extent3D)</li> <li>copy_from (Grid)</li> <li>classification (LASPoint)</li> <li>create (LayerRenderer)</li> <li>crossing_dir (LineCoord2DCrossing)</li> <li>child (ProgressObserver)</li> <li>clone (TaskException)</li> <li>config_from_catchment (WaterConfigs)</li> </ul>"},{"location":"blaze/class_member_functions/#d","title":"d","text":"<ul> <li>data_ready (AsyncLASData)</li> <li>direction (Camera)</li> <li>Default (Config)</li> <li>Direction2D (Direction2D)</li> <li>dx (Direction2D, GeoGridData, GeoTransform)</li> <li>dy (Direction2D, GeoGridData, GeoTransform)</li> <li>data (FlexGrid)</li> <li>data_type (FlexGrid)</li> <li>draw (GeoImgGrid)</li> <li>draw_point (GeoImgGrid)</li> <li>data_update_required (LayerRenderer)</li> <li>dir (LineCoord2D)</li> <li>duration (Timer)</li> </ul>"},{"location":"blaze/class_member_functions/#e","title":"e","text":"<ul> <li>Extent3D (Extent3D)</li> <li>extent (Geo, LASLayer, Layer)</li> <li>end (LASData, LineCoord2D)</li> <li>extract_borders (LASData)</li> <li>export_bounds (LASFile)</li> </ul>"},{"location":"blaze/class_member_functions/#f","title":"f","text":"<ul> <li>FromRGB (CMYKColor)</li> <li>fly (Camera)</li> <li>FromFile (Config)</li> <li>FromGridGraph (Contour)</li> <li>from_polyline (Contour)</li> <li>find_up_down (ContourPoint)</li> <li>FlexGrid (FlexGrid)</li> <li>fill_from (FlexGrid, Geo, Grid, MultiBand)</li> <li>FromGeoImg (Geo)</li> <li>FromPoints (Geo)</li> <li>fill (Grid)</li> <li>from_las_reader (LASFile)</li> <li>flip (LineCoord2DCrossing)</li> <li>FromCMYK (RGBColor)</li> <li>from_json (nlohmann::adl_serializer&lt; BlockingThresholdColorPair &gt;, nlohmann::adl_serializer&lt; BuildingsConfig &gt;, nlohmann::adl_serializer&lt; CMYKColor &gt;, nlohmann::adl_serializer&lt; CanopyConfig &gt;, nlohmann::adl_serializer&lt; ColorVariant &gt;, nlohmann::adl_serializer&lt; ContourConfig &gt;, nlohmann::adl_serializer&lt; ContourConfigs &gt;, nlohmann::adl_serializer&lt; GridConfig &gt;, nlohmann::adl_serializer&lt; GroundConfig &gt;, nlohmann::adl_serializer&lt; RGBColor &gt;, nlohmann::adl_serializer&lt; RenderConfig &gt;, nlohmann::adl_serializer&lt; VegeConfig &gt;, nlohmann::adl_serializer&lt; VegeHeightConfig &gt;, nlohmann::adl_serializer&lt; WaterConfig &gt;, nlohmann::adl_serializer&lt; WaterConfigs &gt;)</li> </ul>"},{"location":"blaze/class_member_functions/#g","title":"g","text":"<ul> <li>get_asset (AssetRetriever)</li> <li>getBlack (CMYKColor)</li> <li>getCyan (CMYKColor)</li> <li>getMagenta (CMYKColor)</li> <li>getYellow (CMYKColor)</li> <li>get_las_files (Config)</li> <li>get_config (ConfigEditor)</li> <li>grow (Extent2D, Extent3D)</li> <li>get (FlexGrid)</li> <li>GDALDataset_w (GDALDataset_w)</li> <li>GLWidget (GLWidget)</li> <li>GPKGWriter (GPKGWriter)</li> <li>Geo (Geo)</li> <li>GeoGridData (GeoGridData)</li> <li>GeoImgGrid (GeoImgGrid)</li> <li>GeoProjection (GeoProjection)</li> <li>GeoTransform (GeoTransform)</li> <li>get_raw (GeoTransform)</li> <li>Grid (Grid)</li> <li>get_values (Grid)</li> <li>GridData (GridData)</li> <li>GridGraph (GridGraph)</li> <li>get_rgb_color (ImgGrid)</li> <li>get_local_data (LocalDataRetriever)</li> <li>getAlpha (RGBColor)</li> <li>getBlue (RGBColor)</li> <li>getGreen (RGBColor)</li> <li>getRed (RGBColor)</li> </ul>"},{"location":"blaze/class_member_functions/#h","title":"h","text":"<ul> <li>height (Contour, ContourPoint, GridData, GridGraph, LASFile, MultiBand)</li> <li>height_m (Geo)</li> <li>horizontal (GridGraph)</li> <li>height_range (LASFile)</li> </ul>"},{"location":"blaze/class_member_functions/#i","title":"i","text":"<ul> <li>is_valid (ConfigEditor)</li> <li>is_loop (Contour)</li> <li>intersection (Extent3D)</li> <li>intersects (Extent3D)</li> <li>initializeGL (GLWidget)</li> <li>in_bounds (GridData, GridGraph, MultiBand)</li> <li>ImgGrid (ImgGrid)</li> <li>insert (LASData)</li> <li>intensity_range (LASData)</li> <li>intensity (LASPoint)</li> </ul>"},{"location":"blaze/class_member_functions/#k","title":"k","text":"<ul> <li>keyPressEvent (GLWidget)</li> </ul>"},{"location":"blaze/class_member_functions/#l","title":"l","text":"<ul> <li>las_filepaths (Config)</li> <li>load_color_details (ConfigEditor)</li> <li>load_contour_details (ConfigEditor)</li> <li>load_vege_details (ConfigEditor)</li> <li>load_water_details (ConfigEditor)</li> <li>layer_name_from_height (ContourConfigs)</li> <li>layers (GLWidget)</li> <li>LASData (LASData)</li> <li>LASFile (LASFile)</li> <li>LASLayer (LASLayer)</li> <li>las_file (LASLayer)</li> <li>LASLayerRenderer (LASLayerRenderer)</li> <li>load_data (LASLayerRenderer)</li> <li>LASPoint (LASPoint)</li> <li>LineCoord2D (LineCoord2D)</li> <li>LineCoord2DCrossing (LineCoord2DCrossing)</li> </ul>"},{"location":"blaze/class_member_functions/#m","title":"m","text":"<ul> <li>mutex (AsyncLASData)</li> <li>move (Camera)</li> <li>move_towards (Camera)</li> <li>minimum_interval (ContourConfigs)</li> <li>magnitude (Coordinate2D)</li> <li>magnitude_sqd (Coordinate2D)</li> <li>max_extent (Extent3D)</li> <li>mouseMoveEvent (GLWidget)</li> <li>mousePressEvent (GLWidget)</li> <li>max_value (Grid)</li> <li>min_value (Grid)</li> <li>Main3DWindow (Main3DWindow)</li> <li>MainWindow (MainWindow)</li> <li>MultiBand (MultiBand)</li> <li>minimum_catchment (WaterConfigs)</li> </ul>"},{"location":"blaze/class_member_functions/#n","title":"n","text":"<ul> <li>n_bytes (FlexGrid)</li> <li>n_points (LASData)</li> <li>name (Layer)</li> <li>next_points (LineCoord2DCrossing)</li> </ul>"},{"location":"blaze/class_member_functions/#o","title":"o","text":"<ul> <li>operator bool (BlazeBool)</li> <li>operator= (BlazeBool, Color, Config, ProgressTracker)</li> <li>operator* (CMYKColor)</li> <li>operator+ (CMYKColor, Coordinate2D)</li> <li>operator[] (CMYKColor, ContourConfigs, FlexGrid, Grid, GridGraph, LASData, MultiBand, RGBColor)</li> <li>output_path (Config)</li> <li>open_output_directory (ConfigEditor)</li> <li>offset_to_center (Coordinate2D)</li> <li>operator Coordinate2D&lt; U &gt; (Coordinate2D)</li> <li>operator- (Coordinate2D, Extent3D)</li> <li>operator== (Coordinate2D)</li> <li>operator Dir (Direction2D)</li> <li>opposite (Direction2D)</li> <li>orthogonal_dirs (Direction2D)</li> <li>orthogonal_to (Direction2D)</li> <li>operator!= (Extent3D)</li> <li>operator-&gt; (GDALDataset_w)</li> <li>original_bounds (LASFile)</li> <li>operator&lt; (PriorityPoint)</li> </ul>"},{"location":"blaze/class_member_functions/#p","title":"p","text":"<ul> <li>pan (Camera)</li> <li>planar_direction (Camera)</li> <li>position (Camera)</li> <li>proj_matrix (Camera)</li> <li>projection_scale (Camera)</li> <li>populate_color_combo (ConfigEditor)</li> <li>populate_color_list (ConfigEditor)</li> <li>populate_contour_list (ConfigEditor)</li> <li>populate_vege_list (ConfigEditor)</li> <li>populate_water_list (ConfigEditor)</li> <li>points (Contour)</li> <li>push_back (Contour, LASData)</li> <li>pick_from_height (ContourConfigs)</li> <li>paintGL (GLWidget)</li> <li>projection (GeoGridData, LASFile, LASLayer, Layer)</li> <li>pixel_to_projection (GeoTransform)</li> <li>projection_to_pixel (GeoTransform)</li> <li>ProgressBox (ProgressBox)</li> <li>ProgressObserver (ProgressObserver)</li> <li>ProgressTracker (ProgressTracker)</li> <li>proportion (ProgressTracker)</li> <li>ProgressTrackerBar (ProgressTrackerBar)</li> <li>pick_from_blocked_proportion (VegeHeightConfig)</li> </ul>"},{"location":"blaze/class_member_functions/#r","title":"r","text":"<ul> <li>reset_to_origin (Camera)</li> <li>rotate_around_center (Camera)</li> <li>rotate_view (Camera)</li> <li>round (Coordinate2D)</li> <li>round_NW (Coordinate2D)</li> <li>rot_x (GeoTransform)</li> <li>rot_y (GeoTransform)</li> <li>read_points (LASData)</li> <li>render (LASLayerRenderer, LayerRenderer)</li> <li>read_from_dxf (Polyline)</li> <li>RGBColor (RGBColor)</li> <li>raise (TaskException)</li> </ul>"},{"location":"blaze/class_member_functions/#s","title":"s","text":"<ul> <li>set_screen_size (Camera)</li> <li>set_output_directory (Config)</li> <li>set_ui_to_config (ConfigEditor)</li> <li>set_next (ContourPoint)</li> <li>set_previous (ContourPoint)</li> <li>slope (ContourPoint)</li> <li>sizeHint (GLWidget)</li> <li>slice (Geo)</li> <li>save_to (GeoImgGrid, ImgGrid)</li> <li>set_dx (GeoTransform)</li> <li>set_dy (GeoTransform)</li> <li>start (LineCoord2D)</li> <li>size (MultiBand)</li> <li>start_task (ProgressBox)</li> <li>set_proportion (ProgressTracker)</li> <li>subtracker (ProgressTracker)</li> </ul>"},{"location":"blaze/class_member_functions/#t","title":"t","text":"<ul> <li>tracker (AsyncProgressTracker, ProgressTrackerBar)</li> <li>toCMYK (CMYKColor, Color, RGBColor)</li> <li>toRGB (CMYKColor, Color, RGBColor)</li> <li>to_polyline (Contour)</li> <li>transform (GeoGridData)</li> <li>to_string (GeoProjection)</li> <li>top_left (LASFile)</li> <li>text_update (ProgressBar, ProgressBox, ProgressObserver, ProgressTracker, ProgressTrackerBar)</li> <li>toScalar (RGBColor)</li> <li>TaskException (TaskException)</li> <li>TestGrid (TestGrid)</li> <li>TimeFunction (TimeFunction)</li> <li>Timer (Timer)</li> <li>to_json (nlohmann::adl_serializer&lt; BlockingThresholdColorPair &gt;, nlohmann::adl_serializer&lt; BuildingsConfig &gt;, nlohmann::adl_serializer&lt; CMYKColor &gt;, nlohmann::adl_serializer&lt; CanopyConfig &gt;, nlohmann::adl_serializer&lt; ColorVariant &gt;, nlohmann::adl_serializer&lt; ContourConfig &gt;, nlohmann::adl_serializer&lt; ContourConfigs &gt;, nlohmann::adl_serializer&lt; GridConfig &gt;, nlohmann::adl_serializer&lt; GroundConfig &gt;, nlohmann::adl_serializer&lt; RGBColor &gt;, nlohmann::adl_serializer&lt; RenderConfig &gt;, nlohmann::adl_serializer&lt; VegeConfig &gt;, nlohmann::adl_serializer&lt; VegeHeightConfig &gt;, nlohmann::adl_serializer&lt; WaterConfig &gt;, nlohmann::adl_serializer&lt; WaterConfigs &gt;)</li> </ul>"},{"location":"blaze/class_member_functions/#u","title":"u","text":"<ul> <li>unproject (Camera)</li> <li>up (Camera)</li> <li>update_progress (ProgressBar, ProgressBox, ProgressObserver, ProgressTracker, ProgressTrackerBar)</li> </ul>"},{"location":"blaze/class_member_functions/#v","title":"v","text":"<ul> <li>view_right (Camera)</li> <li>view_up (Camera)</li> <li>vertical (GridGraph)</li> <li>validate (ParentFolderExistsValidator)</li> </ul>"},{"location":"blaze/class_member_functions/#w","title":"w","text":"<ul> <li>wait_for_data (AsyncLASData)</li> <li>world_offset (Camera)</li> <li>write_to_file (Config)</li> <li>wheelEvent (GLWidget)</li> <li>write_polyline (GPKGWriter)</li> <li>width_m (Geo)</li> <li>with_new_resolution (GeoTransform)</li> <li>width (GridData, GridGraph, LASFile, MultiBand)</li> <li>with_border (LASData)</li> <li>write (LASData)</li> <li>write_to_dxf (Polyline)</li> <li>what (TaskException)</li> </ul>"},{"location":"blaze/class_member_functions/#x","title":"x","text":"<ul> <li>x (Coordinate2D, GeoTransform)</li> </ul>"},{"location":"blaze/class_member_functions/#y","title":"y","text":"<ul> <li>y (Coordinate2D, GeoTransform)</li> </ul>"},{"location":"blaze/class_member_functions/#z","title":"z","text":"<ul> <li>zoom_to_fit (Camera)</li> <li>z (Coordinate3D)</li> </ul>"},{"location":"blaze/class_member_functions/#_1","title":"~","text":"<ul> <li>~AsyncLASData (AsyncLASData)</li> <li>~Color (Color)</li> <li>~ConfigEditor (ConfigEditor)</li> <li>~GDALDataset_w (GDALDataset_w)</li> <li>~GLWidget (GLWidget)</li> <li>~ImgGrid (ImgGrid)</li> <li>~LASLayerRenderer (LASLayerRenderer)</li> <li>~Layer (Layer)</li> <li>~LayerRenderer (LayerRenderer)</li> <li>~Main3DWindow (Main3DWindow)</li> <li>~MainWindow (MainWindow)</li> <li>~PointLayer (PointLayer)</li> <li>~ProgressObserver (ProgressObserver)</li> <li>~ProgressTracker (ProgressTracker)</li> <li>~TimeFunction (TimeFunction)</li> </ul>"},{"location":"blaze/class_member_functions/#_","title":"_","text":"<ul> <li>_set_proportion (ProgressTracker)</li> </ul>"},{"location":"blaze/class_member_variables/","title":"Class Member Variables","text":""},{"location":"blaze/class_member_variables/#b","title":"b","text":"<ul> <li>blocking_threshold (BlockingThresholdColorPair, CanopyConfig)</li> <li>border_width (Config)</li> <li>buildings (Config)</li> <li>bin_resolution (GridConfig)</li> <li>background_color (VegeConfig)</li> </ul>"},{"location":"blaze/class_member_variables/#c","title":"c","text":"<ul> <li>color (BlockingThresholdColorPair, BuildingsConfig, ContourConfig, WaterConfig)</li> <li>contours (Config)</li> <li>configs (ContourConfigs, WaterConfigs)</li> <li>coord (PriorityPoint)</li> <li>catchment (Stream, WaterConfig)</li> <li>coords (Stream)</li> <li>colors (VegeHeightConfig)</li> </ul>"},{"location":"blaze/class_member_variables/#d","title":"d","text":"<ul> <li>dataset (GDALDataset_w, GPKGWriter)</li> <li>downsample_factor (GridConfig)</li> <li>dpi (RenderConfig)</li> </ul>"},{"location":"blaze/class_member_variables/#g","title":"g","text":"<ul> <li>grid (Config)</li> <li>ground (Config)</li> <li>geoTransform (GeoTransform)</li> <li>gl_widget (Main3DWindow)</li> </ul>"},{"location":"blaze/class_member_variables/#h","title":"h","text":"<ul> <li>height_configs (VegeConfig)</li> </ul>"},{"location":"blaze/class_member_variables/#i","title":"i","text":"<ul> <li>interval (ContourConfig)</li> </ul>"},{"location":"blaze/class_member_variables/#l","title":"l","text":"<ul> <li>las_files (Config)</li> <li>layer_names (GPKGWriter)</li> <li>layer (Polyline)</li> </ul>"},{"location":"blaze/class_member_variables/#m","title":"m","text":"<ul> <li>m_data_promise (AsyncLASData)</li> <li>m_mutex (AsyncLASData)</li> <li>m_thread (AsyncLASData)</li> <li>m_tracker (AsyncProgressTracker)</li> <li>m_data (CMYKColor, Coordinate2D, FlexGrid, Grid, RGBColor)</li> <li>m_direction (Camera)</li> <li>m_fov (Camera)</li> <li>m_height (Camera, Contour, ContourPoint, GridData)</li> <li>m_position (Camera)</li> <li>m_up (Camera, ContourPoint)</li> <li>m_width (Camera, GridData)</li> <li>m_world_offset (Camera)</li> <li>max_height (CanopyConfig, VegeHeightConfig)</li> <li>min_height (CanopyConfig, VegeHeightConfig)</li> <li>m_config (ConfigEditor)</li> <li>m_updating_ui (ConfigEditor)</li> <li>m_is_loop (Contour)</li> <li>m_points (Contour, LASData, LASLayerRenderer)</li> <li>min_points (ContourConfig)</li> <li>min_interval (ContourConfigs)</li> <li>m_down (ContourPoint)</li> <li>m_next (ContourPoint)</li> <li>m_prev (ContourPoint)</li> <li>m_slope (ContourPoint)</li> <li>m_z (Coordinate3D)</li> <li>m_dir (Direction2D, LineCoord2D)</li> <li>maxx (Extent2D)</li> <li>maxy (Extent2D)</li> <li>minx (Extent2D)</li> <li>miny (Extent2D)</li> <li>maxz (Extent3D)</li> <li>minz (Extent3D)</li> <li>m_data_size (FlexGrid)</li> <li>m_data_type (FlexGrid)</li> <li>m_camera (GLWidget)</li> <li>m_last_mouse_pos (GLWidget)</li> <li>m_layers (GLWidget)</li> <li>m_point_radius_loc (GLWidget, LASLayerRenderer)</li> <li>m_proj_matrix_loc (GLWidget, LASLayerRenderer)</li> <li>m_projection (GLWidget, GeoGridData, GeoProjection, LASFile)</li> <li>m_renderers (GLWidget)</li> <li>m_vao (GLWidget, LASLayerRenderer)</li> <li>m_vbo (GLWidget, LASLayerRenderer)</li> <li>m_transform (GeoGridData)</li> <li>m_repeats (Grid)</li> <li>m_horizontal (GridGraph)</li> <li>m_vertical (GridGraph)</li> <li>max_ground_intensity (GroundConfig)</li> <li>min_ground_intensity (GroundConfig)</li> <li>m_img (ImgGrid)</li> <li>m_intensity_range (LASData)</li> <li>m_bounds (LASFile)</li> <li>m_filename (LASFile)</li> <li>m_original_bounds (LASFile)</li> <li>m_spatial_index (LASFile)</li> <li>m_las_file (LASLayer)</li> <li>m_data_mutex (LASLayerRenderer)</li> <li>m_data_updated (LASLayerRenderer)</li> <li>m_layer (LASLayerRenderer)</li> <li>m_shader (LASLayerRenderer)</li> <li>m_classification (LASPoint)</li> <li>m_intensity (LASPoint)</li> <li>m_name (Layer, TimeFunction)</li> <li>m_data_update_required (LayerRenderer)</li> <li>m_crossing_dir (LineCoord2DCrossing)</li> <li>m_grids (MultiBand)</li> <li>m_last_progress (ProgressBar)</li> <li>m_progress (ProgressBox)</li> <li>m_child (ProgressObserver)</li> <li>m_observer (ProgressTracker)</li> <li>m_proportion (ProgressTracker)</li> <li>m_subtracker_range (ProgressTracker)</li> <li>m_progress_tracker (ProgressTrackerBar, TimeFunction)</li> <li>m_tracker_obtained (ProgressTrackerBar)</li> <li>m_what (TaskException)</li> <li>m_start (Timer)</li> </ul>"},{"location":"blaze/class_member_variables/#n","title":"n","text":"<ul> <li>name (Polyline, VegeHeightConfig)</li> </ul>"},{"location":"blaze/class_member_variables/#o","title":"o","text":"<ul> <li>output_directory (Config)</li> <li>outlier_removal_height_diff (GroundConfig)</li> </ul>"},{"location":"blaze/class_member_variables/#p","title":"p","text":"<ul> <li>processing_steps (Config)</li> <li>projection (GPKGWriter)</li> <li>priority (PriorityPoint)</li> </ul>"},{"location":"blaze/class_member_variables/#r","title":"r","text":"<ul> <li>relative_path_to_config (Config)</li> <li>render (Config)</li> </ul>"},{"location":"blaze/class_member_variables/#s","title":"s","text":"<ul> <li>secondary_priority (PriorityPoint)</li> <li>scale (RenderConfig)</li> </ul>"},{"location":"blaze/class_member_variables/#u","title":"u","text":"<ul> <li>ui (ConfigEditor, Main3DWindow, MainWindow, ProgressBox)</li> </ul>"},{"location":"blaze/class_member_variables/#v","title":"v","text":"<ul> <li>value (BlazeBool)</li> <li>vege (Config)</li> <li>vertices (Polyline)</li> </ul>"},{"location":"blaze/class_member_variables/#w","title":"w","text":"<ul> <li>water (Config)</li> <li>width (ContourConfig, WaterConfig)</li> </ul>"},{"location":"blaze/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"blaze/class_member_typedefs/#t","title":"t","text":"<ul> <li>T (Grid)</li> </ul>"},{"location":"blaze/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (Grid)</li> </ul>"},{"location":"blaze/class_member_enums/","title":"Class Member Enums","text":""},{"location":"blaze/class_member_enums/#d","title":"d","text":"<ul> <li>Dir (Direction2D)</li> </ul>"},{"location":"blaze/namespace_members/","title":"Namespace Members","text":""},{"location":"blaze/namespace_members/#s","title":"s","text":"<ul> <li>Scalar (cv)</li> <li>SERIALIZE_ENUM_STRICT (nlohmann)</li> <li>source_location (std)</li> </ul>"},{"location":"blaze/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"blaze/namespace_member_functions/#s","title":"s","text":"<ul> <li>SERIALIZE_ENUM_STRICT (nlohmann)</li> </ul>"},{"location":"blaze/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"blaze/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"blaze/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>Scalar (cv)</li> <li>source_location (std)</li> </ul>"},{"location":"blaze/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"blaze/functions/","title":"Functions","text":""},{"location":"blaze/functions/#a","title":"a","text":"<ul> <li>average (las_file.hpp)</li> <li>adjust_ground_to_slope (process.cpp)</li> </ul>"},{"location":"blaze/functions/#b","title":"b","text":"<ul> <li>bool_grid (grid_ops.hpp)</li> <li>border_ranges (las_file.hpp)</li> </ul>"},{"location":"blaze/functions/#c","title":"c","text":"<ul> <li>color_equals (config_editor.cpp)</li> <li>create_color_icon (config_editor.cpp)</li> <li>crosses_contour (contour.hpp)</li> <li>convert_geo_keys_to_wkt (las_file.hpp)</li> <li>copy_from (las_file.hpp)</li> <li>catchment_size (water.cpp)</li> </ul>"},{"location":"blaze/functions/#d","title":"d","text":"<ul> <li>deg2rad (camera.hpp)</li> <li>dxf_entities (dxf.hpp)</li> <li>dxf_footer (dxf.hpp)</li> <li>dxf_header (dxf.hpp)</li> <li>downsample (grid_ops.hpp)</li> <li>double_to_string (to_string.hpp)</li> </ul>"},{"location":"blaze/functions/#e","title":"e","text":"<ul> <li>external_border_ranges (las_file.hpp)</li> <li>extract_borders (las_file.hpp)</li> </ul>"},{"location":"blaze/functions/#f","title":"f","text":"<ul> <li>fill_depressions (water.cpp, water.hpp)</li> <li>flows_to (water.cpp)</li> </ul>"},{"location":"blaze/functions/#g","title":"g","text":"<ul> <li>get_color_name (config_editor.cpp)</li> <li>get_contour_heights (contour.hpp)</li> <li>generate_contours (contour_gen.hpp)</li> <li>generate_naive_contours (contour_gen.hpp)</li> <li>gdal_type (tif.cpp)</li> <li>get_asset_dir (resources.cpp)</li> <li>get_local_data_dir (resources.cpp)</li> <li>get_blocked_proportion (vegetation.hpp)</li> <li>get_pixel_heights (process.cpp)</li> </ul>"},{"location":"blaze/functions/#h","title":"h","text":"<ul> <li>has_value (grid_ops.hpp)</li> <li>hill_shade (hill_shade.hpp)</li> </ul>"},{"location":"blaze/functions/#i","title":"i","text":"<ul> <li>interpolate_coordinates (contour.hpp)</li> <li>identify_contours (contour_gen.hpp)</li> <li>interpolate_value (grid.cpp, grid.hpp)</li> <li>interpolate_holes (grid_ops.hpp)</li> <li>identify_sinks (water.cpp, water.hpp)</li> </ul>"},{"location":"blaze/functions/#j","title":"j","text":"<ul> <li>join_contours (contour_gen.hpp)</li> </ul>"},{"location":"blaze/functions/#l","title":"l","text":"<ul> <li>low_pass (vegetation.hpp)</li> </ul>"},{"location":"blaze/functions/#m","title":"m","text":"<ul> <li>main (main.cpp, main_3d.cpp, blaze.cpp, unit_tests.cpp)</li> </ul>"},{"location":"blaze/functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (config_input.cpp, config_input.hpp, las_file.hpp, las_point.hpp, to_string.hpp, timer.hpp)</li> <li>orthogonal_neighbors (coordinate.hpp)</li> </ul>"},{"location":"blaze/functions/#p","title":"p","text":"<ul> <li>process_las_data (process.cpp, process.hpp)</li> <li>process_las_file (process.cpp, process.hpp)</li> </ul>"},{"location":"blaze/functions/#r","title":"r","text":"<ul> <li>rad2deg (camera.hpp)</li> <li>round_down (contour.hpp)</li> <li>read_dxf (dxf.hpp)</li> <li>remove_outliers (grid_ops.hpp)</li> <li>round (las_file.hpp)</li> <li>read_tif (tif.cpp, tif.hpp)</li> <li>run_loop (progress_tracker_helper.cpp, progress_tracker.hpp)</li> <li>round_up (process.cpp)</li> <li>run_with_config (run.cpp, run.hpp)</li> </ul>"},{"location":"blaze/functions/#s","title":"s","text":"<ul> <li>same_type_different_size (grid.cpp)</li> <li>slope (hill_shade.hpp)</li> <li>smoothify (water.cpp)</li> <li>stream_path (water.cpp)</li> <li>stream_paths (water.cpp, water.hpp)</li> <li>streams (water.cpp)</li> </ul>"},{"location":"blaze/functions/#t","title":"t","text":"<ul> <li>TEST (test_contour_gen.cpp, test_progress_tracker.cpp, test_water.cpp)</li> <li>trim_contours (contour_gen.hpp)</li> <li>to_cmyk (colors.hpp)</li> <li>to_rgb (colors.hpp)</li> <li>to_string (to_string.hpp)</li> </ul>"},{"location":"blaze/functions/#u","title":"u","text":"<ul> <li>unreachable (assert.hpp)</li> <li>unique_coord_name (las_file.hpp)</li> </ul>"},{"location":"blaze/functions/#v","title":"v","text":"<ul> <li>validated (config_editor.cpp)</li> <li>vertex_from_dxf (dxf.hpp)</li> </ul>"},{"location":"blaze/functions/#w","title":"w","text":"<ul> <li>write_to_crt (dxf.hpp)</li> <li>write_to_dxf (dxf.hpp)</li> <li>write_to_image_tif (tif.cpp, tif.hpp)</li> <li>write_to_tif (tif.cpp, tif.hpp)</li> </ul>"},{"location":"blaze/functions/#_","title":"_","text":"<ul> <li>_Assert (assert.hpp)</li> <li>_AssertBinOp (assert.hpp)</li> <li>_GDALAssert (gdal_assert.hpp)</li> </ul>"},{"location":"blaze/macros/","title":"Macros","text":""},{"location":"blaze/macros/#a","title":"a","text":"<ul> <li>Assert (assert.hpp)</li> <li>AssertBinOp (assert.hpp)</li> <li>AssertEQ (assert.hpp)</li> <li>AssertGE (assert.hpp)</li> <li>AssertGT (assert.hpp)</li> <li>AssertLE (assert.hpp)</li> <li>AssertNE (assert.hpp)</li> </ul>"},{"location":"blaze/macros/#c","title":"c","text":"<ul> <li>CHECK_SHADER_BIND (layer_renderer.hpp)</li> </ul>"},{"location":"blaze/macros/#d","title":"d","text":"<ul> <li>DEG2RAD (hill_shade.hpp)</li> </ul>"},{"location":"blaze/macros/#f","title":"f","text":"<ul> <li>Fail (assert.hpp)</li> </ul>"},{"location":"blaze/macros/#g","title":"g","text":"<ul> <li>GDALAssert (gdal_assert.hpp)</li> </ul>"},{"location":"blaze/macros/#h","title":"h","text":"<ul> <li>HAS_BUILTIN (assert.hpp)</li> </ul>"},{"location":"blaze/macros/#j","title":"j","text":"<ul> <li>JSON_DIAGNOSTICS (config_input.cpp)</li> </ul>"},{"location":"blaze/macros/#s","title":"s","text":"<ul> <li>SERIALIZE_ENUM_STRICT (config_input.cpp, config_input.hpp)</li> <li>SQ (grid_ops.hpp, hill_shade.hpp, water.cpp)</li> </ul>"},{"location":"blaze/macros/#u","title":"u","text":"<ul> <li>Unimplemented (assert.hpp)</li> </ul>"},{"location":"blaze/variables/","title":"Variables","text":""},{"location":"blaze/variables/#a","title":"a","text":"<ul> <li>ALL_DIRECTIONS (coordinate.hpp)</li> </ul>"},{"location":"blaze/variables/#b","title":"b","text":"<ul> <li>BorderType (las_file.hpp)</li> </ul>"},{"location":"blaze/variables/#c","title":"c","text":"<ul> <li>COLOR_MAP (colors.cpp, colors.hpp)</li> <li>ColorVariant (colors.hpp)</li> </ul>"},{"location":"blaze/variables/#d","title":"d","text":"<ul> <li>DownsampleMethod (grid_ops.hpp)</li> </ul>"},{"location":"blaze/variables/#f","title":"f","text":"<ul> <li>fragmentShaderSource (layer_renderer.hpp)</li> </ul>"},{"location":"blaze/variables/#g","title":"g","text":"<ul> <li>GeoGrid (forward_grid.hpp, grid.hpp)</li> <li>GeoFlexGrid (grid.hpp)</li> <li>GroundMethod (process.cpp)</li> </ul>"},{"location":"blaze/variables/#i","title":"i","text":"<ul> <li>is_specialization_v (grid.hpp)</li> <li>is_std_optional_v (tif.cpp)</li> </ul>"},{"location":"blaze/variables/#j","title":"j","text":"<ul> <li>json (config_input.cpp)</li> </ul>"},{"location":"blaze/variables/#l","title":"l","text":"<ul> <li>LASClassification (las_point.hpp)</li> </ul>"},{"location":"blaze/variables/#o","title":"o","text":"<ul> <li>ORTHOGONAL_DIRECTIONS (coordinate.hpp)</li> <li>OUT_LAS (process.cpp)</li> </ul>"},{"location":"blaze/variables/#p","title":"p","text":"<ul> <li>ProcessingStep (config_input.hpp)</li> </ul>"},{"location":"blaze/variables/#v","title":"v","text":"<ul> <li>vertexShaderSource (layer_renderer.hpp)</li> </ul>"},{"location":"blaze/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}